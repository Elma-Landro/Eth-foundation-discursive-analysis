Titre: Ambients Applied to Ethereum\nAuteur: Martin Becze\nDate: February 1, 2016\nURL: https://blog.ethereum.org/2016/02/01/2458\nCatégorie: Non catégorisé\n\n==================================================\n\nart nnometimes thereum is compared to a singleton irtual achine.  hile this is correct in some sense  think it is a bit more. irst of all what is a singleton in a distributed system t is merely a set of values that some threshold of participants have come to consensus on.   irtual achine is a computational environment that is isolated from the physical computer and from other environments.nn hypervisor allows the physical machine to be multipleed into many s. ccording to this definition a common hypervisor is the web browser where webpages are s. nother eample of a hypervisor would be thereum as each contract  gets its own isolated computational environment.nnhere are many differences between the common web browser and thereum, but one of the more interesting ones is how s communicate and interact with each other. eb browsers don’t provide a way for s to directly interact while thereum on the other hand provides some simple mechanism for  interaction the opcodes , , , .  n this post will eplore the question hat other rules could eist  an we generalize  interactions and provided an abstract framework for these interactions nd from this framework can we reason about distributed hypervisorsnnost of this post will resemblennambient calculusnnbut there are several notable differences from ambient calculus and what is presented here. he diagrams can be thought of asnnbigraphsnnbut they should also be self eplanatory. art  will describe the rules of ambients and then apply them to thereum. art  will discuss scaling in the terms of ambients as laid out by part .nnhat is an mbientnnn ambient is a bounded place in which computation can occur.  boundary determines what is inside and what is outside an ambient.  or ambients we call this boundary a membrane. he area inside an ambient is hierarchical namespace. bjects can eist inside an ambient. he objects are addressable via the namespace. here are three base elements in ambient calculus. bjects, amespaces and essages.nnierarchical amespacesnnne of the most familiar namespace is the file system tree.  amespaces allow us to identify objects with paths or names. amespaces here have the following propertiesnnor every possible path there eists a null or an objectnnt any point in the namespace you can move up or down. his is what is implied by hierarchical.nnvery path has a root associated with it. he root uniquely identifies the content for all the paths below the root. ou can think of the root as a pointer to the content of the path.nnaths can be read from or written tonnessages can be sent along paths to objectsnnbject ypesnnhat is an object t is just a value. n real life computing its just some data.  his data can be interpreted in several different ways. ny bject can be read as data. he pink circle is some data that eists in the grey ambient.nnbjects can also be interpreted as ambients. his allows ambients to have sub-ambients. ere the orange and grey circles are ambients.nnbjects can also be interpreted as ports. wo or more ports form a / channel. hannels allow messages to be sent to ambients in a different namespaces. hannels can be thought of as tunnels through an ambient’s membrane. oth the entrance and eit ports must eist somewhere in a namespace.  ere the green objects represent ports.nnastly messages can also be considered to be an object. essages are  special since they are defined as objects in motion or thought of as objects with velocity.nno ecap bjects can be the following typesnnbjects  
     ata
     ort
     mbient
     essagennessagesnns stated above messages are objects that are in transit. essages can be sent through a namespace and through channels. essages have the following properties that are set by the systems message handler. hey are not all intrinsically part of the message but as you will see later they make working with messages easier.nno - he path to the destination of the message. his is immutable.nnrom - he sender of the message. his is immutable.nnype - he type of message. his is immutable.nnata - he message's body. his is immutable.nneading - he destination relative to its current position. f `eading` is `null` then the message has arrived at its destination and will travel no further. his is not directly encoded in the message but instead set by the systems message handler. his is mutable.nnirection - hich direction the message is traveling. t can either be going ‘out’ of the ambient or going ‘in’ to the ambient. his is mutable.nnessage ypesnnessage have the following types which have corresponding commands used to send them.nnessage  nnet(path, value) - ets a path to a given valuennet(path) - ets a value of the given pathnnetoot(path, root) - sets the root of `path` to `root`nnetoot(path) - ets the path’s rootnnall(path, data) - ends a message along the given pathnnonnect(to, from, options) - creates a channel between two paths.nneletingnnt might not be immediately obvious how to delete an ambient or other objects. o do this we use the `et` and `etoot` message.nnhennetnnmessage sets the value of a path.  etting a path to null is equivalent to deleting  the contents of that path. or eamplennet(‘pinkmbient’, null)nnere the pink ambient is set to null.  ote the the orange ambient was not deleted.nnhennetootnnmessage sets the root of a path. f the root is set tonnnullnnall the path values below the root will become null. or eamplennopyoot(‘pinkmbient’, null)nnwill set the pink ambient’s root to null which will also cause the orange ambient be to null.nnf course if we did something like etoot(‘a’, ‘pinkmbientsoot’) we would copy the pink mbient and all of it contents to path “a”nnterating the through a amespace.nnn many cases it useful to iterate through all the ambients in a given namespace. ne way we could approach this is to `get` each path in the namespace. ut the problem is that most namespaces are infinite.   better way would be to provide an eplicit iteration method.  et's add a messagennessage  nnet(path) - iven a path return the net non-null path in the namespace.nnhis implies that namespaces all must have an order.  lso this provides us with a nice way to build more complicated ambient operations like merging two or more ambients.  e also need this to build type checking.nnembrane computingnnhe ambient’s border is its membrane. t can filter message coming into and going out of it.  or eample the if the grey ambient sends annet(‘bluembient’, null)nnmessage to the path of the ‘bluembient’ it will go through the membrane of the orange ambient. he orange ambient can decided whether or not to let the message pass through.nn embrane nnets walk through a small eample of what programming ambients might look like.nnmbient  is trying send a message to  ambient  but the message has to go through mbient . ince  is a sub-ambient of ,  can control this message. ere is what an api for dealing with messages might look like.  et say that we have a function ‘onessage’ that gets ran whenever the ambient gets a message.  ere is what  membrane could look like.nn/**
* llow any message to pass through the membrane ecept messages from mbient 
* method onessage
* param message - the message that is leaving the ambient
* retruns oolean
*/nnfunction onessage(message) {
  if(essage.sender ! ”” && essage.direction  ‘out’){
    essage.heading  ‘’
  }
}nn filters any messages coming from the path ‘’ that are going out of it.  nstead of letting the message go to its intended location   reroutes the message to location “”.  otice how  set the heading on the message. f  set essage.heading tonnnullnnthen the message would stop there.   can only decide where to forward the message or to stop it.nnhe ability of ambients to filter and decide which message can travel through them is an important one.   his is also known as embrane computing. t will allow you to build fleible and easily composable contracts. specially when it comes to administration of sub-contracts.nnapping ambients to a thereumnnow that we have the basics of ambients let's apply them to a one of our favorite data structures, thennmerkle treenn.  o start you might have already recognized the fact that a contract in thereum is like an ambient and the namespace is provided by the merkle tree.nnmbients  contractsnnamespace the merkle treennhis could be visualized like thisnnn thereum each ambient has an address that is  bytes long and looks like the following ccaededceffcff.   thereum ambients have storage that allow them store store arbitrary values permanently.  torage is accessed and manipulated with the  and  opcodes.  he equivalent to these  are the set and get messages. lso command all is equivalent.nnet  nnet  nnall   nnetoot, etoot and onnect do not have equivalents in thereum currently. etoot and etoot would read from and manipulate the underlying mekle trie.nnow we are going to deviate from  current thereum  to thereum + mbients.  et us say the contract ccaededceffcff sets the value ‘doge’ at the addresses ‘coin’  which isnnfennin he.  he address ccaededceffcff/nnfennwould then contain the value  ‘doge’.   lso ‘doge’ could also be interpreted as code if a all was made to that path.nnersonal ccountsnnets use a personal thereum account as an eample.  or convenience we are going to say the address of the account is “account” which will be represented as the grey ambient.  his ambient would hold the basic signature validation code as seen in thenncurrency and crypto abstractionnn. f the user wanted to place a spending limits on herself then she could create a “avings ccount” which would only permit a certain amount of ether to be spent per day.  urthermore the user could create her own custom ame eg or other financial apps. he hierarchical nature of the ambients allows you to build up administrative “zone”. hey can make code very modular since the “saving account” and other contracts don’t  need to have any code dedicated to checking  if the user is an admin or checking other credential since that could be done by the account’s ambient.nnart  - calabilitynnn this section we will eplore some ideas about scalability in terms of ambients.
he basic idea of scalability is fairly simple. ost methods proposed so far involve these propertiesnneparating some part of the state into a shard that is processed independent of the other shardsnnome sort of cross validation where some portion of a shard’s work is checked by other shards which is usually triggered by cross shard communication.nne are also assuming we have a roof of take algorithm like asper and this algorithm is implemented in a set of ambients. long with casper we have a currency ambient that tracks the amount of ether each account ambient has. hese ambients are grouped together into the system ambient. here maybe many more ambients in the system ambient but for now we will just consider these.nnor now we will simply assume that casper works and produces the correct state for the “thereum mbient”.nnhardingnnf thereum is successful, the volume of transaction will increase over time.  fter a while a high volume of transactions will cause the price of gas to increase. t a certain threshold determined by a hreshold function the asper ambient will  produce a shard.  t should be noted that only from the casper ambient’s perspective is thereum sharded. veryone else sees thereum as one continued namespace etending through many ambients.nnhere is some threshold that is needed to create a shard in asper. his is not the focus of this post but we can image some of the parameters it might be based off of. t could use gasrice to transaction ratio. r could it use a voting system or a bidding system or combination of all them.nnesides the hreshold function we will assume the following about aspernnnyone can contest a state transition.nnalidators are randomly assigned to shards. hese form a validation group that run asper for that shard.nnalidator may be assigned to more than one shardnnew shards must be initially validated by all validatorsnnhe total amount in bond in a validation group of a shard should be equivalent to what the shard is worth.nnreation of hardsnnor now we will assume that new shards will start out as an empty ambient.  ut keep in mind this might not always be the case- for eample a particularly successfully dapp could perhaps pay the asper contract enough to make it worthwhile for the validator to create a shard out of it.  ut for now it is empty.nnhe first thing that happens to the new shard ambient is the system contracts are copied to it. ut we don’t want an eact copy of the current system ambient. his is because it contains the current state. e want an empty currency contract and an empty asper contract, etc.  o do this the thereum ambient must have an “abstract” system ambient from which we then copy. e can image the abstract system ambient would have a message handler that only allowed messages that were copying it. t could looks something like thisnnfunction onessage(message) {
   // disallows messages getting any subambient
   // roots from the abstract system
   if(message.type ! `getoot `  || message.headed ! ‘’){
      message  null // kills the message 
  }
}nnhe new shard would send a `getoot` to the abstract system. hen it would use `setoot` internally to copy the abstract system its namespace.nnart of the threshold function might be pledges from other ambients to move to a new shard once it is created. hen the new shard is created, all the accounts that pledged to move are automatically moved to the new shard. his is done after the system ambient is in place. he accounts are also copied with the `opyoot` command.nnfter they have been copied their original address is replaced by a port (created by the “onnect” command) creating a channel to their new account on the new shard.nnhe currency contract then sets the amount of ether that the shard has to the sum of the accounts that pledge to move.nnastly the in the new shards currency, the contract is populated by the values of the copied accounts.nnractal chainsnnhe end result will be that the top level ambients no longer “see” the individual accounts that are in the new shard, instead it only see the value of the sum of the account on the new shard ($ in the diagram). hile the new shard’s currency contract keeps track of the individual accounts in the shard. his resembles a fractal in the way that part of the whole is encoded in every section of the structure.nnlso if anyone uses the old address of an ambient that moved, their messages will be forwarded to them via the channels. here are some disadvantages to using the channels ) its will be more costly ) there will be higher latency.nninancial solation - ounterfeiting ttacksnnhe shards can be seen forming a hierarchy each shard ambient keeping track of its accounts and the sum of the accounts in its children shards.nnhis creates a strong guarantee of the correctness of account balances. o shard can create counterfeit currency and send it to another shard. urthermore the security is additive. eaning that the more shards that a message crosses the stronger the guarantee that it is correct. e are assuming that every validation group will check that transaction going through it. f a transaction is going from shard  to .. then shards , . and .. all will check the transaction and ask the shard  for merkle proof of the sender’s account. f the transaction was  found to be invalid after the validator’s approved it then the validators in all three groups would lose their deposits. f accounts were defrauded they would first be refunded from the validators deposits.nnet's consider a long range counterfeit attack. his is where a validation group on a shard creates an account with an invalid amount of currency associated with it and then they just leave it in the shard. f they ever try to move it from the shard the parent validation group will request a complete transaction log that shows how the accounts got its money. t this point the attack would fail unless the parent validation group was also compromised. nd in a long range attack the attackers wait until the parent validation group is compromised. he best way to counter this is to make each validation group responsible for the complete history of its shard and not to release the bonds to unbonded validators after several epochs. his gives the  current validation group an incentive to check the previous validation groups work.nnne way in which a validation group can check the previous validation group work quickly is to just sum the transaction graph. e can think of all messages that transfer currency as forming a directed graph. ince we know the global amount of currency that the shard has, a validation group just needs to sum up the total amount the accounts had for each block in the previous epoch and check it against the known global amount.nno recap, several properties that can increase security arennive the arent alidation group an incentive to check the work of their children.nnive validator an incentive to check previous worknnalidation roup roups (ierarchical validation groups)nnalidators may have to put up a very high bond to participate in validation.  he amount of bond needed is a function of the target number of validators which is a function of the number of shards that eists.nnut this poses a problem since if there were a higher number of validators it would be harder to coordinate a bribe attack on a shard but on the other hand asper can become inefficient when there are large number of validators. ne way this might be solved is to have validators themselves composed of validation groups. he validation group would run in a separate ambient on a separate blockchain from thereum.nnn the validation group ambient, work is further subdivided into smaller chunks. ach individual validator would get assigned several ambients from the shard that validator group was assigned to. his should effectively allow even a small device to participate in validation increasing the total number of participants that briber would have to potentially coordinate with.nnhannels outside the thereum ambientnno do this the validation group would create a new ambient that was connected by a channel to the validator group’s ambient. ou might wonder how it is possible to link to an ambient outside of thereum. ut underneath its straightforward.nnnitially there would only be a validators account controlled by multisig on the thereum blockchain. hen the validators would create their own blockchain (represented as an ambient) which would have the same system ambients and asper ambients as thereum. fter creation, the validator group would connect the two ambients with a channel. ny message entering or eiting the ports the must be agreed upon by all the validators, so the channel should also be protected by a multisig. he code for the multisig would eist in the ports message handler. he channel could only be followed by those running both sets of ambients. odes running just the thereum ambient would see the channel but would not be able to follow it.nnhis provides a pattern that could be elsewhere as it provides a generic way to connect arbitrary ambients to the thereum blockchain. hese ambients could stand for the state of your personal computer or an arbitrary feed of data. eyond the eamples given here, there are many other design patterns that make thinking in ambients useful. hile there are still many lacunae ambients could be a useful model for computational environments.  mbients adds a new dimension to thereum’s hypervisor. uite literally too. t allows for contract to be even more modular and provides for a convenient way to create  administrative domains and model many everyday situations.nn and nnere are some additional things to think about.nnetoot would have to fail if the root didn’t eist in the current namespace. f etoot was eplicitly used the parent namespace (../root) then that tree would be copied to the namespace. f this happened between shards the tree would be serialized into a transaction.nnessagennll messages are assumed to be async. messages can timeout.nnessages all have a response. he response need to be recoded as transaction on requesting shard and the responding shard.nnlocks would need two parts in transaction and out transactions.nnapture and delete -  he sibling ambient sets a value to a path above another sibling with code for to create an ambient that deletes all of its sub-ambients.nnolution  any action that might affect a sibling ambient must go through its message handlernnolution  an ambient could define a message handle for all internal message that eplicitly disallowed certain types of messages.nnolution  reintroduce capabilities as presented in ambient calculus