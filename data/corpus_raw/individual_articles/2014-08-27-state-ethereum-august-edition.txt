Titre: State of Ethereum: August Edition\nAuteur: Vitalik Buterin\nDate: August 27, 2014\nURL: https://blog.ethereum.org/2014/08/27/state-ethereum-august-edition\nCatégorie: Non catégorisé\n\n==================================================\n\nevelopment of thereum has been progressing increasingly quickly this past month. he release of o ("proof of concept five") last month the day before the sale marked an important event for the project, as for the first time we had two clients, one written in ++ and one in o, perfectly interoperating with each other and processing the same blockchain. wo weeks later, thennython clientnnwas also added to the list, and nownna ava versionnnis also almost done. urrently, we are in the process of using an initial quantity of funds that we have already withdrawn from the thereum eodus address to epand our operations, and we are hard at work implementing o, the net version in the series, which features a number of enhancements.nnt this point, thereum is at a state roughly similar to itcoin in mid- the clients and protocol work, and people can send transactions andnnbuildnndecentralizednnapplicationsnnwith contracts and evennnpretty user interfacesnninside of  and avascript, but the software is inefficient, the  underdeveloped, networking-level inefficiencies and vulnerabilities will take a while to get rooted out, and there is a very high risk of security holes and consensus failures. n order to be comfortable releasing thereum ., there are only four things that absolutely need to be done protocol and network-level security testing, virtual machine efficiency upgrades, a very large battery of tests to ensure inter-client compatibility, and a finalized consensus algorithm. ll of these are now high on our priority list but at the same time we are also working in parallel on powerful and easy-to-use tools for building decentralized applications, contract standard libraries, better user interfaces, light clients, and all of the other small features that push the development eperience from good to best.nnonnhe major changes that are scheduled for o are as followsnnhe block time is decreased from  seconds to  seconds, usingnna new -based protocolnnthat epands upon our previous efforts at reducing the block time to  secondsnnhennnnandnnnn(unsigned modular addition and unsigned modular multiplication) are added at slotsnnnnandnnnn, respectively. he purpose of these is to make it easier to implement certain kinds of number-theoretic cryptographic algorithms, eg. elliptic curve signature verification. eennherennfor some eample code that uses these operations.nnhe opcodesnnnnandnnnnare removed from their current slots. nstead, we have the new opcodesnnnn,nnnn...nnnnat positionsnnnn...nnfnnand similarlynnnn...nnnnat positionsnnnn...nnfnn.nnnnncopies the nth highest value in the stack to the top of the stack, andnnnnnswaps the highest and (n+)-th highest value on the stack.nnhennwithnnstatement is added to erpent, as a manual way of using these opcodes to more efficiently access variables. ample usage is foundnnherenn. ote that this is an advanced feature, and has a limitation if you stack so many layers of nesting beneath annwithnnstatement that you end up trying to access a variable more than  stack levels deep, compilation will fail. ventually, the hope is that the erpent compiler will intelligently choose between stack-based variables and memory-based variables as needed to maimize efficiency.nnhennnnopcode is added at slotnnfnn.nnnnis similar tonnnn, ecept that () the opcode has  inputs and  outputs (ie. it does not return anything), and () the eecution happens asynchronously, after everything else is finished. ore precisely, the process of transaction eecution now involves () initializing a "post queue" with the message embedded in the transaction, () repeatedly processing the first message in the post queue until the post queue is empty, and () refunding gas to the transaction origin and processing suicides.nnnnadds a message to the post queue.nnhe hash of a block is now the hash of the header, and not the entire block (which is how it really should have been all along), the code hash for accounts with no code is "" instead ofnnsha("")nn(making all non-contract accounts  bytes more efficient), and the to address for contract creation transactions is now the empty string instead of twenty zero bytes.nnn fficiencynnside from these changes, the one major idea that we are beginning to develop is the concept of "native contract etensions". he idea comes from long internal and eternal discussions about the tradeoffs between having a more reduced instruction set ("nnnn") in our virtual machine, limited to basic memory, storage and blockchain interaction, sub-calls and arithmetic, and a more comple instruction set ("nnnn"), including features such as elliptic curve signature verification, a wider library of hash algorithms, bloom filters, and data structures such as heaps. he argument in favor of the reduced instruction set is twofold. irst, it makes the virtual machine simpler, allowing for easier development of multiple implementations and reducing the risk of security issues and consensus failures. econd, no specific set of opcodes will ever encompass everything that people will want to do, so a more generalized solution would be much more future-proof.nnhe argument in favor of having more opcodes is simple efficiency. s an eample, consider thennheapnn).  heap is a data structure which supports three operations adding a value to the heap, quickly checking the current smallest value on the heap, and removing the smallest value from the heap. eaps are particularly useful when building decentralized markets the simplest way to design a market is to have a heap of sell orders, an inverted (ie. highest-first) heap of buy orders, and repeatedly pop the top buy and sell orders off the heap and match them with each other while the ask price is greater than the bid. he way to do this relatively quickly, in logarithmic time for adding and removing and constant time for checking, is using a treennhe key invariant is that the parent node of a tree is always lower than both of its children. he way to add a value to the tree is to add it to the end of the bottom level (or the start of a new bottom level if the current bottom level is full), and then to move the node up the tree, swapping it with its parents, for as long as the parent is higher than the child. t the end of the process, the invariant is again satisfied with the new node being in the tree at the right placenno remove a node, we pop off the node at the top, take a node out from the bottom level and move it into its place, and then move that nodenndownnnthe tree as deep as makes sensennnd to see what the lowest node is, we, well, look at the top. he key point here is that both of these operations are logarithmic in the number of nodes in the tree even if your heap has a billion items, it takes only  steps to add or remove a node. t's a nontrivial eercise in computer science, but if you're used to dealing with trees it's not particularly complicated. ow, let's try to implement this in thereum code. he full code sample for this isnnherenn for those interested thennparent directorynnalso containsnna batched market implementationnnusing these heaps andnnan attemptnnat implementingnnfutarchynnusing the markets. ere is a code sample for the part of the heap algorithm that handles adding new valuesnn# pushnnifnnmsg.datannnnnn]nnnnnnnnsznnnncontract.storagennnnnn]nncontract.storagennnnsz +nnnn]nnnnmsg.datannnnnn]nnknnnnsz +nnnnwhilennknnnnnnnnbottomnnnncontract.storagennnnknn]nntopnnnncontract.storagennnnk/nn]nnifnnbottomnnnntopnncontract.storagennnnknn]nnnntopnncontract.storagennnnk/nn]nnnnbottomnnk /nnnnnnelsennknnnnnncontract.storagennnnnn]nnnnsz +nnnnhe model that we use is thatnncontract.storage]nnstores the size (ie. number of values) of the heap,nncontract.storage]nnis the root node, and from there for anynnn  contract.storage]nn,nncontract.storagen]nnis a node with parentnncontract.storagen/]nnand childrennncontract.storagen*]nnandnncontract.storagen*+]nn(ifnnn*nnandnnn*+nnare less than or equal to the heap size, of course). elatively simple.nnow, what's the problem n short, as we already mentioned, the primary concern is inefficiency. heoretically, all tree-based algorithms have most of their operations take log(n) time. ere, however, the problem is that what we actually have is a tree (the heap) on top of a tree (the thereum atricia tree storing the state) on top of a tree (leveldb). ence, the market designed here actually has lognnnn(n) overhead in practice, a rather substantial slowdown.nns another eample, over the last several days  have written, profiled and testednnerpent code for elliptic curve signature verificationnn. he code is basically a fairly simple port ofnnpybitcointoolsnn, albeit some uses of recursion have been replaced with loops in order to increase efficiency. ven still, the gas cost is staggering an average of about  for one signature verification.nnnd this, mind you, is after adding some optimizations. or eample, see the code for taking modular eponentsnnwith bnnnnmsg.datannnnnn]nnnnwith ennnnmsg.datannnnnn]nnnnwith mnnnnmsg.datannnnnn]nnnnwith onnnnnnnnwith bitnnnnnn^nnnnnnwhilenngtnn(nnbit,nnnn)nnnn#  touch of loop unrolling for % efficiency gainnnonnnnmulmodnn(nnmulmodnn(nno, o, mnn)nn, b ^nn!nn(nn!nn(nnenn&nnbitnn))nn, mnn)nnonnnnmulmodnn(nnmulmodnn(nno, o, mnn)nn, b ^nn!nn(nn!nn(nnenn&nndivnn(nnbit,nnnn))nn)nn, mnn)nnonnnnmulmodnn(nnmulmodnn(nno, o, mnn)nn, b ^nn!nn(nn!nn(nnenn&nndivnn(nnbit,nnnn))nn)nn, mnn)nnonnnnmulmodnn(nnmulmodnn(nno, o, mnn)nn, b ^nn!nn(nn!nn(nnenn&nndivnn(nnbit,nnnn))nn)nn, mnn)nnbitnnnndivnn(nnbit,nnnn)nnreturnnn(nnonn)nnhis takes up  gas for any input. t is still a fairly simple algorithm a more advanced implementation may be able to speed this up by up to %, but even still iterating over  bits is epensive no matter what you do.nnhat these two eamples show is that high-performance, high-volume decentralized applications are in some cases going to be quite difficult to write on top of thereum without either comple instructions to implement heaps, signature verification, etc in the protocol, or something to replace them. he mechanism that we are now working on is an attempt conceived by our lead developer avin ood to essentially get the best of both worlds, preserving the generality of simple instructions but at the same time getting the speed of natively implemented operations native code etensions.nnative ode tensionsnnhe way that native code etensions work is as follows. uppose that there eists some operation or data structure that we want thereum contracts to have access to, but which we can optimize by writing an implementation in ++ or machine code. hat we do is we first write an implementation in thereum virtual machine code, test it and make sure it works, and publish that implementation as a contract. e then either write or find an implementation that handles this task natively, and add a line of code to the message eecution engine which looks for calls to the contract that we created, and instead of sub-calling the virtual machine calls the native etension instead. ence, instead of it taking  seconds to run the elliptic curve recovery operation, it would take only . seconds.nnhe problem is, how do we make sure that the fees on these native etensions are not prohibitive his is where it gets tricky. irst, let's make a few simplifications, and see where the economic analysis leads. uppose that miners have access to a magic oracle that tells them the maimum amount of time that a given contract can take. ithout native etensions, this magic oracle eists now - it consists simply of looking at thennnnof the transaction - but it becomes not quite so simple when you have a contract whosennnnis  and which looks like it may or may not call a few native etensions to speed things up drastically. ut suppose that it eists.nnow, suppose that a user comes in with a transaction spending  gas on miscellaneous business logic and  gas on an optimized elliptic curve operation, which actually costs only the equivalent of  gas of normal eecution to compute. uppose that the standard market-rate transaction fee is  szabo (ie. micro-ether) per gas. he user sets annnnof . szabo, effectively paying for  gas, because he would be unwilling to pay for the entire  gas for the transaction but he knows that miners can process his transaction for  gas' worth of effort. he user sends the transaction, and a miner receives it. ow, there are going to be two casesnnhe miner has enough unconfirmed transactions in its mempool and is willing to epend the processing power to produce a block where the total gas used brushes against the block-level gas limit (this, to remind you, isnn. times the long-term eponential moving averagennof the gas used in recent blocks). n this case, the miner has a static amount of gas to fill up, so it wants the highestnnnnit can get, so the transaction paying . szabo per gas instead of the market rate of  szabo per gas gets unceremoniously discarded.nnither not enough unconfirmed transactions eist, or the miner is small and not willing or able to process every transaction. n this case, the dominating factor in whether or not a transaction is accepted is the ratio of reward to processing time. ence, the miner's incentives are perfectly aligned, and since this transaction has a % better reward to cost rate than most others it will be accepted.nnhat we see is that, given our magic oracle, such transactions will be accepted, but they will take a couple of etra blocks to get into the network. ver time, the block-level gas limit would rise as more contract etensions are used, allowing the use of even more of them. he primary worry is that if such mechanisms become too prevalent, and the average block's gas consumption would be more than % native etensions, then the regulatory mechanism preventing large miners from creating etremely large blocks as a denial-of-service attack on the network would be weakened - at a gas limit of , a malicious miner could make annnunoptimizednncontract that takes up that many computational steps, and freeze the network.nno altogether we have two problems. ne is the theoretical problem of the gaslimit becoming a weaker safeguard, and the other is the fact that we don't have a magic oracle. ortunately, we can solve the second problem, and in doing so at the same time limit the effect of the first problem. he naive solution is simple instead ofnnnnbeing just one value, there would be one defaultnnnnand then a list ofnnaddress, gasprice]nnpairs for specific contracts. s soon as eecution enters an eligible contract, the virtual machine would keep track of how much gas it used within that scope, and then appropriately refund the transaction sender at the end. o prevent gas counts from getting too out of hand, the secondary gas prices would be required to be at least % (or some other fraction) of the original gasprice. he problem is that this mechanism is space-inefficient, taking up about  etra bytes per contract.  possible fi is to allow people to register tables on the blockchain, and then simply refer to which fee table they wish to use. n any case, the eact mechanism is not finalized hence, native etensions may end up waiting until o.nniningnnhe other change that will likely begin to be introduced in o is a new mining algorithm. e (well, primarily lad amfir) have been slowly working on the mining algorithm in ournnmining reponn, to the point where there is a working proof of concept, albeit more research is required to continue to improve its  resistance. he basic idea behind the algorithm is essentially to randomly generate a new circuit every  nonces a device capable of processing this algorithm would need to be capable of processing all circuits that could be generated, and theoretically there should eist some circuit that conceivably could be generated by our system that would be equivalent to , or , or eccak, or any other algorithms in . ence, such a device would have to be a generalized computer - essentially, the aim is something that tried to approach mathematically provable specialization-resistance. n order to make sure that all hash functions generated are secure, a  is always applied at the end.nnf course, perfect specialization-resistance is impossible there will always be some features of a  that will prove to be etraneous in such an algorithm, so a nonzero theoretical  speedup is inevitable. urrently, the biggest threat to our approach is likely some kind of rapidly switchingnnnn. owever, there is an economic argument which shows that s will survive even if s have a speedup, as long as that speedup is low enough seennmy earlier article on miningnnfor an overview of some of the details.  possible tradeoff that we will have to make is whether or not to make the algorithm memory-hard  resistance is hard enough as it stands, and memory-hardness may or may not end up interfering with that goal (cf.nneter odd's argumentsnnthat memory-based algorithms may actually encourage centralization) if the algorithm is not memory-hard, then it may end up being -friendly. t the same time, we are looking into hybrid-proof-of-stake scoring functions as a way of augmenting o with further security, requiring % attacks to simultaneously have a large economic component.nnith the protocol in an increasingly stable state, another area in which it is time to start developing is what we are starting to call "thereum ." - mechanisms on top of thereum as it stands today, without the need for any new adjustments to the core protocol, that allow for increased scalability and efficiency for contracts and decentralized applications, either by cleverly combining and batching transactions or by using the blockchain only as a backup enforcement mechanism with only the nodes that care about a particular contract running that contract by default. here are a number of mechanism in this category this is something that will see considerably increased attention from both ourselves and hopefully others in the community.