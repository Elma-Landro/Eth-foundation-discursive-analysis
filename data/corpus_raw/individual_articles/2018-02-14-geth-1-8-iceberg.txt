Titre: Geth 1.8 - Iceberg¹\nAuteur: Péter Szilágyi\nDate: February 14, 2018\nURL: https://blog.ethereum.org/2018/02/14/geth-1-8-iceberg\nCatégorie: Non catégorisé\n\n==================================================\n\nfter waaay too much time under development, we're proud to finally announce version .. of the o thereum clientnncebergnn! he release fies a lot of pain points felt by the community and ships a few notable new features, tallying up tonn~ modificationsnn!nnlease note, this release introduces a few breaking changes that may affect certain power users! f you are running a production setup, make sure you read the "reaking changes" section at the end of this blog post!nnlient synchronizationnn huge amount of work went into this release that isn't immediately visible, rather they're under the hood changes to make everybody's life just a little bit more pleasant. e've tried to address many of the issues our users were reporting around syncing and block processing. e're not quite where we'd like to be, but the eperience with v.. should blow all previous releases out of the water.nneliable light clientnneth v.. – released shortly after evcon – was the first release to ship version  of the light client protocol. t was meant to be a huge improvement over version , finally enabling log filtering from thereum contracts. t broke the light client.nnhe breakage was massive, with multiple eperimental protocols (discovery v, light client v) playing badly with each other. eth v.. tried to advertise bothnnles/nnandnnles/nn, which conflicted in the discovery, breaking bothnnles/nnservers would crash serving some light client requests and discovery v, running behind an undocumented port, didn't help either.nneth v.. tries to pick up all the pieces and makennles/nnwhat it was supposed to be in v... e've dropped support fornnles/nnin the discovery, so there should be no more problems finding peers while we iron out the kinks. ight servers have been polished up to be more robust with eisting connections, as well as etended to cleanly separatennethnnandnnlesnnpeers, preventing server side starvation. ersion  and  of the discovery protocols are also running on the same port, and will from now on better avoid issues with firewalls or  traversals.nnith all of the above changes,nnthe light client in v.. should find servers within a few seconds from startup, and synchronizing the mainnet should finish within a minutenn. ince light clients rely on charitable nodes serving them, we ask anyone runningnnnon-sensitivennfull nodes with spare capacity to consider enabling the light server to help people with less capable hardware.nneliable fast syncnnor a long time now we've been receiving reports from users eperiencing fast sync hangs with a "stalling peer" error message, or that trying to synchronize on an average machine often crashes with an "out of memory" error. hese issues have become more and more prevalent as the thereum mainnet grew, yet they have been elusive to us due to their rare occurrence.nnhe heavy internal rewrites allowed us to reliably reproduce and fi these issues. he hang was a very rare race that occurred when state sync restarted thennfi for which is amusingnngiven that it took usnna yearnnto catch. he memory issue was also fied by aggressively capping the amount of memory that sync may consume.nnhe final result of these optimizations is that fast sync became stable again. rom one perspective there are no more hangs, so you don't have to constantly monitor the sync progress. rom the other perspective memory usage is constant, so there's no need for machines with insane .nnhe above chart plots the memory usage during mainnet fast sync of twonnm.largennmazon instance types (purple  eth ., blue  eth .). t the time of writing, fast sync completes in around  hours on these instance types. he eponential growth of thereum however resulted in a state trie of around  million nodes, the import of which can take even half a day on end-user laptops (with an ). opefully . will tackle this issue.nnnitial state pruningnnthereum organizes its state into a gigantic trie data structure. t the bottom – in the leaves we have the accounts – and on top of the accounts we have an th order erkle trie cryptographically guaranteeing forgery resistance. e have one of these giant tries for each and every block, the latest of which weighing at around  million nodes. ost of these nodes are common between subsequent blocks, but every new block does add a few thousand new nodes into the trie.nnf we would like to know what our balance was years ago, we'd have to maintain every single version of this erkle trie since the genesis block, which could total to almost  of data currently. n reality almost nobody cares about historical data – as long as it can be recomputed – rather only about thennrecentnnstate of the network. ast sync gets you "quickly" to the recent state, but blindly piling blocks on top will forever use more and more disk space.nnhe important property of the erkle tries to be aware of is that whilst every new block adds thousands of new nodes, thousands of old ones become obsolete at the same time. f we could easily delete these obsolete ones, disk growth would be significantly capped. owever, once the data is on disk, it's etremely epensive to get rid of them.nneth v.. takes an initial stab at the problem by introducing an in-memory cache in which to store the recent trie nodes. s long as the nodes are in memory, they are cheap to reference count and garbage collect. nstead of writing each trie node to disk, we keep it around as long as possible, hoping that a future block will make it obsolete and save us a database write.nneth v.. by default will use % of the user's cache allowance (nn--cachenn) for trie caching and will flush to disk either if the memory allowance is eceeded, or if block processing time since the last flush eceeds  minutes. his doesn't completely solve database growth just yet, but looking at the disk stats between v. (purple) and v. (blue) in the course of a single week, pruning makes a huge difference.nnransaction tracingnnretty much since forever, eth supportednntracing transactionsnnby dumping the eecuted opcodes. hese dumps can be invaluable for finding consensus issues among clients, but theynnaren't the nicestnnto look at. lthough post-processing these traces is possible, it's a waste of resources to collect so much data just to throw most of it away.nnustom tracing scriptsnnhe v. release family of eth introduced a new way to trace transactions by allowing users to write custom avacript scripts that run within the node while tracing. nstead of producing pre-defined traces, users could gather whatever data they deemed useful without having to eport everything else. lthough we did use it internally, the feature never really graduated to a useful and robust enough state for wide spread use.nneth v.. however completely revamps the custom tracing support. or starters, we've replaced thennottovmnnwe used previously to run the tracers, tonnduktapenn, resulting in a  speed increase. e no longer require the state upon which a transaction relies to be present to trace it, rather the tracer can reconstruct anything missing from historical states (bearing the cost of re-eecuting the blocks in memory). urthermore, when tracing multiple transactions at once (i.e. an entire block), those are eecuted concurrently, slashing tracing time by the number of available  cores.nnll said and done, writing a custom tracernnis complicatednn, taking up a significant time even for veteran thereum developers. s such, we've made the decision to providenna few tracers out of the bonnfor users to use, and potentially improve. e eagerly await any community improvements to these, or even the addition of brand new ones!nnhenncallracernnis a full blown transaction tracer that etracts and reports all the internal calls made by a transaction, along with any information deemed useful.nnhennprestateracernnoutputs sufficient information to create a local eecution of the transaction from a custom assembled genesis block.nnhennbyteracernnsearches for byte-identifiers, and collects them for post-processing. t collects the methods identifiers along with the size of the supplied data, so a reversed signature can be matched against the size of the data.nn.g. eecuting thenncallracernnagainst thennsame transactionnnlinked above gets us a much much friendlier outputnndebug.traceransaction("hash", {tracer "callracer"})nn.nntreaming chain tracersnnracing an entire block of transactions is a lot more optimal than tracing transactions one-by-one, because we don't need to generate the pre-state for each one individually. his holds true even more strongly if generating the starting state entails re-eecuting multiple past blocks (pruned state). he same issue however arises when tracing multiple blocks too if the pre-state was pruned, it's a waste to throw away regenerated state just to do it all over for the net block.nno cater for tracing multiple subsequent blocks with minimal overhead, eth v.. introduces a new  endpoint that can trace chain segments. his endpoint can reuse the computed states in between blocks without rerunning transactions over and over again. hat's more, individual blocks are traced concurrently, so total tracing time gets proportionally lower the more  cores you throw at it.nnracing a transaction or a block takes a relatively short amount of time. racing a chain segment however can take arbitrarily long, depending on how long the chain is and what transactions are included in it. t would be very impractical to wait for all the transactions to be traced before starting to return the ones already done. his rules out chain tracing as a simple  method. nstead, eth v.. implements chain tracing via a subscription (/ebocket), where the user starts a background tracing process and eth will stream the results until all transactions are tracednn$nnncnn- /work/temp/rinkeby/geth.ipcnn{nn"id"nnnnnn,nn"method"nnnn"debug_subscribe"nn,nn"params"nnnnnn"tracehain"nn,nn""nn,nn"fff"nn,nn{nn"tracer"nnnn"callracer"nn}nn]nn}nn{nn"jsonrpc"nnnn"."nn,nn"id"nn,nn"result"nnnn"edeeccbefdbaabbbce"nn}nn{nn"jsonrpc"nnnn"."nn,nn"method"nnnn"debug_subscription"nn,nn"params"nnnn{nn"subscription"nnnn"edeeccbefdbaabbbce"nn,nn"result"nnnn{nn"block"nnnn""nn,nn"hash"nnnn"dbfdffdfbabaedbbeefdbcfdb"nn,nn"traces"nnnnnn{nn"from"nnnn"bdbdeeabbd"nn,nn"gas"nnnn""nn,nn"gassed"nnnn""nn,nn"input"nnnn""nn,nn"output"nnnn""nn,nn"time"nnnn".µs"nn,nn"to"nnnn"edfaddbcefdbfdbdeae"nn,nn"type"nnnn""nn,nn"value"nnnn"debba"nn}nn]nn}nn}nn}nn{nn"jsonrpc"nnnn"."nn,nn"method"nnnn"debug_subscription"nn,nn"params"nnnn{nn"subscription"nnnn"edeeccbefdbaabbbce"nn,nn"result"nnnn{nn"block"nnnn"f"nn,nn"hash"nnnn"acbaaadbceecedbfebedfea"nn,nn"traces"nnnnnn{nn"from"nnnn"bdbdeeabbd"nn,nn"gas"nnnn""nn,nn"gassed"nnnn""nn,nn"input"nnnn""nn,nn"output"nnnn""nn,nn"time"nnnn".µs"nn,nn"to"nnnn"bedcfffddadebafbefbeb"nn,nn"type"nnnn""nn,nn"value"nnnn"debba"nn}nn]nn}nn}nn}nn{nn"jsonrpc"nnnn"."nn,nn"method"nnnn"debug_subscription"nn,nn"params"nnnn{nn"subscription"nnnn"edeeccbefdbaabbbce"nn,nn"result"nnnn{nn"block"nnnn"f"nn,nn"hash"nnnn"eaecaccbddfcaeffefaaffb"nn,nn"traces"nnnnnn{nn"from"nnnn"bedcfffddadebafbefbeb"nn,nn"gas"nnnn"a"nn,nn"gassed"nnnn"ed"nn,nn"input"nnnn"cfebbcfcffffffffbbfebfebffcbfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffbffffdaaffebbaaaabcebdeaaafdfecbcabbefbdaafbe"nn,nn"output"nnnn"cffffffffbbfebfebffcbfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffbffffdaaffebbaaaabcebdeaaafdfecbcabbefbdaafbe"nn,nn"time"nnnn".µs"nn,nn"to"nnnn"cfebdefffcd"nn,nn"type"nnnn""nn,nn"value"nnnn""nn}nn]nn}nn}nn}nn{nn"jsonrpc"nnnn"."nn,nn"method"nnnn"debug_subscription"nn,nn"params"nnnn{nn"subscription"nnnn"edeeccbefdbaabbbce"nn,nn"result"nnnn{nn"block"nnnn"fff"nn,nn"hash"nnnn"ccbceeebddacffdefeefdfbfaacb"nn}nn}nn}nnative eventsnnor about one and a half years now we've supported generatingnno wrappers for thereum contractsnn. hese are etremely useful as they allow calling and transacting with contracts directly using o. he main benefit is that ournnabigennntool generates static types for just about everything, ensuring that code interacting with contracts is compile-time type safe. t's very useful during development too, as any contract  change immediately produces compilation errors, eliminating most runtime failures.nnhat being said,nnabigennnwas always lacking support for thereum contract log filtering you couldn't filter past events, and you couldn't subscribe to future events. eth v.. finally landsnnevent filtering for native dappsnn! o wrappers generated bynnabigennnfrom now on will contain two etra methods for each event,nnilteryventnnandnnatchyventnn. dhering tonnabigennn's strict type safety, both event filters and returned logs are strongly and statically typed. evelopers only need to work with o types, and everything else gets taken care of under the hood.nn nice eample is filtering for kasha posts on the inkeby test network. he publishing event is defined asnnevent ublish(address indeed author, bytes indeed entryd)nn. iltering for posts created by addressesnnlicennornnobnnwould look likenncontract.ilterublishnn(nnnil,nnnn]nncommon.ddressnn{nn"lice"nn,nn"ob"nn}nn, nilnn)nnevcon puppethnns many of you probably know, thenninkebynntest network is almost fully managed viannpuppethnn. or those who don't,nnpuppethnnis "a tool to aid you in creating a new thereum network down to the genesis block, bootnodes, signers, ethstats server, crypto faucet, wallet browsers, block eplorer, dashboard and more without the hassle that it would normally entail to manually configure all these services one by one".nnuppeth was an invaluable tool for us in maintaining the inkeby network since its creation  months ago. t was fit for its purpose – as an internal tool – alas it had a lot of rough edges. e wanted to make this tool useful not just for inkeby, rather for all other developer networks out there too, so for evcon we've heavily polished it. t became user friendly(-er), it gained support for configuring arity, ++ thereum, pyethapp and armony (onnnethashnnconsensus) and it could deploy online wallets and basic block eplorers too.nnt seems to have been ages since evcon and uppeth being merged on master, but v.. finally ships the net incarnation ofnnpuppethnnfor those who have been holding out. o on and deploy your own thereum network!nnreaking changesnniscovery v and v have been merged to use the same  port ( by default). f you are doing manual peer management and using the light client, you may need to ensure your v.. clients are pointed to port  and not  as previously.nnrie pruning is enabled on allnn--syncmodennvariations (includingnn--syncmodefullnn). f you are running an archive node where you would like to retain all historical data, you should disable pruning viann--gcmodearchivenn.nnnly the latest  tries are kept in memory, most tries are garbage collected. f you are running a block eplorer or other service relying on transaction tracing without an archive node (nn--gcmodearchivenn), you need to trace within this window! lternatively, specify thennreeec nntracer option to allow regenerating historical state and ideally switch to chain tracing which amortizes overhead across all traced blocks.nnative events rely on modifications to internalnngo-ethereumnntypes within generated code. f you are using wrappers generated prior to v.., you will need to regenerate them to be compatible with the new code base.nnhe /  endpoint was etended withnn rebind protectionnn. f you are running an  endpointnnaddressed by name rather than nn, run withnn--rpcvhostsyour.domainnnto continue accepting remote requests.nnlosing remarksnnlthough we consider eth .. our best release yet, we urge everyone to eercise caution with the upgrade and monitor it closely afterwards as it does contain non-trivial changes. e would also like to emphasize thatnneth .. introduces state pruning, which is backward incompatible with previous versions of ethnn(old versions reject the pruned database).nns with previous large releases, our recommendation for production users it to sync from scratch, and leave the old database backed up until you confirm that the new release works correctly for all your use cases.nnor a full rundown of the changes please consult thenneth .. release milestonenn.nninaries and mobile libraries are available on ournndownload pagenn.nncknowledgementnns a final note for this release, we'd like to shout out tonning hannnfor all of her insanely hard work as the previous  ecutive irector! mong her multitude of tasks, she always found the time to proof-read our release posts, correcting anynnlost-in-translationnnerrors whilst also ensuring clarity for our less technical readers. hank you for everything you did for the oundation and the community!nn¹ "ecause the previous version was un-sync-able" ~ick ohnson