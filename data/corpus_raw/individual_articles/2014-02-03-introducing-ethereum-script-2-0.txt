Titre: Introducing Ethereum Script 2.0\nAuteur: Vitalik Buterin\nDate: February 3, 2014\nURL: https://blog.ethereum.org/2014/02/03/introducing-ethereum-script-2-0\nCatégorie: Non catégorisé\n\n==================================================\n\nhis post will provide the groundwork for a major rework of the thereum scripting language, which will substantially modify the way  works although still keeping many of the core components working in the eact same way. he rework is necessary as a result of multiple concerns which have been raised about the way the language is currently designed, primarily in the areas of simplicity, optimization, efficiency and future-compatibility, although it does also have some side-benefits such as improved function support. his is not the last iteration of  there will likely be many incremental structural improvements that can be made to the spec, but it does serve as a strong starting point.nns an important clarification, this rework will have little effect on the thereum , the stripped-down-ython-like language in which you can write amecoin in five lines of code. he  will still stay the same as it is now. e will need to make updates to the compiler (an alpha version of which is now available in ython atnnhttp//github.com/ethereum/compilernnor as a friendly web interface atnnhttp//...nn) in order to make sure the  continues to compile to new versions of , but you as an thereum contract developer working in - should not need to see any changes at all.nnroblems with nnver the last month of working with , several problems with the language’s design have become apparent. n no particular order, they are as followsnnoo many opcodesnn– looking at the specificationnnas it appears todaynn,  now has eactly  opcodes – less than the  opcodes found innnitcoin criptnn, but still far more than the theoretically minimal - opcodes needed to have a functional uring-complete scripting language. ome of those opcodes are necessary because we want the scripting language to have access to a lot of data – for eample, the transaction value, the transaction source, the transaction data, the previous block hash, etc like it or not, there needs to be a certain degree of compleity in the language definition to provide all of these hooks. ther opcodes, however, are ecessive, and comple as an eample, consider the current definition of  or . ith the way the language is designed right now, that is necessary for efficiency otherwise, one would have to write  in thereum script by hand, which might take many thousands of s. ut ideally, there should be some way of eliminating much of the bloat.nnot future-compatiblenn– the eistence of the special crypto opcodes does make  much more efficient for certain specialized applications thanks to them, computing  takes only   instead of the many thousands of basefees that it would take if  was implemented in  directly same with ,  and secpk elliptic curve operations. owever, it is absolutely not future-compatible. ven though these eisting crypto operations will only take  ,  will take several thousand s, as will ed signatures, the quantum-proofnnnn,  and erocoin math, and any other constructs that will appear over the coming years. here should be some natural mechanism for folding such innovations in over time.nnot deduplication-friendlynn– the thereum blockchain is likely to become etremely bloated over time, especially with every contract writing its own code even when the bulk of the code will likely be thousands of people trying to do the eact same thing. deally, all instances where code is written twice should pass through some process of deduplication, where the code is only stored once and only a pointer to the code is stored twice. n theory, thereum’s atricia trees do this already. n practice, however, code needs to be in eactly the same place in order for this to happen, and the eistence of jumps means that it is often difficult to abitrarily copy/paste code without making appropriate modifications. urthermore, there is no incentivization mechanism to convince people to reuse eisting code.nnot optimization-friendlynn– this is a very similar criterion to future-compatibility and deduplication-friendliness in some ways. owever, here optimization refers to a more automatic process of detecting bits of code that are reused many times, and replacing them withnnmemoizednnor compiled machine code versions.nneginnings of a olution eduplicationnnhe first issue that we can handle is that of deduplication. s described above, thereum atricia trees provide deduplication already, but the problem is that achieving the full benefits of the deduplication requires the code to be formatted in a very special way. or eample, if the code in contract  from inde  to inde  is the same as the code in contract  from inde  to inde , then deduplication happens. owever, if the code in contract  is offset at all modulo  (eg. from inde  to inde ), then no deduplication takes place at all. n order to remedy this, there is one relatively simple solution move from a dumb heary atricia tree to a more semantically oriented data structure. hat is, the tree represented in the database should mirror the abstract synta tree of the code.nno understand what  am saying here, consider some eisting  codenn                                        nnn the atricia tree, it looks like thisnn(
(               )
(               )
(        )
)nnnd here is what the code looks like structurally. his is easiest to show by simply giving the - it was compiled fromnnif t.value   * ^
stop
if contract.storaget.data]] or t.data]  
stop
contract.storaget.data]]  t.data]nno relation at all. hus, if another contract wanted to use some semantic sub-component of this code, it would almost certainly have to re-implement the whole thing. owever, if the tree structure looked somewhat more like thisnn(
(

(          )
()
)
(

(             )
()
)
(        )
)nnhen if someone wanted to reuse some particular piece of code they easily could. ote that this is just an illustrative eample in this particular case it probably does not make sense to deduplicate since pointers need to be at least  bytes long to be cryptographically secure, but in the case of larger scripts where an inner clause might contain a few thousand opcodes it makes perfect sense.nnmmutability and urely unctional odennnother modification is that code should be immutable, and thus separate from data if multiple contracts rely on the same code, the contract that originally controls that code should not have the ability to sneak in changes later on. he pointer to which code a running contract should start with, however, should be mutable.nn third common optimization-friendly technique is the make a programming language purely functional, so functions cannot have any side effects outside of themselves with the eception of return values. or eample, the following is a pure functionnndef factorial(n)
prod  
for i in range(,n+)
prod * i
return prodnnowever, this is notnn  
def net_integer()
 + 
return nnnd this most certainly is notnnimport os
def happy_fluffy_function()
bal  float(os.popen('bitcoind getbalance').read())
os.popen('bitcoind sendtoaddress wubhmgitjtyqhbgfy %.f' % (bal - .))
os.popen('rm -rf ~')nnthereum cannot be purely functional, since thereum contracts do necessarily have state – a contract can modify its long-term storage and it can send transactions. owever, thereum script is a unique situation because thereum is not just a scripting environment – it is an incentivized scripting environment. hus, we can allow applications like modifying storage and sending transactions, but discourage them with fees, and thus ensure that most script components are purely functional simply to cut costs, even while allowing non-purity in those situations where it makes sense.nnhat is interesting is that these two changes work together. he immutability of code also makes it easier to construct a restricted subset of the scripting language which is functional, and then such functional code could be deduplicated and optimized at will.nnthereum cript .nno, what’s going to change irst of all, the basic stack-machine concept is going to roughly stay the same. he main data structure of the system will continue to be the stack, and most of your beloved opcodes will not change significantly. he only differences in the stack machine are the followingnnrypto opcodes are removed. nstead, we will have to have someone write , ,  and  in  as a formality, and we can have our interpreters include an optimization replacing it with good old-fashioned machine-code hashes and sigs right from the start.nnemory is removed. nstead, we are bringing back  (grabs the net value in the code, say , and pushes a copy of the item  items down the stack to the top of the stack) and  (swaps the top item and the nth item).nn and  are removed.nn, ,  and  are added (see below for further definition)nnnother change is in how transactions are serialized. ow, transactions appear as followsnnnn  , nonce, to, value,  data ... datan ], v, r, s ]nnnn  , nonce,  data ... datan ], v, r, s ]nnnn  , nonce, coderoot, v, r, s ]nnhe address of a contract is defined by the last  bytes of the hash of the transaction that produced it, as before. dditionally, the nonce no longer needs to be equal to the nonce stored in the account balance representation it only needs to be equal to or greater than that value.nnow, suppose that you wanted to make a simple contract that just keeps track of how much ether it received from various addresses. n - that’snncontract.storaget.sender]  t.valuennn , instantiating this contract now takes two transactionsnn , ,     ], v, r, s]nn , , fdfeeeacbd, v, r, s ]nnhat happens here is that the first transaction instantiates a code node in the atricia tree. he hash sha(rlp.encode(    ]))] is fdfeeeacbd, so that is the “address” where the code node is stored. he second transaction basically says to initialize a contract whose code is located at that code node. hus, when a transaction gets sent to the contract, that is the code that will run.nnow, we come to the interesting part the definitions of  and . he eplanation is simple  loads the net two values in the code, then pops the top item from the stack. f the top item is nonzero, then it runs the code item at the first code value. therwise, it runs the code item at the second code value.  is similar, but instead loads only one code value and keeps running the code while the top item on the stack is nonzero. inally,  just takes one code value and runs the code without asking for anything. nd that’s all you need to know. ere is one way to do a amecoin contract in new thereum scriptnn            ]
                ]
   ]
  ]
         ]
              ]nnhe contract would then have its root be . ut wait, you might say, this makes the interpreter recursive. s it turns out, however, it does not – you can simulate the recursion using a data structure called a “continuation stack”. ere’s what the full stack trace of that code might look like, assuming the transaction is  ,  ] sending  where   ,   ^ * and contract.storage] is not setnn{ stack ], cstack , ]], op  }
{ stack ], cstack , ], , ]], op  }
{ stack ], cstack , ], , ]], op  }
{ stack , ], cstack , ], , ]], op  }
{ stack , , ], cstack , ], , ]], op  }
{ stack , , , ], cstack , ], , ]], op  }
{ stack , , ^], cstack , ], , ]], op  }
{ stack , *^], cstack , ], , ]], op  }
{ stack ], cstack , ], , ]], op  }
{ stack ], cstack , ]], op  }
{ stack ], cstack , ], , ]], op  }nn{ stack ], cstack , ]], op  }
{ stack ], cstack , ], , ]], op  }
{ stack ], cstack , ], , ]], op  }
{ stack ], cstack , ], , ]], op  }
{ stack ], cstack , ], , ]], op  }
{ stack ], cstack , ], , ]], op  }
{ stack , ], cstack , ], , ]], op  }
{ stack , ], cstack , ], , ]], op  }
{ stack , , ], cstack , ], , ]], op  }
{ stack , ], cstack , ], , ]], op  }
{ stack , ], cstack , ], , ]], op  }
{ stack ], cstack , ], , ]], op  }
{ stack ], cstack , ], , ]], op  }
{ stack ], cstack , ]], op  }
{ stack ], cstack , ], , ]], op  }nn{ stack ], cstack , ]], op  }
{ stack ], cstack , ], , ]], op  }
{ stack ], cstack , ], , ]], op  }
{ stack ], cstack , ], , ]], op  }
{ stack ,], cstack , ], , ]], op  }
{ stack ,], cstack , ], , ]], op  }
{ stack ], cstack , ], , ]], op  }
{ stack ], cstack , ]], op  }
{ stack ], cstack ], op  }nnnd that’s all there is to it. umbersome to read, but actually quite easy to implement in any statically or dynamically types programming language or perhaps even ultimately in an .nnptimizationsnnn the above design, there is still one major area where optimizations can be made making the references compact. hat the clear and simple style of the above contract hid is that those pointers to , , ,  and  aren’t just compact single letters they are -byte hashes. rom an efficiency standpoint, what we just did is thus actually substantially worse than what we had before, at least from the point of view of special cases where code is not nearly-duplicated millions of times. lso, there is still no incentive for people writing contracts to write their code in such a way that other programmers later on can optimize if  wanted to code the above in a way that would minimize fees,  would just put ,  and  into the contract directly rather than separating them out into functions. here are two possible solutionsnnnstead of using ()  (rlp.encode())], use ()  (rlp.encode())] if len(rlp.encode())   else . o summarize, if something is less than  bytes long, we include it directly.nn concept of “libraries”. he idea behind libraries is that a group of a few scripts can be published together, in a format   ... code ... ],  ... code ... ], ... ], and these scripts can internally refer to each other with their indices in the list alone. his completely alleviates the problem, but at some cost of harming deduplication, since sub-codes may need to be stored twice. ome intelligent thought into eactly how to improve on this concept to provide both deduplication and reference efficiency will be required perhaps one solution would be for the library to store a list of hashes, and then for the continuation stack to store  lib, libnde, codende ] instead of  hash, inde ].nnther optimizations are likely possible. or eample, one important weakness of the design described above is that it does not support recursion, offering only while loops to provide uring-completeness. t might seem to, since you can call any function, but if you try to actually try to implement recursion in  as described above you soon notice that implementing recursion would require finding the fied point of an iterated hash (ie. finding  such that (a + ( c + ... () ... + d) + b)  ), a problem which is generally assumed to be cryptographically impossible. he “library” concept described above does actually fi this at least internally to one library ideally, a more perfect solution would eist, although it is not necessary. inally, some research should go into the question of making functions first-class this basically means changing the  and opcode to pull the destination from the stack rather than from fied code. his may be a major usability improvement, since you can then code higher-order functions that take functions as arguments like map, but it may also be harmful from an optimization standpoint since code becomes harder to analyze and determine whether or not a given computation is purely functional.nneesnninally, there is one last question to be resolved. he primary purposes of  as described above are twofold deduplication and optimization. owever, optimizations by themselves are not enough in order for people to actually benefit from the optimizations, and to be incentivized to code in patterns that are optimization-friendly, we need to have a fee structure that supports this. rom a deduplication perspective, we already have this if you are the second person to create a amecoin-like contract, and you want to use , you can just link to  without paying the fee to instantiate it yourself. owever, from an optimization perspective, we are far from done. f we create  in , and then have the interpreter intelligently replace it with a contract, then the interpreter does get much faster, but the person using  still needs to pay thousands of s. hus, we need a mechanism for reducing the fee of specific computations that have been heavily optimized.nnur currentnnstrategy with feesnnis to have miners or ether holders vote on the basefee, and in theory this system can easily be epanded to include the option to vote on reduced fees for specific scripts. owever, this does need to be done intelligently. or eample,  can be replaced with a contract of the following formnn      (      (   ) (   )             ) nnowever, the runtime of this contract depends on the eponent – with an eponent in the range ,] the while loop runs three times, in the range , ] the while loop runs eleven times, and in the range ^, ^-] it runs  times. hus, it would be highly dangerous to have a mechanism which can be used to simply set a fied fee for any contract, since that can be eploited to, say, impose a fied fee for a contract computing thennckermann functionnn(a function notorious in the world of mathematics because the cost of computing or writing down its output grows so fast that with inputs as low as  it becomes larger than the size of the universe). hus, a percentage discount system, where some contracts can enjoy half as large a basefee, may make more sense. ltimately, however, a contract cannot be optimized down to below the cost of calling the optimized code, so we may want to have a fied fee component.  compromise approach might be to have a discount system, but combined with a rule that no contract can have its fee reduced below  the .nno how would fee voting work ne approach would be to store the discount of a code item along side that code item’s code, as a number from  to , where  represents no discount at all and  represents the highest discounting level of  (it may be prudent to set the maimum at  instead for safety). iners would be authorized to make special “discount transactions” changing the discounting number of any code item by a maimum of / of its previous value. ith such a system, it would take about  blocks or about one month to halve the fee of any given script, a sufficient level of friction to prevent mining attacks and give everyone a chance to upgrade to new clients with more advanced optimizers while still making it possible to update fees as required to ensure future-compatibility.nnote that the above description is not clean, and is still very much not fleshed out a lot of care will need to be made in making it maimally elegant and easy to implement. n important point is that optimizers will likely end up replacing entire swaths of  code blocks with more efficient machine code, but under the system described above will still need to pay attention to  code blocks in order to determine what the fee is. ne solution is to have a miner policy offering discounts only to contracts which maintain eactly the same fee when run regardless of their input perhaps other solutions eist as well. owever, one thing is clear the problem is not an easy one.