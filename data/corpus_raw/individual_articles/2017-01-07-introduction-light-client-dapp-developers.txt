Titre: Introduction of the Light Client for DApp developers\nAuteur: Zsolt Felföldi\nDate: January 7, 2017\nURL: https://blog.ethereum.org/2017/01/07/introduction-light-client-dapp-developers\nCatégorie: Non catégorisé\n\n==================================================\n\nhe first version of the ight thereum ubprotocol (/) and its implementation in eth are still innnannneperimental stage, but they are epected to reach a morennmaturennstate in a few months where the basic functions will perform reliably.nnhe light client has been designed to function more or less the same as a full client, but the “lightness" has some inherent limitations that pp developersnnshouldnnunderstand andnnconsider when designing their applicationsnn.nnn most cases a properly designed application can work even without knowing what kind of client it is connected to, but we are looking into adding an  etension for communicating different client capabilities in order to provide a future proof interface. hile minor details of  are still being worked out,  believe it is time to clarify the most important differences between full and light clients from the application developer perspective.nnurrent limitationsnnending transactionsnnight clients do not receive pending transactions from the main thereum network.nnhe only pending transactions a light client knows about are the ones that have been created and sent from that client.nnhen a light client sends a transaction, it starts downloading entire blocks until it finds the sent transaction in one of the blocks, then removes it from the pending transaction set.nninding a transaction by hashnnurrently you can only find locally created transactions by hash.nnhese transactions and their inclusion blocks are stored in the database and can be found by hash later. inding other transactions is a bit trickier. t is possible (though not implemented as of yet) to download them from a server and verify the transaction is actually included in the block if the server found it. nfortunately, if the server says that the transaction does not eist, it is not possible for the client to verify the validity of this answer. t is possible to ask multiple servers in case the first one did not know about it, but the client can never be absolutely sure about the non-eistence of a given transaction. or most applications this might not be an issue but it is something one should keep in mind if something important may depend on the eistence of a transaction.  coordinated attack to fool a light client into believing that no transaction eists with a given hash would probably be difficult to eecute but not entirely impossible.nnerformance considerationsnnequest latencynnhe only thing a light client always has in its database is the last few thousand block headers. his means that retrieving anything else requires the client to send requests and get answers from light servers. he light client tries to optimize requestnndistributionnnand collects statistical data of each server's usual response times in order to reduce latency.nnatency is the key performance parameter of a light client. t is usually in the -ms order of magnitude, and it applies to every state/contract storage read, block and receipt set retrieval.nnf many requests are made sequentially to perform an operation, it may result in a slow response time for the user. unning  functions in parallel whenever possible can greatly improve performance.nnearching for events in a long history of blocksnnull clients employ a so-called " mapped" bloom filter to find events quickly in a long list of blocks so that it is reasonably cheap to search for certain events in the entire block history. nfortunately, using a -mapped filter is not easy to do with a light client, as searches are only performed in individual headers, which is a lot slower. earching a few days' worth of block history usually returns after an acceptable amount of time, butnnat the moment you should not search for anything in the entire history because it will take an etremely long time.nnemory, disk and bandwidth requirementsnnere is the good news a light client does not need a big database since it can retrieve anything on demand. ith garbage collection enabled (which scheduled to be implemented),nnthe database will function more like anncache, and a light client will be able to run withnnas low as b of storage spacenn. ote that the current eth implementation uses aroundnnb of memorynn, which can probably be further reduced. andwidth requirements are also lower when the client is not used heavily. andwidth used is usually well undernnb/hour when running idle, with an additional -kb for an average state/storage requestnn.nnuture improvementsnneducing overall latency by remote eecutionnnometimes it is unnecessary to pass data back and forth multiple times between the client and the server in order to evaluate a function. t would be possible to eecute functions on the server side, then collect all the erkle proofs proving every piece of state data the function accessed and return all the proofs at once so that the client can re-run the code and verify the proofs. his method can be used for both read-only functions of the contracts as well as any application-specific code that operates on the blockchain/state as an input.nnerifying comple calculations indirectlynnne of the main limitations we are working to improvennis the slow search speed of log histories. any of the limitations mentioned above, including the difficulty of obtaining -mapped bloom filters, follow the same pattern the server (which is a full node) can easily calculate a certain piece of information, which can be shared with the light clients. ut the light clients currently have no practical way of checking the validity of that information, since verifying the entire calculation of the results directly would require so much processing power and bandwidth, which would make using a light client pointless.nnortunately there is a safe and trustless solution to the generalnntasknnof indirectly validating remote calculations based on an input dataset that both parties assume to be available, even if the receiving party does not have the actual data, only its hash.nnhis is the eact the casennin our scenario where the thereum blockchain itself can be used as an input for such a verified calculation.nnhis means it is possible for light clients to have capabilities close to that of full nodes because they can ask a light server to remotely evaluate an operation for them that they would not be able to otherwise perform themselves. he details of this feature are still being worked out and are outside the scope of this document, but the general idea of the verification method is eplained by r. hristian eitwiessner in thisnnevcon  talknn.nnomple applications accessing huge amounts of contract storage can also benefit from this approach by evaluating accessor functions entirely on the server side and not having to download proofs and re-evaluate the functions. heoretically it would also be possible to use indirect verification for filtering events that light clients could not watch for otherwise. owever, in most cases generating proper logs is still simpler and more efficient.