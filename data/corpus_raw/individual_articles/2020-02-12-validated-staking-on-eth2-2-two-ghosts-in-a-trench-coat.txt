Titre: Validated, staking on eth2: #2 - Two ghosts in a trench coat\nAuteur: Carl Beekhuizen\nDate: February 12, 2020\nURL: https://blog.ethereum.org/2020/02/12/validated-staking-on-eth2-2-two-ghosts-in-a-trench-coat\nCatégorie: Non catégorisé\n\n==================================================\n\npecial thanks to acha ves aint-eger & anny yan for review.nnn this installment, we'll discuss the consensus mechanisms behind eth. th has a novel approach to deciding which block is the head of the chain, along with which blocksnnarennandnnare notnna part of the chain.nny using a hybrid between the two mechanisms, eth aims to have a consensus which, in addition to being rapid and safe when the network is behaving normally, remains safe even when it’s being attacked.nn rilemmann impossibilitynnis a core result in the field of distributed computation which states that in a distributed system it is not possible tonnsimultaneouslynnhave safety, liveness, and full asynchrony unless some unreasonable assumptions can be made about your system.nnafetynnis the idea that decisions cannot be unmade whereasnnlivenessnncaptures the notion that new things can be decided.  protocol isnnasynchronusnnif there is no bound on how long a message may take to get delivered.nnf nodes could communicate reliably, always follow the protocol honestly and never crash, then consensus would be easy, but that is not how the world works. hen these assumption don't hold,  mpossibility is the proof that at least one of safety, liveness, or full asynchrony must be compromised.nns and their opinions on forksnnth usesnnreedy eaviest bserved ubtree ()nnas its fork-choice rule.  selects the head of the chain by choosing the fork which has the most votes (it does this by considering all of the votes for each fork block and their respective child blocks).nnut another waynn, each time there is a fork,  chooses the side where more of the latest messages support that block’s subtree (i.e. more of the latest messages support either that block or one of its descendants). he algorithm does this until it reaches a block with no children.nn has the benefit of reducing the efficacy of attacks during times of high network latency as well as minimizing the depth of chain reorgs when compared to the longest-chain rule. his is because while an attacker can keep building blocks efficiently on their own chain thereby making it the longest,  would choose the other fork as there are more votes for it in total.nnn particular, eth uses a variation of  which has been adapted to a o contet called atest essage riven  (-). he idea behind - is that when calculating the head of the chain, one only considers thennlatestnnvote made by each validator, and not any of the votes made in the past. his dramatically decreases the computation required when running , since the number of forks that need to be considered to eecute the fork choice cannot be greater than the number of validators (nnnn(nnvnn)nn(v)nnnn(nnvnn)nnin ig  notation).nnnder the rules of , validators/miners can always try to add a new block to the blockchain (liveness), and they can do this at any point in the chain’s history (asynchronous). ince it is live and fully asynchronous, thanks to our friend , we know it can’t be safe.nnhe lack of safety presents itself in the form of reorgs where a chain can suddenly switch between forks of arbitrary depth. bviously this is undesirable and eth deals with this by having users make assumptions about how long miners' blocks will take to be communicated with the rest of the network, this takes the form of waiting fornnnnnnnnconfirmations. th, by contrast, makes no such assumptions.nnhe friendly finality gadgetnn blockchain without any notion of safety is useless because no decisions could be reached and users could not agree on the state of the chain. nternnasper the riendly inality adget (asper )nn. asper  is a mechanism which favours safety over liveness when making decisions. his means that while the decisions it makes are final, under poor network conditions, it may not be able to decide on anything.nn is a crypto-economic adaption of the classicnnractical yzantine ault olerent ()nnwhich has phases where nodes first indicate that they'd like to agree on something (nnjustificationnn) and then agree that they've seen each other agreeing (nnfinalisationnn).nnth does not try to justify and finalise every slot (the time when a block is epected to be produced), but instead only every  slots. ollectively,  slots is called annnepochnn. irst, validators sign that they agree with all  blocks in an epoch. hen, ifnn≥nnnnnngeq frac{}{}nn≥nnnnnn​nndo so, the block is justified. n a later epoch, validators get another chance to vote to indicate that they have seen the earlier justified epoch and ifnn≥nnnnnngeq frac{}{}nn≥nnnnnn​nndo this, the epoch is finalised and is forever a part of the eth chain.nn employs a clever trick. otes actually consist of two sub-votes, one for the epoch that is attempting to be justified and another for an earlier epoch that is to become finalised. his saves a lot of etra communication between nodes and helps to achieve the goal of scaling to millions of validators.nnwo ghosts in a trench coatnnonsensus within eth relies on both - – which adds new blocks and decides what the head of the chain is – and asper  which makes the final decision on which blocksnnarennandnnare notnna part of the chain. ’s favourable liveness properties allow new blocks to quickly and efficiently be added to the chain, while  follows behind to provide safety by finalising epochs.nnhe two protocols are merged by running  from the last finalised block as decided upon by . y construction, the last finalised block is always a part of the chain which means  doesn't need to consider earlier blocks.nnn the normal case when blocks are being produced andnn≥nnnnnngeq frac{}{}nn≥nnnnnn​nnvalidators are voting on them, these blocks are added to the head of the chain by , and not long after justified and finalised by  (which considers the last few epochs).nnf there is an attack on the network and/or a large proportion of validators go offline, then  continues adding new blocks. owever, since  is live, but not safe, it may change its mind about the head of the chain – this is because new blocks are continually added to the chain, which means nodes keep learning new information.  on the other hand, favours safety over liveness meaning that it stops finalising blocks until the network is stable enough for validators to vote consistently again.