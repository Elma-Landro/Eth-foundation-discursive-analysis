Titre: Secured #6 - Writing Robust C - Best Practices for Finding and Preventing Vulnerabilities\nAuteur: Justin Traglia\nDate: November 2, 2023\nURL: https://blog.ethereum.org/2023/11/02/writing-robust-c\nCatégorie: Non catégorisé\n\n==================================================\n\nornn-nn, thereum clients need the ability to compute and verify  commitments. ather than each client rolling their own crypto, researchers and developers came together to writennc-kzg-nn, a relatively small  library with bindings for higher-level languages. he idea was to create a robust and efficient cryptographic library that all clients could use. he rotocol ecurity esearch team at the thereum oundation had the opportunity to review and improve this library. his blog post will discuss some things we do to make  projects more secure.nnuzznnuzzing is a dynamic code testing technique that involves providing random inputs to discover bugs in a program.nnibuzzernnandnnafl++nnare two popular fuzzing frameworks for  projects. hey are both in-process, coverage-guided, evolutionary fuzzing engines. or c-kzg-,nnwe usednnibuzzer since we were already well-integrated with  project's other offerings.nnere's the fuzzer fornnverify_kzg_proofnn, one of c-kzg-'s functionsnn#include "../base_fuzz.h"nnstatic const size_t _  nnstatic const size_t _  _ + __nnstatic const size_t _  _ + ___nnstatic const size_t _  _ + ___nnstatic const size_t _  _ + __nnint uzzerestnenput(const uint_t* data, size_t size) {nninitialize()nnif (size  _) {nnbool oknnverify_kzg_proof(nn&ok,nn(const ytes *)(data + _),nn(const ytes *)(data + _),nn(const ytes *)(data + _),nn(const ytes *)(data + _),nn&snn)nn}nnreturn nn}nnhen eecuted, this is what the output looks like. f there were a problem, it would write the input to disk and stop eecuting. deally, you should be able to reproduce the problem.nnhere's also differential fuzzing, which is a technique which fuzzes two or more implementations of the same interface and compares the outputs. or a given input, if the output is different, and you epected them to be the same, you know something is wrong. his technique is very popular in thereum because we like to have several implementations of the same thing. his diversification provides an etra level of safety, knowing that if one implementation were flawed the others may not have the same issue.nnor  libraries, we developednnkzg-fuzznnwhich differentially fuzzes c-kzg- (through its olang bindings) andnngo-kzg-nn. o far, there haven't been any differences.nnoveragennet, we usednnllvm-profdatannandnnllvm-covnnto generate a coverage report from running the tests. his is a great way to verify code is eecuted ("covered") and tested. ee thenncoveragenntarget in c-kzg-'s akefile for an eample of how to generate this report.nnhen this target is run (nni.e.nn,nnmake coveragenn) it produces a table that serves as a high-level overview of how much of each function is eecuted. he eported functions are at the top and the non-eported (static) functions are on the bottom.nnhere is a lot of green in the table above, but there is some yellow and red too. o determine what is and isn't being eecuted, refer to the  file (nncoverage.htmlnn) that was generated. his webpage shows the entire source file and highlights non-eecuted code in red. n this project's case, most of the non-eecuted code deals with hard-to-test error cases such as memory allocation failures. or eample, here's some non-eecuted codennt the beginning of this function, it checks that the trusted setup is big enough to perform a pairing check. here isn't a test case which provides an invalid trusted setup, so this doesn't get eecuted. lso, because we only test with the correct trusted setup, the result ofnnis_monomial_formnnis always the same and doesn't return the error value.nnrofilenne don't recommend this for all projects, but since c-kzg- is a performance critical library we think it's important to profile its eported functions and measure how long they take to eecute. his can help identify inefficiencies which could potentially o nodes. or this, we usednngperftoolsnn(oogle erformance ools) instead ofnnllvm-raynnbecause we found it to be more feature-rich and easier to use.nnhe following is a simple eample which profilesnnmy_functionnn. rofiling works by checking which instruction is being eecuted every so often. f a function is fast enough, it may not be noticed by the profiler. o reduce the chance of this, you may need to call your function multiple times. n this eample, we callnnmy_functionnn times.nn#include gperftools/profiler.hnnint task_a(int n) {nnif (n  ) return nnreturn task_a(n - ) * nnn}nnint task_b(int n) {nnif (n  ) return nnreturn task_b(n - ) + nnn}nnvoid my_function(void) {nnfor (int i   i   i++) {nnif (i %   ) {nntask_a(i)nn} else {nntask_b(i)nn}nn}nn}nnint main(void) {nnrofilertart("eample.prof")nnfor (int i   i   i++) {nnmy_function()nn}nnrofilertop()nnreturn nn}nnsennrofilertart("filename")nnandnnrofilertop()nnto mark which parts of your program to profile. hen re-compiled and eecuted, it will write a file to disk with profiling data. ou can then usennpprofnnto visualize this data.nnere is the graph generated from the command abovennere's a bigger eample from one of c-kzg-'s functions. he following image is the profiling graph fornncompute_blob_kzg_proofnn. s you can see, % of this function's time is spent performing ontgomery multiplications. his is epected.nneversennet, view your binary in a software reverse engineering () tool such asnnhidrannornnnn. hese tools can help you understand how high-level constructs are translated into low-level machine code. e think it helps to review your code this way like how reading a paper in a different font will force your brain to interpret sentences differently. t's also useful to see what type of optimizations your compiler makes. t's rare, but sometimes the compiler will optimize out something which it deemed unnecessary. eep an eye out for this, something like this actually happened in c-kzg-,nnsome of the tests were being optimized outnn.nnhen you view a decompiled function, it will not have variable names, comple types, or comments. hen compiled, this information isn't included in the binary. t will be up to you to reverse engineer this. ou'll often see functions are inlined into a single function, multiple variables declared in code are optimized into a single buffer, and the order of checks are different. hese are just compiler optimizations and are generally fine. t may help to build your binary with  debugging information most s can analyze this section to provide better results.nnor eample, this is whatnnblob_to_kzg_commitmentnninitially looks like in hidrannith a little work, you can rename variables and add comments to make it easier to read. ere's what it could look like after a few minutesnntatic nalysisnnlangnncomes built-in with thennlang tatic nalyzernn, which is an ecellent static analysis tool that can identify many problems that the compiler will miss. s the name "static" suggests, it eamines code without eecuting it. his is slower than the compiler, but a lot faster than "dynamic" analysis tools which eecute code.nnere's a simple eample which forgets to freennarrnn(and has another problem but we will talk more about that later). he compiler will not identify this, even with all warnings enabled because technically this is completely valid code.nn#include stdlib.hnnint main(void) {nnint* arr  malloc( * sizeof(int))nnarr]  nnreturn nn}nnhennuni.allocnnchecker will identify thatnnarrnnwasn't freed. he line in the warning message is a bit misleading, but it makes sense if you think about it the analyzer reached the return statement and noticed that the memory hadn't been freed.nnot all of the findings are that simple though. ere's a finding that lang tatic nalyzer found in c-kzg- when initially introduced to the projectnniven an unepected input, it was possible to shift this value by  bits which is undefined behavior. he solution was to restrict the input withnn(log_pow(n) ! )nnso that this was impossible. ood job, lang tatic nalyzer!nnanitizennantizers are dynamic analysis tools which instrument (add instructions) to programs which can point out issues during eecution. hese are particularly useful at finding common mistakes associated with memory handling. lang comes built-in with several sanitizers here are the four we find most useful and easy to use.nnddressnnddressanitizernn(an) is a fast memory error detector which can identify out-of-bounds accesses, use-after-free, use-after-return, use-after-scope, double-free, and memory leaks.nnere is the same eample from earlier. t forgets to freennarrnnand it will set  the th element in a  element array. his is a simple eample of a heap-buffer-overflownn#include stdlib.hnnint main(void) {nnint* arr  malloc( * sizeof(int))nnarr]  nnreturn nn}nnhen compiled withnn-fsanitizeaddressnnand eecuted, it will output the following error message. his points you in a good direction (a -byte write innnmainnn). his binary could be viewed in a disassembler to figure out eactly which instruction (atnnmain+nn) is causing the problem.nnimilarly, here's an eample where it finds a heap-use-after-freenn#include stdlib.hnnint main(void) {nnint *arr  malloc( * sizeof(int))nnfree(arr)nnreturn arr]nn}nnt tells you that there's a -byte read of freed memory atnnmain+cnn.nnemorynnemoryanitizernn(an) is a detector of uninitialized reads. ere's a simple eample which reads (and returns) an uninitialized valuennint main(void) {nnint data]nnreturn data]nn}nnhen compiled withnn-fsanitizememorynnand eecuted, it will output the following error messagennndefined ehaviornnndefinedehavioranitizernn(an) detects undefined behavior, which refers to the situation where a program's behavior is unpredictable and not specified by the langauge standard. ome common eamples of this are accessing out-of-bounds memory, dereferencing an invalid pointer, reading uninitialized variables, and overflow of a signed integer. or eample, here we incrementnn_nnwhich is undefined behavior.nn#include limits.hnnint main(void) {nnint a  _nnreturn a + nn}nnhen compiled withnn-fsanitizeundefinednnand eecuted, it will output the following error message which tells us eactly where the problem is and what the conditions arennhreadnnhreadanitizernn(an) detects data races, which can occur in multi-threaded programs when two or more threads access a shared memory location at the same time. his situation introduces unpredictability and can lead to undefined behavior. ere's an eample in which two threads increment a globalnncounternnvariable. here aren't any locks or semaphores, so it's entirely possible that these two threads will increment the variable at the same time.nn#include pthread.hnnint counter  nnvoid *increment(void *arg) {nn(void)argnnfor (int i   i   i++)nncounter++nnreturn nn}nnint main(void) {nnpthread_t thread, threadnnpthread_create(&thread, , increment, )nnpthread_create(&thread, , increment, )nnpthread_join(thread, )nnpthread_join(thread, )nnreturn nn}nnhen compiled withnn-fsanitizethreadnnand eecuted, it will output the following error messagennhis error message tells us that there's a data race. n two threads, thennincrementnnfunction is writing to the same  bytes at the same time. t even tells us that the memory isnncounternn.nnalgrindnnalgrindnnis a powerful instrumentation framework for building dynamic analysis tools, but its best known for identifying memory errors and leaks with its built-in emcheck tool.nnhe following image shows the output from running c-kzg-'s tests with algrind. n the red bo is a valid finding for a "conditional jump or move that] depends on uninitialized value(s)."nnhisnnidentified an edge casenninnnepand_root_of_unitynn. f the wrong root of unity or width were provided, it was possible that the loop will break beforennoutwidth]nnwas initialized. n this situation, the final check would depend on an uninitialized value.nnstatic __ epand_root_of_unity(nnfr_t *out, const fr_t *root, uint_t widthnn) {nnout]  _nnout]  *rootnnfor (uint_t i   !fr_is_one(&outi - ]) i++) {nn(i  width)nnblst_fr_mul(&outi], &outi - ], root)nn}nn(fr_is_one(&outwidth]))nnreturn __nn}nnecurity eviewnnfter development stabilizes, it's been thoroughly tested, and your team has manually reviewed the codebase themselves multiple times, it's time to get a security review by a reputable security group. his won't be a stamp of approval, but it shows that your project is at least somewhat secure. eep in mind there is no such thing as perfect security. here will always be the risk of vulnerabilities.nnor c-kzg- and go-kzg-, the thereum oundation contractednnigma rimennto conduct a security review. hey producednnthis reportnnwith  findings. t contains one critical vulnerability in go-kzg- that was a really good find. he - library that go-kzg- uses,nngnark-cryptonn, had a bug which allowed invalid  and  points to be sucessfully decoded. ad this not been fied, this could have resulted in a consensus bug (a disagreement between implementations) in thereum.nnug ountynnf a vulnerability in your project could be eploited for gains, like it is for thereum, consider setting up a bug bounty program. his allows security researchers, or anyone really, to submit vulnerability reports in echange for money. enerally, this is specifically for findings which can prove that an eploit is possible. f the bug bounty payouts are reasonable, bug finders will notify you of the bug rather than eploiting it or selling it to another party. e recommend starting your bug bounty program after the findings from the first security review are resolved ideally, the security review would cost less than the bug bounty payouts.nnonclusionnnhe development of robust  projects, especially in the critical domain of blockchain and cryptocurrencies, requires a multi-faceted approach. iven the inherent vulnerabilities associated with the  language, a combination of best practices and tools is essential for producing resilient software. e hope our eperiences and findings from our work with c-kzg- provide valuable insights and best practices for others embarking on similar projects.