Titre: How to build server less applications for Mist\nAuteur: Alex Van de Sande\nDate: July 12, 2016\nURL: https://blog.ethereum.org/2016/07/12/build-server-less-applications-mist\nCatégorie: Non catégorisé\n\n==================================================\n\nthereum is not meant to be a platform to build esoteric smart contract applications that require a  degree to understand, but it aims to be one pillar of a different architecture for applications on the world wide web. ith this post we will try to elucidate how this can be done and give some basic eamples on how to start building a decentralized app.nnho is this fornnhis tet is intended at those who have a basic understanding of web technology and how to build a simple javascript and html app, and want to convert these skills into building apps for the thereum ecosystem.nnow can apps run without serversnnurrently servers in web apps do much more than what they were originally intended to. esides serving static web pages, they also keep private information, handle user authentication and deal with all the complicated ways in which data is analyzed and saved. ll the user computer does - a device which would be considered a super computer when the web was invented - is to load and display that information to the user.nnurrent server modelsnnnstead, a more decentralized architecture would allow a much more modular approach, in which different machines and different protocols would handle specific tasks, some on the user's side and some in specialized machines deployed on a peer to peer network. herefore all the ata logic (what gets saved, who saves it, how to solve conflicts etc) is handled by smart contracts on the blockchain, static files are served viannwarmnnand realtime communication overnnhispernn. he user device keeps the user authentication and runs the application interface.nnoing this would remove the danger of data breach and attacks as there are less single nodes keeping tons of unencrypted data, while also removing the load and cost of serving apps by distributing it across the network. ince all those protocols are decentralized, anyone can connect to the network and start providing a specialized service if the user is browsing from a powerful laptop, for instance, they can also serve static files to network neighbors.nnecentralised erver modelsnn decentralized architecture also encourages innovation since the interface is detached from the data, anyone can come up with a new interface to the same app, creating a more vibrant and competing ecosystem. rguably, one of the most interesting and innovative periods in witter history was when it served mostly as a central data hub and anyone could build their  witter pplication.nnee it workingnnf you want to eperiment with the app before learning it, we recommend younndownload ist and read our introductory tutorial to how to install the app and run it.nnf you just want to see the whole app instead, you can download it directly from thenntake oice ithub repositorynn.nntake oice running on the ist rowsernnet's get to itnne are going to build a very simple application called "take oice". he idea is to allow ether stakers to vote on anything they want, and the app will tally the total ether balance of all those who agree or disagree with the statement.nnhe app underlying contract is written innnoliditynn, a javascript-like language and is very simplenncontract therotenn{nnevent ogotenn(nnbytes indeed proposalash, bool pro, address addrnn)nnnnfunctionnnvotenn(nnbytes proposalash, bool pronn)nn{nnifnn(nnmsg.valuennnnnn)nnthrownnnnogotenn(nnproposalash, pro, msg.sendernn)nnnn}nnfunctionnn(nn)nn{nnthrownnnn}nn}nnhe first line sets up the contract name and the second creates an event called "ogote", which will output in the log the followingnna hash of the proposal being voted onnnif the voter agrees or disagrees with itnnthe address of the voternnhe function "vote" will then fire the log, which the application later will count. t also has a check that no ether can be sent accidentally. he “anonymous”  function is eecuted when any ether is deposited on the smart contract and will then automatically reject it.nnf you want to learn more about coding in olidity we recommend you start on thennethereumnnsoliditynntutorialsnn, read thennofficial documentation pagennand try it on your browser using thennonline compilernn.nnhat's essentially it you choose a hash, choose a side and eecute ote(). o how does this translates into a polling appnnerverless rchitecturennollowing the principle of , we are doing the minimum product possible that is still usable, meaning we won't be using databases for storing proposals or using any feature that requires anything other than vanilla javascript and pure html.nno we will use the  of the app itself to keep the proposal tet, and we will use that to display it to the user and generate a hash that can then be used to check the votes. he users can use social media to share which proposals they want to debate or simply use direct links.nn// n the initial startup functionnnproposalnnnndecodenn(nngetarameteryamenn(nn'proposal'nn))nnnn//nntart with basicsnno grab your favorite html framework and get a basic website on your local machine and open it on ist. ll pages in ist have access to a javascript object called web which will where you will be working the most.  irst thing we need to do is check if web is present or notnnunctionnninitnn(nn)nn{nn..nn.nnifnn(nntypeof webnnnn'undefined'nn)nn{nn// lert the user they are notnninnna web compatible browsernnreturnnnnn}nnome application developers might want to load their own web object, to guarantee forward compatibility. o do that, just add just beforenn/bodynntagnnnnscriptnnsrcnnnn"nnnd then add this on your initial function to load your own custom web providernn// hecks eb supportnnifnn(nntypeof webnn!nnnn'undefined'nn&&nntypeof ebnn!nnnn'undefined'nn)nn{nn// f therenn's a web library loaded, then make your own webnnweb  new eb(web.currentrovider)nn} else if (typeof eb ! 'nnundefinednn') {nn// f there isn'nntnnthennnsetnna providernnwebnnnnnew ebnn(nnnew eb.providers.ttprovidernn(nn"http//localhost"nn))nnnn}nnelsennifnn(nntypeof webnnnn'undefined'nn)nn{nn// lert the user he is notnninnna web compatible browsernnreturnnnnn}nnoad information from the blockchainnnou checked you are connected to a blockchain, but which one s it the main ethereum network aybe a testnet or a private network aybe it's a fork in the future and your chain is a brand new one. he best way to check this is to see if the contract address you want to load has any code on it.nnurthermore, to eecute a contract you need to know two basic things it's address and the , which will be a json encoded file containing interface information.nnvar contractddressnnnn'edeedefcfecebccffbc'nnnnvar contractnnnnnn{nn"constant"nnfalse,nn"inputs"nnnnnn{nn"name"nnnn"proposalash"nn,nn"type"nnnn"bytes"nn}nn,nn{nn"name"nnnn"pro"nn,nn"type"nnnn"bool"nn}nn]nn,nn"name"nnnn"vote"nn,nn"outputs"nnnnnn]nn,nn"type"nnnn"function"nn}nn,nn{nn"anonymous"nnfalse,nn"inputs"nnnnnn{nn"indeed"nntrue,nn"name"nnnn"proposalash"nn,nn"type"nnnn"bytes"nn}nn,nn{nn"indeed"nnfalse,nn"name"nnnn"pro"nn,nn"type"nnnn"bool"nn}nn,nn{nn"indeed"nnfalse,nn"name"nnnn"addr"nn,nn"type"nnnn"address"nn}nn]nn,nn"name"nnnn"ogote"nn,nn"type"nnnn"event"nn}nn]nnnnow that you have those, you can check if the contract eist on the startup functionnn// oad the contractnnweb.eth.getodenn(nncontractddress, functionnn(nne, rnn)nn{nnifnn(nn!nnenn&&nnr.lengthnnnnnn)nnloadontractnn(nn)nnnn}nn)nnou can even run this command recursively, to try connecting to it again using another address (in case you are actually on the testnet). nce you have found your contract you can load it up herennunctionnnloadontractnn(nn)nn{nn// load the contract to javascriptnnethervoteontractnnnnweb.eth.contractnn(nncontractnn)nnnnethervotennnnethervoteontract.atnn(nncontractddressnn)nnnn}nnou are using the web object to create a new a javascript object that will be able to eecute all the ethereum commands directly from the browser. f you want to load only a single instance of the contract, then you can even do it in one linennethervotennnnweb.eth.contractnn(nncontractnn)nn.atnn(nncontractddressnn)nnnndentify the usernnnowing the user's account reveals a lot of information about the user how much ether and any other tokens it has on its balance, and their transaction history. o having all apps know this by default would create a super cookie and would be an unacceptable invasion of privacy. n the other hand, requiring the user to create an user account with login information for each site is not only a pain for the user, but also puts your private information in control of third parties, which creates giant honey pots that can be breached by hackers.nns a result of this dilemma most users have most of their personal information and authentication informationnnhandled by a half dozen billion dollar corporationnn. rivacy should not be a compromise we accept in echange of practicality users should be able to easily authenticate into any app while being in control of their own personal information.nnsing ist, apps have no information about the user, until the user decides to reveal itself to the app. hen you want to query what you know about the accounts, you should call the getccounts functionnnweb.eth.getccountsnn(nnfunctionnn(nne,accountsnn)nn{nnifnn(nn!nnenn)nn{nn//nndonnsomething with the accountsnn}nn}nn)nnnnurrently, the returning object is an array that holds simple accounts that the user has local access to, but in the future it will also hold smart contract accounts the user uses to identify themselves. his will allow the user to have access to features currently available only to centralized authenticators, like two factor authentication or cloud backup, and to future improvements only available to smart contracts, like allowing a few trusted friends to give you access to an account for which you lost keys or having automatic inheritance of inactive accounts.nnach future thereum browser will handle how users identify themselves to the pp. n ist we have two ways either the user can initiate it by clicking the "connect" button (currently it's just called a "no accounts" button) or the pp can request the authentication by calling the "requestccount" api.nnttention the accounts on this list are just one which the user claims to hold the key to, but the user has provided no proof of doing, therefore you can show a different , but don't send the user any secret information intended only to that account. f you require the user to prove their identity you need them to sign a message, while ist will also support that in the future, keep it in mind that it would force the user to add an etra step and type their password, so you should only use that when absolutely necessary.nnotingnnnce you have the contract as an object, voting is a matter of calling it from javascript. his will pop up a ist transaction pane, where the user will be able to check the transaction and then type their password. o first we will create two clickable objects that calls a vote functionnndocument.getlementydnn(nn'vote-support'nn)nn.addventistenernn(nn'click'nn,nnfunctionnn(nn)nn{nnvotenn(nntruenn)nnnn}nn,nnfalsenn)nnnndocument.getlementydnn(nn'vote-against'nn)nn.addventistenernn(nn'click'nn,nnfunctionnn(nn)nn{nnvotenn(nnfalsenn)nnnn}nn,nnfalsenn)nnnnotice that one calls the function with a true parameter and the other false. he function vote could be as simple asnnunctionnnvotenn(nn)nn{nnethervote.votenn(nnproposalash, support,nn{nnfrom web.eth.accountsnnnnnn]nn}nn)nnnn}nn"thervote" is the object we created before, and "vote" is one of its functions, which correspond to one of the contract functionsnnfunctionnnvotenn(nnbytes proposalash, bool pronn)nn{nn}nne pass the two parameters demanded by the function and then add a third object containing transaction informations, like who is it being sent from and optionally, how much gas to include or how much to pay for the gas.nnonsequently this would generate a panel asking the user to confirm the transaction - but most likely it will return an error because currently the web.eth.accounts object is an empty array by default, so you have to check for that and if empty, request the accounts to the usernnfunctionnnvotenn(nnsupportnn)nn{nnweb.eth.getccountsnn(nnfunctionnn(nne,accountsnn)nn{nn// hecknnifnnthere are accounts availablennifnn(nn!nnenn&&nnaccountsnn&&nnaccounts.lengthnnnnnn)nn{nn// reate a dialog requesting the transactionnnethervote.votenn(nnproposalash, support,nn{nnfrom accountsnnnnnn]nn}nn)nn}nnelsenn{nnmist.requestccountnn(nnfunctionnn(nne, accountnn)nn{nnifnn(nn!nnenn)nn{nn// reate a dialog requesting the transactionnnethervote.votenn(nnproposalash, support,nn{nnfrom account.toowerasenn(nn)nn}nn)nn}nn}nn)nnnn}nn}nn)nnnn}nnou should only request an account once the user initiated an action pinging a transaction out of nowhere will deservedly irritate the user and probably make him close your app. f we observe abuses from apps using this feature, we might add more strict requirements to when an alert will show up.nnatch the contractnninally, to count up all the votes we need to watch the contract events and see what votes were cast. o do that, we have to run this function once to start watching the events, after we instantiated "ethervote"nnethervotennnnweb.eth.contractnn(nncontractnn)nn.atnn(nncontractddressnn)nnnnvar logotesnnnnethervote.ogotenn(nn{nnproposalash proposalashnn}nn,nn{nnfromlocknnnn}nn)nnnn// aitnnfornnthe events to be loadednnlogotes.watchnn(nnfunctionnn(nnerror, resultnn)nn{nnifnn(nn!nnerrornn)nn{nn// o something whenever the event happensnnreceivedventnn(nnresultnn)nnnn}nn}nn)nnhe above code will start reading all blocks from number . (when the contract was uploaded) onwards and then eecute the receivedvent() function once for each event. henever a new block arrives with an event this function will be triggered again so you won't need to call continuously. o what would this function donnar voteapnnnn{nn}nnnnunction receivedventnn(nneventnn)nn{nn// et the current balance of a voternnvar balnnnnumbernn(nnweb.fromeinn(nnweb.eth.getalancenn(nnevent.args.addrnn)nn,nn"finney"nn))nnnnvoteapnnnnres.args.addrnn]nnnn{nnbalance bal, support event.args.pronn}nnnn}nnrom the original solidity contract, you can see that the ogote event comes with three argumenst, proposalash, ro and ddrnnevent ogotenn(nnbytes indeed proposalash, bool pro, address addrnn)nnnno what this function does is that it will use the function web.eth.getalance to check the current ether balance of the address that voted. ll balances always return numbers in wei, which is a / of an ether and is not very useful for this particular application, so we also use another included web function which converts that to any ether unit we want. n this case we will be using the finney, which is a thousandth of an ether.nnhen the function will save the balance, along with the position of the voter to a map based on the address. ne advantage of using a map instead of an array is that this will automatically overwrite any previous information about that same address, so if someone votes twice, only their last opinion will be kept.nnnother thing we could do is identify the user and show them if they voted or not.nn// hecknnifnnthe current owner has already voted and show that on the interfacennweb.eth.getccountsnn(nnfunctionnn(nne,accountsnn)nn{nnifnn(nn!nnenn&&nnaccountsnn&&nnaccountsnnnnnn]nnnnres.args.addrnn)nn{nnifnn(nnres.args.pronn)nn{nn// ser has voted yesnn!nn}nnelsenn{nn// ser has voted againstnn!nn}nn}nn}nn)nnnnally up the votesnninally, we should add a separate function to calculate the sums of the votesnncalculateotesnn(nn)nnnnhy do we want to tally up the votes on a separate function ecause since the vote weight is based on the current balance of each account, we should recalculate the balances at every new block, event if we received no new event. o do this you can add this function that will eecute automatically everytime a new block arrivesnnweb.eth.filternn(nn'latest'nn)nn.watchnn(nnfunctionnn(nne, resultnn)nn{nnifnn(nn!nnenn)nn{nncalculateotesnn(nn)nnnn}nn}nn)nnnninally, up to calculating the final tally. e have previously used eth.getalance in synchronous mode, where the app would wait for the result of the previous action to proceed. ere, since we can be calling a lot of actions every block, we will use it in asynchronous mode you call the node and eecute the action whenever it replies without freezing the interface.nnvar totalro, totalgainst, totalotesnnnnfunctionnncalculateotesnn(nn)nn{nntotalronnnnnnnntotalgainstnnnnnnnntotalotesnnnnnnnnbject.keysnn(nnvoteapnn)nn.mapnn(nnfunctionnn(nnann)nn{nn// call thennfunctionnnasynchronouslynnweb.eth.getalancenn(nna, functionnn(nne,rnn)nn{nnvoteapnnnnann]nn.balancennnnumbernn(nnweb.fromeinn(nnr,nn'finney'nn))nnnnifnn(nnvoteapnnnnann]nn.supportnn)nntotalronn+nnparseloatnn(nnvoteapnnnnann]nn.balancenn)nnnnelsenntotalgainstnn+nnparseloatnn(nnvoteapnnnnann]nn.balancenn)nnnn//nndonnsomething cool with the resultsnn!nn}nn)nnnn}nn)nnnn}nns you can follow on the code, what the app is doing is looping in each of the voting addresses and getting their balance, and as soon as it returns, it will either add it to the pro or against camp and sum the totals.nntra oodiesnn few etra caveats when there are no events, nothing will be returned and votes won't be calculated so you should add a timeout function on all functions that rely on events from the blockchain.nnsetimeoutnn(nnfunctionnn(nn)nn{nn// f the app doesn't respond after anntimeoutnnit probably has no votesnn}nn,nnnn)nnnnow you can feel free to use all your current webdeveloper foo to work whatever magic you want. se the numbers to build a nice visualization in  or connect to your favorite social media to share the best questions.nnist also tries to simplify your code by providing some basic navigation and  methods. f you want your app to be header less and occupy the full height of the mist app, just add this to your head tagnnnnmetannnamennnn"ethereum-dapp-url-bar-style"nncontentnnnn"transparent"nnnnnd if you want to use ist itself to navigate on your app, you can use thennist.menunnobjectnnfornn(nnitem of propistorynn)nn{nnifnn(nnitem.lengthnnnnnn&&nnitemnn!nn'null'nn)nn{nnmist.menu.addnn(nnitem ,nn{nnname item,nnposition n++,nnselected itemnnnnproposalnn}nn,nnfunctionnn(nn)nn{nnwindow.location.searchnnnn'proposal'nn+ encodenn(nnthis.namenn)nnnn}nn)nnnn}nn}nnne great thing about ethereum is that you can epand on this simple contract functionality without needing permission you can add all etra functionality on separate contracts, keeping every single one of them simple and easier to debug. t also means other people can use the contracts you created to their own apps and give new functionality. eanwhile, all the apps use the same data and backend.nnou can play with this app live hosted onnngithub pagesnn, but this isn't the canonical source of truth, just one of the many possible interfaces to it. he same app will also work as a local html file on your computer or on annn networknnand in the future it will be downloaded directly via ist using warm.nnome ideas on how you can trynnreate a listing of currently available statements. nyone can check them by seeing the sha of the proposal tet, so you don't need permission.nnreate threaded comments where users can reply to statements and then upvote or downvote them, sort of like a decentralized stake based edditnnnstead of (or in addition to) using ether balance, you can use some other ethereum token, like he  or igi old to weight your questions differently. ince all that the original contract stores is the sender, you can check all balances. r maybe you can create your own currency that is based on reputation, karma or some other way.