Titre: Toward a 12-second Block Time\nAuteur: Vitalik Buterin\nDate: July 11, 2014\nURL: https://blog.ethereum.org/2014/07/11/toward-a-12-second-block-time\nCatégorie: Non catégorisé\n\n==================================================\n\nne of the annoyances of the blockchain as a decentralized platform is the sheer length of delay before a transaction gets finalized. ne confirmation in the itcoin network takes ten minutes on average, but in reality due to statistical effects when one sends a transaction one can only epect a confirmation within ten minutes .% of the time .% of the time it will take longer than ten minutes, .% of the time longer than twenty minutes and .% of the time longer than an hour. ecause of fine technical points involvingnninney attacksnnandnnsub-% double spendsnn, for many use cases even one confirmation is not enough gambling sites and echanges often need to wait for three to si blocks to appear, often taking over an hour, before a deposit is confirmed. n the time before a transaction gets into a block, security is close to zero although many miners refuse to forward along transactions that conflict with transactions that had already been sent earlier, there is no economic necessity for them to do so (in fact quite the contrary), and some don't, so reversing an unconfirmed transaction is possible with about a -% success rate.nnn many cases, this is fine if you pay for a laptop online, and then manage to yank back the funds five minutes later, the merchant can simply cancel the shipping online subscription services work the same way. owever, in the contet of some in-person purchases and digital goods purchases, it is highly inconvenient. n the case of thereum, the inconvenience is greater we are trying to be not just a currency, but rather a generalized platform for decentralized applications, and especially in the contet of non-financial apps people tend to epect a much more rapid response time. hus, for our purposes, having a blockchain that is faster than  minutes is critical. owever, the question is, how low can we go, and if we go too low does that destabilize anythingnnverview of iningnnirst off, let us have a quick overview of how mining works. he itcoin blockchain is a series of blocks, with each one pointing to (ie. containing the hash of) the previous. ach miner in the network attempts to produce blocks by first grabbing up the necessary data (previous block, transactions, time, etc), building up the block header, and then continually changing a value called the nonce until the nonce satisfies a function called a "proof of work condition" (or "mining algorithm"). his algorithm is random and usually fails on average, in itcoin the network needs to collectively make about nnnnattempts before a valid block is found. nce some random miner finds a block that is valid (ie. it points to a valid previous block, its transactions and metadata are valid, and its nonce satisfies the o condition), then that block is broadcast to the network and the cycle begins again. s a reward, the miner of that block gets some quantity of coins (  in itcoin) as a reward.nnhe "score" of a block is defined in a simplified model as the number of blocks in the chain going back from it all the way to the genesis (formally, it's the total mining difficulty, so if the difficulty of the proof of work condition increases blocks created under this new more stringent condition count for more). he block that has the highest score is taken to be "truth".  subtle, but important, point is that in this model the incentive for miners is always to mine on the block with the highest score, because the block with the highest score is what users ultimately care about, and there are never any factors that make a lower-score block better. f we fool around with the scoring model, then if we are not careful this might change but more on this later.nne can model this kind of network thusnnowever, the problems arise when we take into account the fact that network propagation is not instant. ccording to ann papernnfrom ecker and attenhofer in urich, once a miner produces a block on average it takes . seconds for the block to reach % of nodes,  seconds for it to reach % of nodes and the mean delay is . seconds. hus, a more accurate model might bennhis gives rise to the following problem if, at time   , miner  mines a blocknn'nnon top ofnnnn(where "on top of" is understood to mean "pointing to as the previous block in the chain"), then miner  might not hear about the block until time   , so until    miner  will still be mining on . f miner  finds a block in that interval, then the rest of the network will reject miner 's block because they already saw miner 's block which has an equal scorenntales, fficiency and entralizationnno what's wrong with this ctually, two things. irst, it weakens the absolute strength of the network against attacks. t a block time of  seconds, as in itcoin, this is not an issue  seconds is a very small amount of time, and ecker and attenhofer estimate the total stale rate as being around .%. ence, an attacker does not actually need .% of the network in order to launch a % attack if the attacker is a single node, they would only neednn. /  + .nn .%. e can estimate this via a mathematical formula if transit time is  seconds, then after a block is produced the network will be producing stales for  seconds before the block propagates, so we can assume an average ofnn /   .nnstales per valid block or a stale rate of .%. t  seconds per block, however, we getnn /   .nnstales per valid block or a stale rate of .%. t  seconds per block, we getnn /   nnstale per valid block, or a stale rate of %. hus, we can see the network get substantially weaker against attacks.nnowever, there is also another negative consequence of stale rates. ne of the more pressing issues in the mining ecosystem is thennproblem of mining centralizationnn. urrently, most of the itcoin network is split up into a small number of "mining pools", centralized constructions where miners share resources in order to receive a more even reward, and the largest of these pools has for months been bouncing between % and % of network hashpower. n the future, even individual miners may prove threatening right now % of all new bitcoin mining devices are coming out of a single factory in henzhen, and if the pessimistic version ofnnmy economic analysisnnproves correct that may eventually morph into % of all itcoin miners being in a single factory in henzhen.nno how do stale rates affect centralization he answer is a clever one. uppose that you have a network with  pools with .% hashpower, and one pool with % hashpower. % of the time, the last block is produced by one of these miners, and the network hears about it in  seconds, and things are somewhat inefficient but nevertheless fair. % of the time, however, it is the % hashpower mining pool that produced the last block thus, it "hears" about the block instantly and has a % stale rate, whereas everyone else still has their full stale rate.nnecause our model is still pretty simple, we can still do some math on an approimation in closed form. ssuming a  second transit time and a -second block time, we have a stale rate of .% as described above. he % mining pool will have a % stale rate % of the time, so its efficiency multiplier will benn. * . +  * .  .nn, whereas everyone else will have an efficiency multiplier of . that's a .% efficiency gain which is pretty economically significant especially for mining pools where the difference in fees is only a few percent either way. hus, if we want a  second block time, we need a better strategy.nnnnhe beginnings of a better approach come from a paper entitled "nnast oney rows on rees, not hainsnn", published by viv ohar and onatan ompolinsky in ecember . he idea is that even though stale blocks are not currently counted as part of the total weight of the chain, they could be hence they propose a blockchain scoring system which takes stale blocks into account even if they are not part of the main chain. s a result, even if the main chain is only % efficient or even % efficient, an attacker attempting to pull off a % attack would still need to overcome the weight of the entire network. his, theoretically, solves the efficiency issue all the way down to -second block times. owever, there is a problem the protocol, as described, only includes stales in the scoring of a blockchain it does not assign the stales a block reward. ence, it does nothing to solve the centralization problem in fact, with a -second block time the most likely scenario involves the % mining pool simply producingnneverynnblock. f course, the % mining pool producing every blocknnon the main chainnnis fine, but only if the blocks off chain are also fairly rewarded, so the % mining pool still collects not much more than % of the revenue. ut for that rewarding stales will be required.nnow, we can't reward all stales always and forever that would be a bookkeeping nightmare (the algorithm would need to check very diligently that a newly included uncle had never been included before, so we would need an "uncle tree" in each block alongside the transaction tree and state tree) and more importantly it would make double-spends cost-free. hus, let us construct our first protocol, single-level , which does the minimal thing and takes uncles only up to one level (this is the algorithm used in thereum up to now)nnvery block must point to a parent (ie. previous block), and can also include zero or more uncles. n "uncle" is defined as a block with a valid header (the block itself need not be valid, since we only care about its proof-of-work) which is the child of the parent of the parent of the block but not the parent (ie. the standard definition of "uncle" from genealogy that you learned at age ).nn block on the main chain gets a reward of . hen a block includes an uncle, the uncle gets a reward of / and the block including the uncle gets a reward of /.nnhe score of a block is zero for the genesis block, otherwise the score of the parent plus the difficulty of the block multiplied by one plus the number of included uncles.nnhus, in the graphical blockchain eample given above, we'll instead have something like thisnnere, the math gets more comple, so we'll make some intuitive arguments and then take the lazy approach and simulate the whole thing. he basic intuitive argument is this in the basic mining protocol, for the reasons we described above, the stale rate is roughlynnt/(+t)nnwherenntnnis the transit time andnnnnis the block interval, becausennt/nnof the time miners are mining on old data. ith single-level , the failure condition changes from mining one stale to mining two stales in a row (since uncles can get included but relatives with a divergence of  or higher cannot), so the stale rate should benn(t/)^nn, ie. about .% instead of .%. ow, let's use annython scriptnnto test that theorynn###   ###nnnn.nnnn.nnnn.nnnn.nnnn.nnotal blocks producednnnnotal blocksnninnnchainnnnnfficiencynn.nnverage unclesnn.nnength of chainnnnnlock timenn.nnhe results can be parsed as follows. he top five numbers are a centralization indicator here, we see that a miner with % hashpower gets . as much reward as a miner with % hashpower. he efficiency is . meaning that .% of all blocks are not included at all, and there are . uncles per block hence, our intuitions about a ~% stale rate without uncle inclusion and .% with uncle inclusion are confirmed almost eactly. ote that the actual block time is .s because even though there is a valid proof of work solution every s, % of them are lost and % of them make it into only the net block as an uncle, not into the main chain.nnow, there is a problem here. he original authors of the  paper did not include uncle/stale rewards, and although  believe it is a good idea to deviate from their prescription for the reasons  described above, they did not do so for a reason it makes the economic analysis more uncomfortable. pecifically, when only the main chain gets rewarded there is an unambiguous argument why it's always worth it to mine on the head and not some previous block, namely the fact that the only thing that conceivably differentiates any two blocks is their score and higher score is obviously better than lower score, but once uncle rewards are introduced there are other factors that make things somewhat tricky.nnpecifically, suppose that the main chain has its last blocknnnn(score ) with parentnnnn(score ) with parentnnnn(score ). lso suppose thatnnnnhas two stale children, both of which were produced afternnnnso there was no chance for them to be included innnnnas uncles. f you mine onnnnn, you would produce a block with scorenn +   nnand reward , but if you mine onnnnnyou would be able to includennnn's children and get a block with scorenn +  +   nnand rewardnn + . *   .nn.nndditionally, there is annselfish-miningnn-esque attack against single-level . he argument is as follows if a mining pool with % hashpower were not to include any other blocks, then in the short term it would hurt itself because it would no longer receive the / nephew reward but it would hurt others more. ecause in the long-term mining is a zero-sum game since the block time rebalances to keep issuance constant, this means that not including uncles might actually be a dominant strategy, so centralization concerns are not entirely gone (specifically, they still remain % of the time). dditionally, if we decide to crank up the speed further, say to a  second target block time, single-level is just not good enough. ere's a result with those statisticsnn###   ###nnnn.nnnn.nnnn.nnnn.nnnn.nnotal blocks producednnnnotal blocksnninnnchainnnnnfficiencynn.nnverage unclesnn.nnength of chainnnnnlock timenn.nn% centralization gain. hus, we need a new strategy.nn ew trategynnhe first idea  tried about one week ago was requiring every block to have five uncles this would in a sense decentralize the production of each block further, ensuring that no miner had a clear advantage in making the net block. ince the math for that is pretty hopelessly intractable (well, if you try hard at it for months maybe you could come up with something involving nested oisson processes and combinatorical generating functions, but 'd rather not), here'snnthe sim scriptnn. ote that there are actually two ways you can do the algorithm require the parent to be the lowest-hash child of the grandparent, or require the parent to be the highest-score child of the grandparent. he first way (to do this yourself, modify line  tonnif newblock"id"]  self.blocksself.head]"id"]nn, we get thisnn###   ###nnnn.nnnn.nnnn.nnnn.nnnn.nnotal blocks producednnnnotal blocksnninnnchainnnnnfficiencynn.nnverage unclesnn.nnength of chainnnnnlock timenn.nnoooops! ell, let's try the highest-score modelnn###   ###nnnn.nnnn.nnnn.nnnn.nnnn.nnotal blocks producednnnnotal blocksnninnnchainnnnnfficiencynn.nnverage unclesnn.nnength of chainnnnnlock timenn.nno here we have a very counterintuitive result the % hashpower mining pool gets only  as much as a % hashpower pool. conomic sublinearity is a cryptoeconomic holy grail, but unfortunately it is also somewhat of a perpetual motion machine unless you rely on some specific thing that people have a certain amount of (eg. home heating demand, unused  power), there is no way to get around the fact even if you come up with some clever sublinear concoction an entity with  as much power going in will at the very least be able to pretend to be  separate entities and thus claim a  reward. hus, we have an unambiguous (okay, fine,  point something percent confidence) empirical proof that the  miners are acting suboptimally, meaning that the optimal strategy in this environment is not to always mine the block with the highest score.nnhe reasoning here is this if you mine on a block that has the highest score, then there is some chance that someone else will discover a new uncle one level back, and then mine a block on top of that, creating a new block at the same level as your block but with a slightly higher score and leaving you in the dust. owever, if you try to be one of those uncles, then the highest-score block at the net level will certainly want to include you, so you will get the uncle reward. he presence of one non-standard strategy strongly suggests the eistence of other, and more eploitative, non-standard strategies, so we're not going this route. owever,  chose to include it in the blog post to show an eample of what the dangers are.nno what is the best way forward s it turns out, it's pretty simple. o back to single level , but allow uncles to come from up to  blocks back. ence, the child of a parent of a parent (hereinafter, -,+-ancestor) is a valid uncle, a -,+-ancestor is a valid uncle, as is a -,+-ancestor and a -,+-ancestor, but a -,+-ancestor or a -,+-ancestor (ie.nnc(c(((((head))))))nnwhere no simplification is possible) is not. dditionally, we increase the uncle reward to /, and cut the nephew reward to /. irst, let's make sure that it works under standard strategies. n the  sim script, setnn_nnto ,nn__nnto ,nn_nnto ,nn__nnto / andnn__nnto / and see what happensnn###   ###nnnn.nnnn.nnnn.nnnn.nnnn.nnotal blocks producednnnnotal blocksnninnnchainnnnnfficiencynn.nnverage unclesnn.nnength of chainnnnnlock timenn.nnompletely reasonable all around, although note that the actual block time is s due to inefficiency and uncles rather than the s we targeted. ow, let's try a few more trials for enlightenment and funnn__  .nn,nn__  .nnlead to the % mining pool getting a roughly . return, and settingnn__  /nnandnn__  /nnleads to the % mining pool getting a .% return. bviously setting thenn__nnall the way to zero would negate the benefit completely, so it's good to have it be as close to one as possible, but if it's too close to one than there's no incentive to include uncles.nn__  /nnseems to be a fair middle ground, giving the % miner a .% centralization advantagennllowing uncles going back  blocks, surprisingly, has fairly little substantial efficiency gain. he reason is that the dominant weakness of -,+  is the +, not the -, ie. stalennc(c(((..(head)..))))nnblocks are the problem. s far as centralization goes, with ./. rewards it knocks the % mining pool's reward down to essentially .. ith / and / rewards there is no substantial gain over the -,+ approach.nnllowing -,+ children increases efficiency to effectively %, and cuts centralization to near-zero assuming ./. rewards and has negligible benefit assuming / and / rewards.nnf we reduce the target block time to  seconds, efficiency goes down to % and the % miner gets a . return (ie. % centralization gain). f we couple this with a -,+ rule, the effect is negligible (% - .), but if we use a -,+ rule efficiency goes up to % and the % miner only gets a . return (the way to add this to the sim script is to add after line nnfor c in self.children.get(c, {}) uc]  ruennfor a -n,+ rule and then similarly nest down one level further for -n,+). dditionally, the actual block time in all three of these scenarios is around  seconds.nnf we reduce the target block time to  seconds, then we get an actual block time of  seconds and the efficiency is % and the % miner gets . even without improvements.nnow, let's look at the other two risks of limited  that we discussed above the non-head dominant strategy and the selfish-mining attack. ote that there are actually two non-head strategies try to take more uncles, and try to be an uncle. rying to take more uncles was useful in the -,+ case, and trying to be an uncle was useful in the cas of my abortive mandatory--uncles idea. rying to be an uncle is not really useful when multiple uncles are not required, since the reason why that alternative strategy worked in the mandatory--uncle case is that a new block is useless for further mining without siblings. hus, the only potentially problematic strategy is trying to include uncles. n the one-block case, it was a problem, but here is it not because most uncles that can be included afternnnnnblocks can also be included afternnn+nnblocks, so the practical etent to which it will matter is limited.nnhe selfish-mining attack also no longer works for a similar reason. f you fail to include uncles, then the guy after you will. here are four chances for an uncle to get in, so not including uncles is a -party prisoner's dilemma between anonymous players - a game that is doomed to end badly for everyone involved (ecept of course the uncles themselves). here is also one last concern with this strategy we saw that rewarding all uncles makes % attacks cost-free, so are they cost-free here eyond one block, the answer is no although the first block of an attempted fork will get in as an uncle and receive its / reward, the second and third and all subsequent ones will not, so starting from two confirmations attacks still cost miners almost as much as they did before.nnwelve seconds, reallynnhe most surprising finding about ecker and attenhofer's finding is the sheer length of time that blocks take to propagate - an amazingly slow  seconds. n ecker and attenhofer's analysis, the  second delay is actually mostly because of the need to download and verify the blocks themselves ie. the algorithm that itcoin clients follow isnndef on_receive_blocknn(nnbnn)nnnnifnnnot verify_pow_and_headernn(nnbnn)nnnnreturnnnifnnnot verify_transactionsnn(nnbnn)nnnnreturnnnacceptnn(nnbnn)nnstart_broadcastingnn(nnbnn)nnowever, ecker and attenhofer did propose a superior strategy which looks something like thisnndef on_receive_headernn(nnhnn)nnnnifnnnot verify_pow_and_headernn(nnhnn)nnnnreturnnnask_for_full_blocknn(nnh, callbacknn)nnstart_broadcastingnn(nnhnn)nndef callbacknn(nnbnn)nnnnstart_broadcastingnn(nnbnn)nnifnnnot verify_transactionsnn(nnbnn)nnnnstop_broadcastingnn(nnbnn)nnreturnnnacceptnn(nnbnn)nnhis allows all of the steps to happen in parallel headers can get broadcasted first, then blocks, and the verifications do not need to all be done in series. lthough ecker and attenhofer do not provide their own estimate, intuitively this seems like it may speed up propagation by -%. he algorithm is still non-eploitable because in order to produce an invalid block that passes the first check a miner would still need to produce a valid proof of work, so there is nothing that the miner could gain. nother point that the paper makes is that the transit time is, beyond a certain point, proportional to block size hence, cutting block size by % will also cut transit time to something like -% the nonscaling portion of the transit time is something like s. ence, a -second target block time (and s actual block time) may be quite viable. s usual, we'll be more conservative at first and not take things that far, but a block time of s does nevertheless seem to be very much achievable.