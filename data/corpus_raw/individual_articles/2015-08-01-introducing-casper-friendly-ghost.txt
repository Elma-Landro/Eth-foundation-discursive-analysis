Titre: Introducing Casper “the Friendly Ghost”\nAuteur: Vlad Zamfir\nDate: August 1, 2015\nURL: https://blog.ethereum.org/2015/08/01/introducing-casper-friendly-ghost\nCatégorie: Non catégorisé\n\n==================================================\n\ni everyone – lad here. ’ve been working on the analysis and specification of  “proof-of-stake” blockchain architecture since eptember . hile italik and  haven’t agreed on all of the details of the spec, we do have consensus on many properties of the proof-of-stake protocol that will likely be implemented for the erenity release! t is called asper “the friendly ghost” because it is an adaptation of some of the principles of the  (reedy eaviest-bserved ub-ree) protocol for proof-of-work consensus to proof-of-stake. his blog post (my first one!) shares properties that are likely to be true of asper’s implementation in the erenity release. ormal verification and simulation of asper’s properties is under way, and will be published eventually - in the meantime, please enjoy this high-level, informal discussion!   )nnecurity-deposit based security and authenticationnnasper is a security-deposit based economic consensus protocol. his means that nodes, so called “bonded validators”, have to place a security deposit (an action we call “bonding”) in order to serve the consensus by producing blocks. he protocol’s direct control of these security deposits is the primary way in which asper affects the incentives of validators. pecifically, if a validator produces anything that asper considers “invalid”, their deposit are forfeited along with the privilege of participating in the consensus process. he use of security deposits addresses the “nothing at stake” problem that behaving badly is not epensive. here is something at stake, and bonded validators who misbehave in an objectively verifiable mannernnwillnnlose it.nnery notably, a validator’s signature is only economically meaningful so long as that validatornncurrentlynnhas a deposit. his means that clients can only rely on signatures from validators that they know arenncurrentlynnbonded. herefore, when clients receive and authenticate the state of the consensus,nntheir authentication chain ends in the list of currently-bonded validatorsnn. n proof-of-work consensus, on the other hand, the authentication chain ends in the genesis block - as long as you know the genesis block you can authenticate the consensus. ere, as long as you know the set of currently-bonded validators, you can authenticate the consensus.  client who does not know the list of currently bonded validators must authenticate this list out-of-band. his restriction on the way in which the consensus is authenticated solves the “long range attack” problem by requiring that everyone authenticate the consensus against current information.nnhe validator list changes over time as validators place deposits, lose their deposits, unbond, and get unbonded. herefore, if clients are offline for too long, their validator list will no longer be current enough to authenticate the consensus. n the case that they are online sufficiently often to observe the validator set rotating, however, clients are able to securely update their validator list. ven in this case, clients must begin with an up-to-date list of currently-bonded validators, and therefore they must authenticate this list out-of-bandnnat leastnnonce.nnhis “out-of-band authentication only necessarily once” property is what italik callsnnweak subjectivitynn. n this contet information is said to be “objective” if it can be verified in a protocol-defined manner, while it is “subjective” if it must be authenticated via etra-protocol means. n weakly subjective consensus protocols,nnthe fork-choice rule is statefulnn, and clients must initialize (and possibly sometimes renew) the information that their fork-choice rule uses to authenticate the consensus. n our case, this entails identifying the currently bonded validators (or, more probably a cryptographic hash of the validator list).nnambling on onsensusnnasper makes validators bet a large part of their security deposits on how the consensus process will turn out. oreover, the consensus process “turns out” in the manner in which they bet validators are made to bet their deposits on how they epect everyone else to be betting their deposits. f they bet correctly, they earn their deposit back with transaction fees and possibly token issuance upon it – if on the other hand they do not quickly agree, they re-earn less of their deposit. herefore through iterated rounds of betting validator bets converge.nnoreover, if validators change their bets too dramatically, for eample by voting with a high probability on one block after voting with a very high probability on another, then they are severely punished. his guarantees that validators bet with very high probabilities only when they are confident that the other validators will also produce high probability bets. hrough this mechanism we guarantee that their bets never converge to a second value after converging upon a first, as long as there there is sufficient validator participation.nnroof-of-work consensus is also a betting scheme miners bet that their block will be part of the heaviest chain if they eventually prove to be correct, they receive tokens - whereas if they prove to be incorrect, they incur electricity costs without compensation. onsensus is secured as long as all miners are betting their hashing power on the same chain, making it the blockchain with the most work (nnas a direct result of and as preempted by their coordinated bettingnn). he economic cost of these proof-of-work bets add up linearly in the number of confirmations (generations of descendant blocks), while, in asper, validators can coordinate placing eponentially growing portions of their security deposits against blocks, thereby achieving maimum security very quickly.nny-height onsensusnnalidators bet independently on blocks at every height (i.e. block number) by assigning it a probability and publishing it as a bet. hrough iterative betting, the validators elect eactly one block at every height, and this process determines the order in which transactions are eecuted. otably, if a validator ever places bets with probabilities summing to more than % at a time for a given height, or if any are less than %, or if they bet with more than % on an invalid block, then asper forfeits their security deposit.nnransaction inalitynnhen every member of a supermajority of bonded validators (a set of validators who meet a protocol-defined threshold somewhere between % and % of bonds) bets on a block with a very high (say,  .%) probability, the fork-choice rule never accepts a fork where this block does not win, and we say that the block isnnfinalnn. dditionally, when a client sees that every block lower than some heightnnnnis final, then the client will never choose a fork that has a different application state at heightnn - nnthan the one that results from the eecution of transactions in these finalized blocks. n this eventuality, we say that this state is finalized.nnhere are therefore two relevant kinds of transaction finality the finality of the fact that the transaction will be eecuted at a particular height (which is from finality of its block, and therefore priority over all future blocksnnat that heightnn), and the finality of the consensus state after that transaction’s eecution (which requires finality of its block and of unique blocks at all lower heights).nnensorship esistancennne of the largest risks to consensus protocols is the formation of coalitions that aim to maimize the profits of their members at the epense of non-members. f asper’s validators’ revenues are to be made up primarily of transaction fees, for eample, a majority coalition could censor the remaining nodes in order to earn an increased share of transaction fees. dditionally, an attacker could bribe nodes to eclude transactions affecting particular addresses – and so long as a majority of nodes are rational, they can censor the blocks created by nodes who include these transactions.nno resist attacks conducted by majority coalitions, asper regards the consensus process as anncooperative gamennand ensures that each node is most profitable if they are in a coalition made up of % of the consensus nodes (at least as long as they are incentivized primarily by in-protocol rewards). fnnpnn% of the validators are participating in the consensus game, then they earnnnfnn(nnpnn) ≤nnpnn% of the revenues they would earn if % of the validators were participating, for some increasing functionnnfnn.nnore specifically, asper punishes validators for not creating blocks in a protocol-prescribed order. he protocol is aware of deviations from this order, and withholds transaction fees and deposits from validators accordingly. dditionally, the revenue made from betting correctly on blocks is linear (or superlinear) in the number of validators who are participating in at that height of the consensus game.nnill there be more transactions per secondnnost probably, yes, although this is due to the economics of asper rather than due to its blockchain architecture. owever, asper’s blockchain does allow for faster block times than is possible with proof-of-work consensus.nnalidators will likely be earning only transaction fees, so they have a direct incentive to increase the gas limit, if their validation server can handle the load. owever, validators also have reduced returns from causing other, slower validators to fall out of sync, so they will allow the gas limit to rise only in a manner that is tolerable by the other validators. iners investing in hardware primarily purchase more mining rigs, while validators investing in hardware primarily upgrade their servers so they can process more transactions per second. iners also have an incentive to reinvest in more powerful transaction processing, but this incentive is much weaker than their incentive to purchase mining power.nnecurity-deposit-based proof-of-stake is very light-client friendly relative to proof-of-work. pecifically, light clients do not need to download block headers to have full security in authenticating the consensus, or to have full economic assurances of valid transaction eecution. his means that a lot of consensus overhead affects only the validators, but not the light clients, and it allows for lower latency without causing light clients to lose the ability to authenticate the consensus.nnecovery from netsplitsnnasper is able to recover from network partitions because transactions in non-finalized blocks can be reverted. fter a partition reconnects, asper eecutes transactions from blocks that received bets on the partition with higher validator participation. n this manner, nodes from either side of the partition agree on the state of the consensus after a reconnection and before validators are able to replace their bets. alidator bets converge to finalize the blocks in the partition that had more validator participation, with very high probability. asper will very likely process the losing transactions from losing blocks after the ones from winning blocks, although it is still to be decided whether validators will have to include these transactions in new blocks, or if asper will eecute them in their original order, himself.nnecovery from mass crash-failurennasper is able to recover from the crash-failure of all but one node. onded validators can always produce and place bets on blocks on their own, although they always make higher returns by coordinating on the production of blocks with a larger set of validators. n any case, a validator makes higher returns from producing blocks than from not producing blocks at all. dditionally, bonded validators who appear to be offline for too long will be unbonded, and new bonders subsequently will be allowed to join the validation set. asper can thereby potentially recover precisely the security guarantees it had before the mass crash-failure.nnhat is asper, in non-economic termsnnasper is an eventually-consistent blockchain-based consensus protocol. t favours availability over consistency (seennthe  theoremnn). t is always available, and consistent whenever possible. t is robust to unpredictable message delivery times because nodes come to consensus via re-organization of transactions, after delayed messages are eventually received. t has an eventual fault tolerance of %, in the sense that a fork created by % correct nodes scores higher than any fork created by the remaining potentially-faulty validators. otably, though, clients cannot be certain that any given fork created with % participation won’t be reverted because they cannot know whether some of these nodes are yzantine. lients therefore only consider a block as finalized if it has the participation of a supermajority of validators (or bonded stake).nnhat is it like to be a bonded validatornns a bonded validator, you will need to securely sign blocks and place bets on the consensus process. f you have a very large deposit, you will probably have a handful of servers in a custom multisig arrangement for validation, to minimize the chance of your server misbehaving or being hacked. his will require eperimentation and technical epertise.nnhe validator should be kept online as reliably and as much as possible, for it to maimize its profitability (or for otherwise it will be unprofitable). t will be very advisable to buy o protection. dditionally, your profitability will depend on the performance and availability of the other bonded validators. his means that there is risk that you cannot directly mitigate, yourself. ou could lose money even if other nodes don’t perform well - but you will lose more money yet if you don’t participate at all, after bonding. owever, additional risk also often means higher average profitability - especially if the risk is perceived but the costly event never occurs.nnhat is it like to be an application or a usernnpplications and their users benefit a lot from the change from proof-of-work consensus to asper. ower latency significantly improves the user’s eperience. n normal conditions transactions finalize very quickly. n the event of network partitions, on the other hand, transactions are still eecuted, but the fact that they can potentially still be reverted is reported clearly to the application and end-user. he application developer therefore still needs to deal with the possibility of forking, as they do in proof-of-work, but the consensus protocol itself provides them with a clear measure of what it would take for any given transaction to be reverted.nnhen can we hear morenntay tuned! e’ll be sure to let you know more of asper’s specification over the net months, as we come to consensus on the protocol’s details. n addition, you can look forward to seeing simulations, informal and formal specification, formal verification, and implementations of asper! ut please, be patient & can take an unpredictable amount of time!   )