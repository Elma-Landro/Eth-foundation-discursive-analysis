Titre: Pyethereum and Serpent Programming Guide\nAuteur: Vitalik Buterin\nDate: April 10, 2014\nURL: https://blog.ethereum.org/2014/04/10/pyethereum-and-serpent-programming-guide\nCatégorie: Non catégorisé\n\n==================================================\n\nhe content of this tutorial is intended to apply to o. ost of the instructions given below will not work in the older o implementations of lethero (++) and thereal (o)nnver the last few weeks, we have made a large number of changes to the thereum protocol. , introducing a large body of changes made by avin ood and myself, wasnnannounced as an informal descriptionnntwo weeks ago, and has been formally specified in avin ood’s “yellow paper” atnnhttp//gavwood.com/aper.pdfnn. he protocol spec did change substantially, but at the same time things are solidifying we know why we want transactions to pay fees instead of contracts, so that’s not likely to change, we know that code and data will be separate, and the byte-based code and memory and -byte-block-based stack and storage are unlikely to change, and we know that the workings of the  in general will be similar to what they are now instead of some kind of elaborate erkle-code-tree construction.  has given myself what  wanted out ofnnthereum cript nn, avin a much more optimization-friendly  architecture, and users annshiny new currencynn. eanwhile, hen ouwu, eiko ees and onrad eldmeier have taken the lead as our main ython developers, and the networking side of the pyethereum client is getting to the point where it is getting ready to talk to o and ++. t the same time, aside from all of the managerial tasks that are part and parcel of having a key role in a large project,  have taken it upon myself to bring up to speed the pyethereum  implementation and the compiler for the  programming language.nnhe purpose of this post will be to provide an in-depth technical tutorial into the workings of pyethereum and erpent, and show you how you can start writing the tools to build your own contracts and applications. he itcoin po hackathon is happening today and tomorrow, so feel free to make an thereum contract your project if you are among those attending.nnirst of all, importantly,  is no longer called  the language is now called erpent. hy ecause it’s basically ython.nnith recent upgrades to the compiler, erpent is now a highly feature-filled programming language, with powerful features includingnnrrays (eg. ]  )nnrray literals (eg.    , ,  ])nnested arrays (eg. z   ,  ,  ], y ])nne support (eg. receiving_address  bcdbfbdcaefe)nntring support (eg.   "cow")nnnline message calling (eg. usdprice  eth * msg(ethcontract,,t.gas-,],))nnut of line message calling (eg. msg(multifeedcontract,,t.gas-,inparray,,outarray,))nnimple value sending operation (eg. send(receiver, value, t.gas-))nneturning values (eg. return() and return(,,,],))nnreating message data and storage as arrays (eg. contract.storage]  msg.data])nnyte arrays (eg.   bytes(), setch(,,"c")), y  getch(,)nnhe intent of the erpent language is to make programming smart contracts and decetralized applications in thereum as easy as programming boring command line apps is in ython. he language is designed to be maimally clean and maimally simple, combining the benefits of a compiled language with an easy-to-use coding eperience. ust the logic, and nothing but the logic. nfortunately, floating point numbers are missing, as are higher-order constructs like list comprehensions and closures, but aside from that erpent has basically everything that you need.nnetting tartednno how do you code in erpent he first step is to set up the development and eecution environment. o do this, first download two librariesnnpyethereumnnandnnserpentnn. he simplest way to download is to either download the zip files from ithub and unpack them, or run git clonennhttp//github.com/ethereum/pyethereumnnand git clonennhttp//github.com/ethereum/serpentnn. hen, enter the pyethereum directory, and run sudo python setup.py install to install pyethereum to your system, and do the same with serpent.nnow that the software is downloaded, let’s get right to it. o start off, try thisnnserpent compile_to_assembly '  'nn"nnbnnenngnninnnnncnnonndnnennnn.nnennnnndnncnnonndnnennnn"nn,nn"nnnnnnnn"nn,nn"nnnnnnnnnnnn"nn,nn"nnnnnnnnnn"nn,nn"nnnnnnnnnnnn"nn,nn"nnbegincode_.endcode_", "", "", "", "", "nnbnnenngnninnnconndnnennnn​nn.nnennnnndnnconndnnennnn​nn"nn,nn"nnnnnnnn"nn,nn"nnnnnnnn"nn,nn"nnnnnnnnnn"nn,nn"nnnnnnnn"nn,nn"nnbegincode_", "", "", "~begincode_", "#_", , , "", "#_", "~endcode_"]nnhe compile_to_assembly instruction compiles the code down into an intermediate human-readable “assembly language” format rather than plain old bytecode. sing plain old serpent compile would give you the much more incomprehensible but compact bbaf. n this case, the “core” of the code is , , ""], putting the value  into memory slot , and the rest of the code basically says to return a contract containing that code. nother command that you may find useful is serpent get_vars this will give you a list of all the variables together with their associated memory indices. n this case, you get {'' }, meaning that the compiler is choosing to use the memory inde  to store the variable . he last interesting command is parse to convert erpent into an intermediate high-level parse tree. ow, since erpent is a programming language, we want to run programs, and so ideally we would like to actually create contracts and run them as quickly as possible. et’s try that. irst, open a file, call it “namecoin.se“, and put the following code into itnnif !contract.storagemsg.data]]
contract.storagemsg.data]]  msg.data]
return()
else
return()nnhis is the two-line amecoin eample that we love so much, but embellished with return values to make it easier to work with for this tutorial. yping serpent compile namecoin.se should givennbbafbbbfbbfnnow, let’s see if we can actually get the code running. o do that, the first step is actually to create for ourselves an account. he process here is almost eactly the same as in my ython itcoin librarynnpybitcointoolsnn in general, anyone who is familiar with pybitcointools should feel right at home in pyethereum, although unfortunately in pyethereum it was not really practical to stick to pybitcointools’ “no classes” mantra in the code. he first step is to generate a private keynnpyethtool sha cownncefdfebaccaebdbdfaaabaecaafnnn production code, you should obviously replace “cow” with an actually secure password. f you want your account to be a “brainwallet” that you can easily remember, my main advice is to prepend a username, eg. “vbuterinblhblhmnky#!$!%”, ensuring that attackers need to target you individually instead of performing a blanket attack on everyone simultaneously assuming  brainwallet users this reduces your risk from a trial-and-error attack by .%.nnf you want to use your key later, on any standard inu shell you can also type in keynnpyethtool sha cownn, and then use$key to use the key thereafter. e’ll use that format here from now on, so if you are following along then you should also do bothnnkeynnpyethtool sha cownncodennserpent compile namecoin.senno now, let’s keep going.nnaddrnnpyethtool privtoaddr $keynnecho $addrnncdadfecdecabcfedfddnnow, we create a new genesis block, and we'll set the initial endowment to  wei ( ether) for your address.nngenesisnnpyethtool mkgenesis $addr nnecho $genesisnnfbfaeaadccdedecdaabbbccdadbafafddabcdddbfcdbaccfebaebeffadeacfafdcbeabffcdfbafbbbeeaeeffefbccnnow that we have that out of the way, we can get to actually doing stuff to the block. he only way to do anything in a blockchain-based architecture, in general, is to create and apply a transaction. ere, we will need multiple transactions the first to create the contract, and then the latter ones to actually use it. ere's contract creationnnunsignedtnnpyethtool mkcontract   $codennecho $unsignedtnnfcedaafbbafbbbfbbfnntnnpyethtool sign $unsignedt $keynnecho $tnnffedaafbbafbbbfbbfcababefadcaffeafcafbfdffcaafbcaccffbdcaaeaabefbfccadbfnnr, the easier waynntnnpyethtool mkcontract   $code | pyethtool -s sign $keynnecho $tnnffedaafbbafbbbfbbfcababefadcaffeafcafbfdffcaafbcaccffbdcaaeaabefbfccadbfnnhe first field in mkcontract is a nonce, which must be equal to the number of transactions you already sent from that account. he purpose of requiring a nonce is to prevent replay attacks otherwise, if you sent ob  ether, ob could simply replay that transaction over and over again until you run out of money, whereas here due to the nonce requirement the transaction can only go through once. he second field is the amount of ether to send (in the case of contract creation, the amount of ether to initially provide to the contract), and the third field is the code. ote that the ransaction.contractnnfunction callnnalso has two more fields between value and recipient gasprice and startgas. yethtool is nice to you and initializes these values to  szabo (ie.  wei or one millionth of an ether) per gas and  gas, respectively. his will give you a theoretical maimum of  computational steps for the code to run, although in practice it may run out after  if you use many epensive operations. inally, once you create the transaction, you need to sign it with your private key.nnnce that's done, we just, wellnnpyethtool applytnngnnennnnnennsnninnsnngenesisnngnnennnnnesnninnsnntnn{"result" "daceffebffccecfa", "block" "fefdaadccdedecdaabbbccdadbafafddabcecbfffcbefebbfffdaacafadcdcaaffefbecfeafdadeacfbafdcbeabffcdfbafbbbeeaeeffefbfafabffedaafbbafbbbfbbfcababefadcaffeafcafbfdffcaafbcaccffbdcaaeaabefbfccadbfabcecbfffcbefebbfffdaacbc"}nnhis gives you two values. he first is the address of the contract, and the second is the new block data. ote that the block data does not represent the entire block there is also the state data hidden in the statedb folder. ence, if you try to deserialize the block on a fresh machine it likely will not work. rom the values returned, set the first value to contract and the second to med so we can use them later. ow, we need to craft a transaction to actually use this contract. uppose we want to register "george" to . o do that, however, we first need to do another annoying chore package up the data. ortunately, the serpent compiler has a utility for doing just thatnndatannecho '"george",]' | serpent -j encode_datalistnnecho $datannfdnnhe namecoin contract takes data in two fields, the key and the value, so we simply put them into a  array and use erpent to encode it. he encoder can accept strings and numbers as the individual elements in the array. ote that unfortunately ython's  decoder requires double quotes for internal strings "'george',]" would not work.nnow, we do thisnntnnpyethtool mkt  $contract  $data | pyethtool -s sign $keynnecho $tnnfaedadaceffebffccecfabfdbacffdadbcbeedfbcfcaedcfcefdefcdeddfcdbedcbnnndnnpyethtool applytnnmnnenndnnmednnmnnenndnntnn{"result" "", "block" "fefdaadccdedecdaabbbccdadbafafddaddfadbcfbbdcdaebbbfdffeebaddbcfbeeffccbabccddcdfccbdeacfafafdcbeabffcdfbafbbbeeaeeffefbffabffedaafbbafbbbfbbfcababefadcaffeafcafbfdffcaafbcaccffbdcaaeaabefbfccadbfabcecbfffcbefebbfffdaacbfcdbafaedadaceffebffccecfabfdbacffdadbcbeedfbcfcaedcfcefdefcdeddfcdbedcbaddfadbcfbbdcdaebbbfdffeebafc"}nnegistration successful! he result here is two values, just as before the first is the new block state, and the second is the response returned by the contract. ased on the definition of the contract above, "" means success. ow, just to be sure, let's set end to the block he returned by the previous command and peek at the statennpyethtool getstate $endnn{'nonce' 'gdcbebffcdfbafbbbeeaeefeb)', 'min_gas_price' , 'etra_data' '', 'state_root' 'fdfadbicfbdcdaebbbfdffegeb', 'difficulty' , 'timestamp' , 'number' , 'gas_used' , 'coinbase' '', 't_list_root' 'didbcfbeeffccb#abcddcdffb', 'state' {'' {'nonce' , 'balance' , 'storage' {}, 'code' ''}, 'daceffebffccecfa' {'nonce' , 'balance' , 'storage' { }, 'code' 'bbbfbbf'}, 'cdadfecdecabcfedfdd' {'nonce' , 'balance' , 'storage' {}, 'code' ''}}, 'uncles_hash' 'dccedec]zabbgbccdadbatfafdd', 'prevhash' '', 'gas_limit' }nnou can see the contract account near the beginning of the state description, with "george" registered to  as epected. e're done! s an eercise, try constructing two more transactions, one registering "george" to  and another registering "harry" to . f you apply them all sequentially after these two, the one registering "george" to  should return , but the one registering "harry" to  should succceed.nnoing it in ythonnnhat's pyethtool, the command line utility. ow, how does it work using pyethereum itself s it turns out, it's surprisingly easy. ere's the sessionnn import serpentnn from pyethereum import transactions, blocks, processblock, utilsnn code  serpent.compile(open('namecoin.se').read())nn key  utils.sha('cow')nn addr  utils.privtoaddr(key)nn genesis  blocks.genesis({ addr ** })nn t  transactions.contract(,**,,,code).sign(key)nn result, contract  processblock.apply_t(genesis,t)nn t  transactions.ransaction(,**,,contract,,serpent.encode_datalist('george',])).sign(key)nn result, ans  processblock.apply_t(genesis,t)nn serpent.decode_datalist(ans)nn]nn genesis.to_dict()nn'nonce' 'gdcbebffcdfbafbbbeeaeefeb)', 'min_gas_price' , 'etra_data' '', 'state_root' '', 'difficulty' , 'timestamp' , 'number' , 'gas_used' , 'coinbase' '', 't_list_root' 'bdb!|b& bbbsdaedn*ee', 'state' {'' {'nonce' , 'balance' , 'storage' {}, 'code' ''}, 'daceffebffccecfa' {'nonce' , 'balance' , 'storage' { }, 'code' 'ebbfbbf'}, 'cdadfecdecabcfedfdd' {'nonce' , 'balance' , 'storage' {}, 'code' ''}}, 'uncles_hash' 'dccedec]zabbgbccdadbatfafdd', 'prevhash' '', 'gas_limit' }nn genesis.get_balance(addr)nnnn genesis.get_storage_data(contract,'george')nnnnnother important command is processblock.debug   this starts printing code eecution step by step, helping you debug what is wrong in your contract code - or my pyethereum  or erpent implementation!nnetting into the odenno that's your introduction to how to use pyethereum. ow, let's get into the most fun part, writing contracts. or reading efficiency, let's provide the amecoin contract againnnif !contract.storagemsg.data]]
contract.storagemsg.data]]  msg.data]
return()
else
return()nnhat does this contract do ssentially, this contract implements a name registration database by simply using that as the sole function of the long-term storage of the contract. ontract code theoretically has three places to put data stack, memory and storage. f those three, stack and memory are used implicitly in erpent to support arithmetic and variables, but long-term storage is the only one that survives once eecution is over. ere, when you register "george" to , the contract first checks ifcontract.storage"george"] is not nonzero, ie. is zero. f it is, then it sets that storage inde to the value provided, , and then returns . f it is not, then it returns zero. ote that this contract has no way for other contracts to access it it is only really usable by eternal applications. ore advanced name registries would have an  for contracts to fetch the data associated with a name as well.nnow, on to a more intricate eamplenninit
contract.storagecdadfecdecabcfedfdd]  
code
if msg.datasize  
addr  msg.data]
return(contract.storageaddr])
else
from  msg.sender
fromvalue  contract.storagefrom]
to  msg.data]
value  msg.data]
if fromvalue  value
contract.storagefrom]  fromvalue - value
contract.storageto]  contract.storageto] + value
return()
else
return()nnhis is the "currency contract", or more precisely an embellished version of it with return values to make debugging easier. his contract is interesting for several reasons. irst, it has an initialization step, which gets called when the contract is first made. his initializes an account with  currency units owned by that account.nnfter that, there are two code paths. irst, incoming messages might contain only one data field. n that case, these messages are treated as balance queries, and simply return the balance of the queried address. ote that msg.data] provides the integer at bytes ... of the transaction data, msg.data] provides the integer at bytes ..., and so forth. his is a convenience introduced in erpent the underlying transaction data is all byte-based. ncidentally, this is why we needed to use erpent's encode_datalist function to generate the transaction data.nnecond, incoming messages might contain two data fields. n that case, the messages are treated as requests to send to that address. he sender is inferred from the sender of the message, and the recipient and the value are taken from the first two fields (ie. first  bytes) in msg.data. f there is enough money to transfer, it transfers the money and returns  otherwise it returns .nnhallengenn create a currency contract which takes a fee, denominated in its internal currency, from every transaction, and refunds a small amount of ether to everyone sending a successful transaction, so people (or contracts) who want to deal in this currency would not have to worry about simultaneously maintaining currency and ether balances themselves. he contract would also include a third transaction type, perhaps taking  arguments, through which someone can buy internal currency units from the contract by sending it ether. he contract should keep track of two variables its own balance in its currency, and its ether balance, and it should dynamically adjust the transaction fee and the echange rate in order to keep both its ether balance and its internal currency balance in bal- uh, in an approimate equilibrium.nnontracts alling ontractsnnhis is a proprietary data feed contractnnowner  cdadfecdecabcfedfdd
if msg.sender  owner and msg.datasize  
contract.storagemsg.data]]  msg.data]
return()
else
return(contract.storagemsg.data]])nnhis contract is designed to work as a key/value that can be edited only by its owner, but also also allows anyone to query its contents the point is for the owner to use various storage indices to record changing data like the  price of ether. ere, there are two main "clauses" in the contract, one for modifying storage which triggers if a key and a value are provided and the message originates from the contract's owner, and the other for just reading storage. he msg.datasize variable tells you the number of -byte data fields there is in the message data. here are no particularly new features here this contract is actually fairly simple, and  encourage you to first follow and make sure you understand the logic involved and then play with the contract, instantiating it in a block and then pushing set and query transactions to it.nnhe interesting part, however, comes when we use this contract inside of another contract. eet this monstrosity, a hedging contractnnif !contract.storage]
contract.storage]  msg.sender
contract.storage]  msg.value
contract.storage]  msg.data]
contract.storage]  msg.data]
return()
elif !contract.storage]
ethvalue  contract.storage]
if msg.value  ethvalue
contract.storage]  msg.sender
datasource  contract.storage]
datainde  contract.storage]
othervalue  ethvalue * msg(datasource,,t.gas-,datainde],)
contract.storage]  othervalue
contract.storage]  block.timestamp + 
return(,othervalue],)
else
datasource  contract.storage]
datainde  contract.storage]
othervalue  contract.storage]
ethvalue  othervalue / msg(datainde,,t.gas-,datasource],)
if ethvalue  contract.balance
send(contract.storage],contract.balance,t.gas-)
return()
elif block.timestamp  contract.storage]
send(contract.storage],contract.balance - ethvalue,t.gas-)
send(contract.storage],ethvalue,t.gas-)
return()
else
return()nnhis contract is bulky because it's designed to be more testing-friendly an optimal implementation is roughly half the size. he contract works as followsnnarty  sends in  ether alongside a data feed contract  and a currency code  as data items, and is registered at contract storage inde . ,  and  are registered in contract storage indices ,  and . n this case, suppose that the currency code represents .nnarty  sends in  ether, and is registered at contract storage inde . he contract then calls  with data  to determine the price of ether in the given currency, and uses this to compute , the amount of value in  sent by each party.  is stored at inde , and an epiry time set to  hours in the future is stored at inde .nnaybe, the price of ether in  drops by more than %. f this happens, then there is not enough ether in the contract altogether to pay  . o prevent this, as soon as the price slips under the % mark, anyone (usually ) can ping the contract to withdraw all  ether into 's address and thereby recover to 's address almost all of the amount, as measured in , that  put in, and leave  with nothing. f this happens, the contract returns .nntherwise, after one day, anyone can send a transaction to "ping" the contract and cause it to send   worth of ether to  and the remaining ether to , returning .nnf there is no "margin call" or "epiry" event, then a ping to the contract does nothing and returns .nnhe point of the hedging contract is that  benefits by always getting back the same quantity of  that he put in, and  benefits if he believes that the value of ether will go up, since a % rise in the ether price will, in this circumstance, give him a % profit.  can of course be substituted with anything, including , gold or the consumer price inde.nnhe important new features eplored here are msg, send and array literals. msg and send are both ways of sending message to other contracts. he syntaes arennsend(to, value, gas)nnout  msg(to¸ value, gas, datastart, datalength)nnmsg(to, value, gas, datastart, datalength, outstart, outlength)nnend is simpler, assuming that all you want to do is send money with no bells and whistles involved. he latter two are equivalent ways of sending a message to another contract, differing only in how they handle the output the first caps output to  bytes and sticks it straight into a variable, whereas the second takes in two arguments for the position in memory where to dump the output. he "output" of a message is blank if the recipient is not-yet-eistent, an eternally owned account, or does not eplicitly specify a return value, and if the output does specify a return value then the output is that value ("value" in this contet being an arbitrary-length byte array, not a -byte number). hese two are thus both ways of saying the same thingnnd  array()
d]  
d]  
d]  
  msg(, , , d, )nnndnnd  array()
d]  
d]  
d]  
w  array()
msg(, , , d, , w, )
  w]nnn the contract eample above, we used the data feed contract to provide the price of ether in , and then directly plugged it into the formula othervalue  ethvalue * msg(datasource,,t.gas-,datainde],).nnrray literals are another nice convenience feature the truly optimal way to write the above code is as followsnn  msg(, , , , , ], )nnote that you unfortunately still need to specify the array length. owever, here the array itself is created and referenced all inline, without needing to manually set things up. ll of the magic is done by the erpent compiler.nno that's basically it for today. hat might you want to code in erpent ell, here are a few possibilitiesnnchellingoinnn contract-based implementation ofnnusticenn.nnome skeleton code for a decentralized organization.nn board game (eg. chess, o)nn decentralized echange, with a contract-based order book, between ether and the sub-currency contract given above.nnny of the other eamples in ournnwhitepapernnnjoy, and have fun! lso, if you do find any bugs in pyethereum or erpent, please be sure to point them out.nnee alsonnlist of erpent language operations