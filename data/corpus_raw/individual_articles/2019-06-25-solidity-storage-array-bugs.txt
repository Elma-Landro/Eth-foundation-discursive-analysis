Titre: Solidity Storage Array Bugs\nAuteur: Solidity and Security Team\nDate: June 25, 2019\nURL: https://blog.ethereum.org/2019/06/25/solidity-storage-array-bugs\nCatégorie: Non catégorisé\n\n==================================================\n\nolidity torage rray ug nnouncementnnhis blog post is about two bugs connected to storage arrays which are otherwise unrelated. oth have been present in the compiler for a long time and have only been discovered now even though a contract containing them should very likely show malfunctions in tests.nnaenam imnnwith help fromnnguyen hamnn, both fromnnurvegridnndiscovered an issue where invalid data is stored in connection with arrays of signed integers.nnhis bug has been present since olidity .. and we consider it the more serious of the two. f these arrays use negative integers in a certain situation, it will cause data corruption and thus the bug should be easy to detect.nnhrough the thereum bug bounty program, we received a report about a flaw within the new eperimental  encoder (referred to as ncoder). he new  encoder is still marked as eperimental, but we nevertheless think that this deserves a prominent announcement since it is already used on mainnet.
redits to ing huan in (ofnnhttps//www.secondstate.ionn) for both discovering and fiing the bug!nnhenn.. releasenncontains the fies to the bugs.
t the moment, we do not plan to publish a fi to the legacy .. series of olidity, but we might if there is popular demand.nnoth bugs should be easily visible in tests that touch the relevant code paths.nnetails about the two bugs can be found below.nnigned nteger rray ugnnho should be concernednnf you have deployed contracts which use signed integer arrays in storage and either directly assignnna literal array with at least one negative value in it (nn  -, -, -]nn) ornnan eisting array of anndifferentnnsigned integer typennto it, this will lead to data corruption in the storage array.nnontracts that only assign individual array elements (i.e. withnn]  -nn) are not affected.nnow to check if contract is vulnerablennf you use signed integer arrays in storage, try to run tests where you use negative values. he effect should be that the actual value stored is positive instead of negative.nnf you have a contract that meets these conditions, and want to verify whether the contract is indeed vulnerable, you can reach out to us viannsecurityethereum.orgnn.nnechnical detailsnntorage arrays can be assigned from arrays of different type. uring this copy and assignment operation, a type conversion is performed on each of the elements. n addition to the conversion, especially if the signed integer type is shorter than  bits, certain bits of the value have to be zeroed out in preparation for storing multiple values in the same storage slot.nnhich bits to zero out was incorrectly determined from the source and not the target type. his leads to too many bits being zeroed out. n particular, the sign bit will be zero which makes the value positive.nnncoder rray ugnnho should be concernednnf you have deployed contracts which use the eperimental  encoder , then those might be affected. his means that only contracts which use the following directive within the source code can be affectednnpragma eperimental ncodernnnndditionally, there are a number of requirements for the bug to trigger. ee technical details further below for more information.nnow to check if contract is vulnerablennhe bug only manifests itself when all of the following conditions are metnntorage data involving arrays or structs is sent directly to an eternal function call, tonnabi.encodennor to event data without prior assignment to a local (memory) variable nnthis data either contains an array of structs or an array of statically-sized arrays (i.e. at least two-dimensional).nnn addition to that, in the following situation, your code is  affectednnif you only return such data and do not use it innnabi.encodenn, eternal calls or event data.nnossible consequencesnnaturally, any bug can have wildly varying consequences depending on the program control flow, but we epect that this is more likely to lead to malfunction than eploitability.nnhe bug, when triggered, will under certain circumstances send corrupt parameters on method invocations to other contracts.nnechnical detailsnnuring the encoding process, the eperimental  encoder does not properly advance to the net element in an array in case the elements occupy more than a single slot in storage.nnhis is only the case for elements that are structs or statically-sized arrays. rrays of dynamically-sized arrays or of elementary datatypes are not affected.nnhe specific effect you will see is that data is "shifted" in the encoded array f you have an array of typennuint]]nnand it contains the datann, ], , ], , ]]nn, then it will be encoded asnn, ], , ], , ]]nnbecause the encoder only advances by a single slot between elements instead of two.nnhis post was jointly composed by aic, chriseth, holiman