Titre: Verkle tree structure\nAuteur: Guillaume Ballet and Dankrad Feist\nDate: December 2, 2021\nURL: https://blog.ethereum.org/2021/12/02/verkle-tree-structure\nCat√©gorie: Non cat√©goris√©\n\n==================================================\n\nerkle tree is a commitment scheme that works similar to a erkle tree, but has much smaller witnesses. t works by replacing the hashes in a erkle tree with a vector commitment, which makes wider branching factors more efficient.nnhanks to evaundray edderburn for feedback on the post.nnverviewnnor details on how verkle trees work, seennankrad's blog postnnitalik's blog postnneep an  on erkle triesnnhe aim of this post is to eplain the concrete layout of thenndraft verkle tree nn. t is aimed at client developers who want to implement verkle trees and are looking for an introduction before delving deeper into the .nnerkle trees introduce a number of changes to the tree structure. he most significant changes arenna switch from  byte keys to  byte keys (not to be confused with  byte addresses, which is a separate change)nnthe merge of the account and storage tries and finallynnhe introduction of the verkle trie itself, which uses vector commitments instead of hashes.nns the vector commitment scheme for the verkle tree, we usennedersen commitmentsnn. edersen commitments are based on elliptic curves. or an introduction to edersen commitments and how to use them as polynomial or vector commitments using nner roduct rgumentss, seennherenn.nnhe curve we are using isnnandersnatchnn. his curve was chosen because it is performant, and also because it will allow efficient s in _ to reason about the verkle tree in the future. his can be useful for rollups as well as allowing an upgrade where all witnesses can be compressed into one  once that becomes practical, without needing a further commitment update.nnhe curve order/scalar field size of bandersnatch isnnp  nn, which is a  bit prime. s a result of this, we can only safely commit to bit strings of at most  bits, otherwise the field overflows. e chose a branching factor (width) of  for the verkle tree, which means each commitment can commit to up to  values of  bits each (or to be precise, integers up tonnp - nn). e write this asnnommit(v‚ÇÄ, v‚ÇÅ, ..., v‚ÇÇ‚ÇÖ‚ÇÖ)nnto commit to the listnnvnnof length .nnayout of the verkle treennne of the design goals with the verkle tree  is to make accesses to neighbouring positions (e.g. storage with almost the same address or neighbouring code chunks) cheap to access. n order to do this, a key consists of annstemnnof  bytes and annsuffinnof one byte for a total of  bytes. he key scheme is designed so that "close" storage locations are mapped to the same stem and a different suffi. or details please look at thenn draftnn.nnhe verkle tree itself is then composed of two types of nodesnntension nodesnn, that represent  values with the same stem but different suffiesnnnner nodesnn, that have up to  children, which can be either other inner nodes or etension nodes.nnhe commitment to an etension node is a commitment to a  element vector the remaining positions will be . t isnn‚ÇÅ and ‚ÇÇ are two further commitments that commit to all the values with stem equal tonnstemnn. he reason we need two commitments is that values have  bytes, but we can only store  bits per field element.  single commitment would thus not be enough to store  values. o instead ‚ÇÅ stores the values for suffi  to , and ‚ÇÇ stores  to , where the values are split in two in order to fit into the field size (we'll come to that later.)nnhe etension together with the commitments ‚ÇÅ and ‚ÇÇ are referred to as "etension-and-suffi tree" (a for short).nnigure nnepresentation of a walk through a verkle tree for the keynnfeabcd..ffnn the path goes through  internal nodes with  children each (, , ), one etension node representingnnabcd..ffnnand the two suffi tree commitments, including the value fornnnn, v‚ÇÑ. ote thatnnstemnnis actually the first  bytes of the key, including the path through the internal nodes.nnommitment to the values leaf nodesnnach etension and suffi tree node contains  values. ecause a value is  bits wide, and we can only store  bits safely in one field element, four bits would be lost if we simply tried so store one value in one field element.nno circumvent this problem, we chose to partition the group of  values into two groups of  values each. ach -byte value in a group is split into two -byte values. o a value v·µ¢‚àà ùîπ‚ÇÉ‚ÇÇ is turned into v‚ÅΩÀ°·µí ∑·µâ ≥‚Åæ·µ¢ ‚àà ùîπ‚ÇÅ‚ÇÜ and v‚ÅΩ·µò·µñ·µñ·µâ ≥‚Åæ·µ¢‚àà ùîπ‚ÇÅ‚ÇÜ such that v‚ÅΩÀ°·µí ∑·µâ ≥‚Åæ·µ¢ ++ v‚ÅΩ·µò·µñ·µñ·µâ ≥‚Åæ·µ¢ v·µ¢.nn "leaf marker" is added to the v‚ÅΩÀ°·µí ∑·µâ ≥‚Åæ·µ¢, to differentiate between a leaf that has never been accessed and a leaf that has been overwritten with s.nno value ever gets deleted from a verkle treenn. his is needed for upcoming state epiry schemes. hat marker is set at the th bit, i.e. v‚ÅΩÀ°·µí ∑·µâ ≥ ·µê·µí·µà‚Å±·∂†‚Å±·µâ·µà‚Åæ·µ¢  v‚ÅΩÀ°·µí ∑·µâ ≥‚Åæ·µ¢ + ¬π¬≤‚Å∏ if v·µ¢ has been accessed before, and v‚ÅΩÀ°·µí ∑·µâ ≥ ·µê·µí·µà‚Å±·∂†‚Å±·µâ·µà‚Åæ·µ¢   if v·µ¢ has never been accessed.nnhe two commitments ‚ÇÅ and ‚ÇÇ are then defined asnnommitment of etension nodesnnhe commitment to an etension node is composed of an "etension marker", which is just the number , the two subtree commitments ‚ÇÅ and ‚ÇÇ, and thennstemnnof the key leading to this etension node.nnnlike etension nodes in the erkle-atricia tree, which only contain the section of the key that bridges the parent internal node to the child internal node, the stem covers the whole key up to that point. his is because verkle trees are designed with stateless proofs in mind if a new key is inserted that "splits" the etension in two, the older sibling need not be updated, which allows for a smaller proof.nnommitment of nternal nodesnnnternal nodes have the simpler calculation method for their commitments the node is seen as a vector of  values, that are the (field representation of the) root commitment of each of their  subtrees. he commitment for an empty subtree is . f the subtree is not empty, then the commitment for the internal node isnnwhere the ·µ¢ are the children of the internal node, and  if a child is empty.nnnsertion into the treennigure  is an illustration of the process of inserting a new value into the tree, which gets interesting when the stems collide on several initial bytes.nnigure nnalue v‚ÇÅ‚Çâ‚ÇÇ is inserted at locationnn...nnin a verkle tree containing only value v‚ÇÅ‚ÇÇ‚Çá at locationnn...nn. ecause the stems differ at the third byte, two internal nodes are added until the differing byte. hen another "etension-and-suffi" tree is inserted, with a full -byte stem. he initial node is untouched, and ¬≤‚ÇÄ has the same value as ‚Å∞‚ÇÄ before the insertion.nnhallower trees, smaller proofsnnhe verkle tree structure makes for shallower trees, which reduces the amount of stored data. ts real power, however, comes from the ability to produce smaller proofs, i.e. witnesses. his will be eplained in the net article.