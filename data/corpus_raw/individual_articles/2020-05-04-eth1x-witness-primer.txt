Titre: The 1.x Files: A Primer for the Witness Specification\nAuteur: Griffin Ichiba Hotchkiss\nDate: May 4, 2020\nURL: https://blog.ethereum.org/2020/05/04/eth1x-witness-primer\nCatégorie: Non catégorisé\n\n==================================================\n\nince a lot of us have a bit more time on our hands,  thought now might be a good opportunity to proceed with something perhaps a little bit boring and tedious, but nevertheless quite fundamental to the tateless thereum effort understanding the formal itness pecification.nnike the captain of the attleship in tarraft, we're going to take it slow. he witness spec is not a particularlynncomplicatednnconcept, but it is verynndeepnn. hat depth is a little daunting, but is well worth eploring, because it'll provide insights that, perhaps to your nerdy delight, etend well beyond the world of blockchains, or even software!nny the end of this primer, you should have at least minimum-viable-confidence in your ability to understand what the formal tateless thereumnnitness pecificationnnis all about. 'll try to make it a little morennfunnn, too.nnecap hat you need to know about tatenntateless thereum is, of course, a bit of a misnomer, because the state is really what this whole effort is about. pecifically, finding a way to make keeping a copy of the whole thereum state annnoptionalnnthing. f you haven't been following this series, it might be worth having a look atnnmy earlier primernnon the state of stateless thereum. 'll give a short  here though. eel free to skim if you feel like you've already got a good handle on this topic.nnhe complete ‘state’ of thereum describes the current status of all accounts and balances, as well as the collective memories of all smart contracts deployed and running in the . very finalized block in the chain has one and only one state, which is agreed upon by all participants in the network. hat state is changed and updated with each new block that is added to the chain.nnhe thereum tate is representednnin siliconnas annerkle-atricia rienn a hashed data structure that organizes each individual piece of information (e.g. an account balance) into one massive connected unit that can be verified for uniqueness. he complete state trie is too massive to visualize, but here's a 'toy version' that will be helpful when we get to witnessesnnike magical cryptographic caterpillars, the accounts and code of smart contracts live in the leaves and branches of this tree, which through successive hashing eventually leads to a singlennroot hashnn. f you want to know that two copies of a state trie are the same, you can simply compare the root hashes. aintaining relatively secure and indisputable consensus over one 'canonical' state is the essence of what a blockchain is designed to do.nnn order to submit a transaction to be included in the net block, or to validate that a particular change is consistent with the last included block, thereum nodes must keep a complete copy of the state, and re-compute the root hash (over and over again). tateless thereum is a set of changes that will remove this requirement, by adding what's known as a 'witness'.nn itness ketchnnefore we dive into the witness specification, it'll be helpful to have an intuitive sense of what a witness is. gain, there is a more thorough eplanation in the post on the thereum state linked above.nn witness is a bit like a cheat sheet for an oblivious (stateless) student (client). t's just the minimum amount of information need to pass the eam (submit a valid change of state for inclusion in the net block). nstead of reading the whole tetbook (keeping a copy of the current state), the oblivious student (stateless client) asks a friend (full node) for a crib sheet to submit their answers.nnn very abstract terms, a witness provides all of the needed hashes in a state trie, combined with some ‘structural’ information about where in the trie those hashes belong. his allows an ‘oblivious’ node to include new transaction in its state, and to compute a new root hash locally – without requiring them to download an entire copy of the state trie.nnet's move away from the cartoonish idea and towards a more concrete representation. ere is a "real" visualization of a witnessnn recommend opening this image in a new tab so that you can zoom in and really appreciate it. his witness was selected because it's relatively small and easy to pick out features. ach little square in this image represents a single 'nibble', or half of a byte, and you can verify that yourself by counting the number of squares that you have to 'pass through', starting at the root and ending at an ther balance (you should count ). hile we're looking at this image, notice the huge chunk of code within one of the transactions that must be included for a contract call -- code makes up a relatively large part of the witness, and could be reduced by code merkleization (which we'll eplore another day).nnome ormalitiesnnne of the fundamental distinguishing features of thereum as a protocol is itsnnindependencennfrom a particular implementation. his is why, rather than just onennofficialnnclient as we see in itcoin, thereum has several completely different versions of client. hese clients, written in various programming languages, must adhere tonnhe thereum ellow apernn, which eplains in much more formal terms hownnanynnclient should behave in order to participate in the thereum protocol. hat way, a developer writing a client for thereum doesn't have to deal with any ambiguity in the system.nnhe itness pecification has this eact goal to provide annnunambiguousnndescription of what a witness is, which will make implementing it straightforward in any language, for all clients. f and when tateless thereum becomes 'a thing', the witness specification can be inserted into the ellow aper as an appendi.nnhen we saynnunambiguousnnin this contet, it means something stronger than what you might mean in ordinary speech. t's not that the formal specification is just a really, really, really, detailed description of what a witness is and how it behaves. t means that, ideally, there isnnliterally one and only one waynndescribe a particular witness. hat is to say, if you adhere to the formal specification, it'd bennimpossiblennfor you to write an implementation for tateless thereum that generates witnesses different than any other implementation also following the rules. his is key, because the witness is going to (hopefully) become a new cornerstone of the thereum protocol t needs to be correct by construction.nn atter of emantics (and ynta)nnlthough 'blockchain development' usually implies something new and eciting, it must be said that a lot of it is grounded in much older and wiser traditions of computer programming, cryptography, and formal logic. his really comes out in the itness pecification! n order to understand how it works, we need to feel comfortable with some of the technical terms, and to do that we're going to have to take a little detour into linguistics and formal language theory.nnead aloud the following two sentences, and pay particular attention to your intonation and cadencennfuriously sleep ideas green colorlessnncolorless green ideas sleep furiouslynn bet the first sentence came out a bit robotic, with a flat emphasis and pause after each word. y contrast, the second sentence probably felt natural, if a bit silly. ven though it didn't reallynnmean anythingnn, the second sentencennmade sensennin a way that the first one didn't. his is a little intuition pump to draw attention to the distinction betweennnyntannandnnemanticsnn. f you're an nglish speaker you have an understanding of what the wordsnnrepresentnn(their semantic content), but that was largely irrelevant here what you noticed was a difference between valid and invalid grammar (their synta).nnhis eample sentence is fromnna  papernnby one oam homsky, which is a name you might recognize. lthough he is now known as an influential political and social thinker, homsky's first contributions as an academic were in the field of logic and linguistics, and in this paper, he created one of the most useful classification systems for formal languages.nnhomsky was concerned with the mathematical description of grammar, how one can categorize languages based on their grammar rules, and what properties those categories have. ne such property that is relevant to us isnnsyntactic ambiguitynn.nnmbiguous uffalonnonsider the grammatically correct sentence "nnuffalo buffalo uffalo buffalo buffalo buffalo uffalo buffalo.nn" -- this is a classic eample that illustrates just how ambiguous nglish synta rules can be. f you understand that, depending on the contet, the word 'buffalo' can be used as a verb (to intimidate), an adjective (being from uffalo, ), or a noun (a bison), you can parse the sentence based on where each word belongs.nne could also use entirely different words, and multiple sentences "ou know those  bison that other  bison intimidate ell, they intimidate, too. hey intimidate  bison, to be eact."nnut what if we want to remove the ambiguity, but still restrict our words to use only 'buffalo', and keep it all as a single sentence t's possible, but we need to modify the rules of nglish a bit. ur new "language" is going to be a little more eact. ne way to do that would be to mark each word to indicate its part of speech, like sonnuffalo{pn} buffalo{n} uffalo{pn} buffalo{n} buffalo{v} buffalo{v} uffalo{pn} buffalo{n}nnerhaps that's still not super clear for a reader. o make it even more eact, let's try using a bit ofnnsubstitutionnnto help us herd some of these "buffalo" into groups. ny bison from uffalo,  is really just one special version of what we would call a "noun phrase", ornnnn. e can substitutennnninto the sentence whenever we encounter the stringnnuffalo{pn} buffalo{n}nn. ince we're getting a bit more formal, we might decide to use a shorthand notation for this and other future substitution rules, by writingnn  uffalo{pn} buffalo{n}nnwherennnnmeans "hat's on the left side can be replaced by what's on the right side". mportantly, we don't want this relationship to go the other way imagine how mad the oulder buffalo would get!nnpplying our substitution rule to the full sentence, it would change tonn  buffalo{v} buffalo{v} nnow, this is still a bit confusing, because in this sentence there is a sneaky relative clause, which can be seen a lot more clearly by inserting the word 'that' into the first part our sentence, i.e.nn *that*  buffalo{v}...nn.nno let's make a substitution rule that groups the relative clause intonnnn, and saynn   buffalo{v}nndditionally, since a relative clause really just makes a clarification about a noun phrase, the two taken together are equivalent to just another noun phrasenn  nnith these rules defined and applied, we can write the sentence asnn buffalo{v} nnhat seems pretty good, and really gets at the core relationship this silly sentence epresses ne particular group of bison intimidating another group of bison.nne've taken it this far, so why not go all the way henever 'buffalo' as a verb precedes a noun, we could call that a verb phrase, ornnnn, and define a rulenn  buffalo{v}nnnd with that, we have our single complete valid sentence, which we could callnnnnnn  nnhat we've done here might be better represented visuallynnhat structure looks curiously familiar, doesn't itnnhe buffalo eample is a bit silly and not very rigorous, but it's close enough to demonstrate what's going on with the weird mathematical language of the itness pecification, which  have very sneakily introduced in my rant about buffalo. t's callednnackus-aur formnnnotation, and it's often used in formal specifications like this, in a variety of real-world scenarios.nnhe 'substitution rules' we defined for our restricted nglish language helped to make sure that, given a herd of "buffalo", we could construct a 'valid' sentence without needing to know anythingnnabout what the word buffalo means in the real worldnn. n the classification first elucidated by homsky, a language that has eact enough rules of grammar that allow you to do this is called anncontet-freennlanguage.nnore importantly, the rules ensure that for everynnpossiblennsentence comprised of the word(s)nnbuffalo{np|n|v}nn, there is one and only one way to construct the data structure illustrated in the tree diagram above. n-ambiguity !nno orth and ead the pecnnitnesses are at their core just a single large object, encoded into a byte array. rom the (anthropomorphic) perspective of a stateless client, that array of bytes might look a bit like a long sentence comprised of very similar looking words. o long as all clients follow the same set of rules, the array of bytes should convert into one and only one hashed data structure, regardless of how the implementation chooses to represent it in memory or on disk.nnhe production rules, written out in section ., are a bit more comple and far less intuitive than the ones we used for our toy eample, but the spirit is very much the same o bennunambiguousnnguidelines for a stateless client (or a developer writing a client) to follow and benncertainnnthey're getting it right.nn've glossed over quite a lot in this eposition, and the rabbit hole of formal languages goes far deeper, to be sure. y aim here was to just provide enough of an introduction and foundation to overcome that first hurdle of understanding. ow that you have cleared that hurdle, it's time pop open wikipedia and tackle the rest yourself!nns always, if you have feedback, questions, or requests for topics, please gichiba or ancock on twitter.