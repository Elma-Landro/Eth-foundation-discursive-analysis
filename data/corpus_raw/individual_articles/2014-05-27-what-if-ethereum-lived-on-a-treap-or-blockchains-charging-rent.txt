Titre: What If Ethereum Lived on a Treap? Or, Blockchains Charging Rent\nAuteur: Vitalik Buterin\nDate: May 27, 2014\nURL: https://blog.ethereum.org/2014/05/27/what-if-ethereum-lived-on-a-treap-or-blockchains-charging-rent\nCatégorie: Non catégorisé\n\n==================================================\n\nlthough truly solving blockchain scalability fundamentally, that is to say figuring out a solution to the problem that every node must process every transaction, is a very hard problem, and all suggested solutions rely on either highly advanced cryptography or intricate multi-blockchain architectures, partial solutions that provide a constant-factor improvement over the way itcoin does things are actually quite easy to find. n thereum, for eample, we have the concept of a separate state tree and transaction history, allowing miners to easily store only eisting account states and not historical transaction outputs that are no longer relevant and thereby drastically reducing the amount of storage that would be required if itcoin is any indication, savings should be around %. nother improvement is the use of accounts instead of coins/ as the fundamental unit, allowing each user to take up less than a hundred bytes on the blockchain regardless of how many transactions go in and out of their account. f course, both of these are partially, or perhaps even fully, offset by the fact that thereum has a much larger scope, intending to use the blockchain for much more than just monetary transactions, but even if that is true it makes scalability all the more necessary. hat  am about to describe in this article is another anti-bloat strategy that could potentially be used to achieve very substantial gains, this time targeting the issue of “dust”.nnust, in simple terms, refers to the accumulation of tiny outputs (or accounts) on the blockchain, perhaps with only a fraction of a cent worth of coin, that are either dumped onto the blockchain maliciously or are simply too low-value to be even worth the increased transaction fee to send. n thereum, dust of the second kind can also consist of accounts that have zero balance left, perhaps because the user might want to switch to a different private key for security reasons. ust is a serious problem it is estimated that the majority of the itcoin blockchain is dust, and in the case of itecoin something like % of the outputs are the result of a single malicious blockchain spam attack that took place back to . n thereum, there is a storage fee on in order to charge for adding something to the state, and thennfloating block limit systemnnensures that even a malicious miner has no significant advantage in this regard, but there is no concept of a fee charged over time hence, there is no protection or incentive against a itecoin-style attack affecting the thereum blockchain as well. ut what if there was one hat if the blockchain could charge rentnnhe basic idea behind charging rent is simple. ach account would keep track of how much space it takes up, including the  nonce, balance, code, state_root ] header  and the storage tree, and then every block the balance would go down by  multiplied by the amount of space taken up (which can be measured in bytes, for simplicity normalizing the total memory load of each storage slot to  bytes). f the balance of an account drops below zero, it would disappear from the blockchain. he hard part is implementation. ctually implementing this scheme is in one way easier and in one way harder than epected. he easy part is that you do not need to actually update every account every block all you do is keep track of the last block during which the account was manipulated and the amount of space taken up by the account in the header  and then read just the account every time computation accesses it. he hard part, however, is deleting accounts with negative balance. ou might think that you can just scan through all accounts from time to time and then remove the ones with negative balances from the database the problem is, however, that such a mechanism doesn’t play nicely with atricia trees. hat if a new user joins the network at block , wants to download the state tree, and there are some deleted accounts ome nodes will have to store the deleted accounts to justify the empty spots, the hashes corresponding to nothing, in the trie. hat if a light client wants a proof of eecution for some particular transaction hen the node supplying the proof will have to include the deleted accounts. ne approach is to have a “cleansing block” every  blocks that scans through the entire state and clears out the cruft. owever, what if there was a more elegant solutionnnreapsnnne elegant data structure in computer science is something called anntreapnn.  treap, as one might or probably might not understand from the name, is a structure which is simultaneously a tree and a heap. o review the relevant data structure theory, annheapnn) is a binary tree, where each node ecept for leaves has one or two children, where each node has a lower value than its children and the lowest-value node is at the top, and what data structure theorists normally call anntreennis a binary tree where values are arranged in sorted order left to right (ie. a node is always greater than its left child and less than its right child, if present).  treap combines the two by having nodes with both a key and a priority the keys are arranged horizontally and the priorities vertically. lthough there can be many heaps for each set of priorities, and many binary trees for each set of values, as it turns out it can be proven that there is always eactly one treap that matches every set of (priority, value)pairs.nnlso, as it turns out, there is an easy (ie. log-time) algorithm for adding and removing a value from the treap, and the mathematical property that there is only one treap for every set of (priority, value) pairs means that treaps are deterministic, and both of these things together make treaps a potential strong candidate for replacing atricia trees as the state tree data structure. ut then, the question is, what would we use for priorities he answer is simple the priority of a node is the epected block number at which the node would disappear. he cleaning process would then simply consist of repeatedly kicking off nodes at the top of the treap, a log-time process that can be done at the end of every block.nnowever, there is one implementation difficulty that makes treaps somewhat challenging for this purpose treaps are not guaranteed to be shallow. or eample, consider the values , ], , ], , ], , ], , ]]. he treap for those would unfortunately look like thisnnow, imagine that an attacker generates ten thousand addresses, and puts them into sorted order. he attacker then creates an account with the first private key, and gives it enough ether to survive until block . he attacker then gives the second private key enough ether to survive until block . he third private key lasts until , and so forth until the last account susrvives until block . ll of these go into the blockchain. ow, the blockchain will have a chain of ten thousand values each of which is below and to the right of all of the previous. ow, the attacker starts sending transactions to the addresses in the second half of the list. ach of those transactions will require ten thousand database accesses to go through the treap to process. asically, a denial of service attack through trie manipulation. an we mitigate this by having the priorities decided according to a more clever semi-randomized algorithm ot really even if priorities were completely random, there is an algorithm using which the attacker would be able to generate a -length subsequence of accounts that have both address and priority in increasing ordernnin a hundred million stepsnn. an we mitigate this by updating the treap bottom-up instead of top-down lso no the fact that these are erkle trees means that we basically have to use functional algorithms to get anywhere.nno what can we do ne approach is to figure out a way to patch this attack. he simplest option would likely involve having a higher cost to purchasing priority the more levels you go down the tree. f the treap is currently  levels deep but your addition would increase it to  levels, the etra level would be a cost that must be paid for. owever, this requires the trie nodes to include a built-in height variable, making the data structure somewhat more complicated and less minimalistic and pure. nother approach is to take the idea behind treaps, and create a data structure that has the same effect using plain old boring atricia trees. his is the solution that is used in databases such as y, and is called “nnindicesnn“. asically, instead of one trie we have two tries. ne trie is a mapping of address to account header, and the other trie is a mapping of time-to-live to address. t the end of every block, the left side of the  trie is scanned, and as long as there are nodes that need to be deleted they are repeatedly removed from both tries. hen a new node is added it is added to both tries, and when a node is updated a naive implementation would update it in both tries if the  is changed as a result of the transaction, but a more sophisticated setup might be made where the second update is only done in a more limited subset of cases for eample, one might create a system where a node needs to “purchase ” in blocks of  days, and this purchase happens automatically every time a node gets onto the chopping block – and if the node is too poor then of course itnndrops off the edgenn.nnonsequencesnno now we have three strategies treaps with heights, tries with time-to-live indices and the “cleansing block”. hich one works best is an empirical question the  approach would arguably be the easiest to graft onto eisting code, but any one of the three could prove most effective assuming the inefficiencies of adding such a system, as well as the usability concerns of having disappearing contracts, are less severe than the gains. hat would the effects of any of these strategies be irst of all, some contracts would need to start charging a micro-fee even passive pieces of code like an elliptic curve signature verifier would need to continually spend funds to justify their eistence, and those funds would have to come from somewhere. f a contract cannot afford to do this, then the contract could just store a hash and the onus would be on the transaction sender to send the contract the code that it is supposed to eecute the contract would then check the hash of the code and if the hash matches the code would be run. ame-registry applications might decide to work somewhat differently, storing most of their registrations using some erkle tree-based offchain mechanism in order to reduce their rent.nnowever, there is also another more subtle consequence account nonce resets. or eample, suppose that  have an account, and  received and sent some transactions from that account. n order to prevent replay attacks (ie. if  send   to ob, ob should not be able to republish the same transaction in order to get another  ), each transaction includes a “nonce” counter that increments after every transaction. hus, the account header stores the current transaction nonce, and if the current nonce is  then the only transaction that will be accepted is one with a nonce of , at which point the nonce will go up to . f accounts disappear, then nonces could reset to , leading to potentially dangerous situations if a user accumulates some funds in an account, then lets the balance drop to zero and the account disappear, and then refills it. ne solution would be for transactions to have a maimum block number, which can be set to  days in the future by defauly, and then require all withdrawals to leave enough balance for the account to last another  days this way, old transactions with nonce  would be too old to replay. owever, this adds another inefficiency, and must be balanced with the benefit of blockchains charging rent.nns another interesting point, the history of the blockchain would become relevant again some dapps, wishing to store some data forever, would store it in a transaction instead of the state, and then use past block headers as an immutable rent-free datastore. he eistence of applications which do this would mean that thereum clients would have to store at least a headers-only version of the history, compromising thereum’s “the present state is all that matters” ideology. owever, an alternative solution might be to have a contract maintaining annerkle mountain rangenn, putting the responsibility onto those users that benefit from particular pieces of information being stored to maintain log-sized erkle tree proofs with the contract remaining under a kilobyte in size.nns a final objection, what if storage space is not the most problematic point of pressure with regard to scalability hat if the main issue is with bandwidth or computation f the problem is computation, then there are some convenient hacks that can be made for eample, the protocol might be epanded to include both transactions and state transition deltas into the block, and nodes would be free to only check a portion of the deltas (say, %) and then quickly gossip about inconsistencies to each other. f it’s bandwidth, then the problem is harder it means that we simply cannot have every node downloading every transaction, so some kind of tree-chains solution is the only way to move forward. n the other hand, if space is the problem, then rent-charging blockchains are very likely the way to go.