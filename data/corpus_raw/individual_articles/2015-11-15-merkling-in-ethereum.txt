Titre: Merkling in Ethereum\nAuteur: Vitalik Buterin\nDate: November 15, 2015\nURL: https://blog.ethereum.org/2015/11/15/merkling-in-ethereum\nCatégorie: Non catégorisé\n\n==================================================\n\nerkle trees are a fundamental part of what makes blockchains tick. lthough it is definitely theoretically possible to make a blockchain without erkle trees, simply by creating giant block headers that directly contain every transaction, doing so poses large scalability challenges that arguably puts the ability to trustlessly use blockchains out of the reach of all but the most powerful computers in the long term. hanks to erkle trees, it is possible to build thereum nodes that run on all computers and laptops large and small, smart phones, and even internet of things devices such as those that will be produced bynnlock.itnn. o how eactly do these erkle trees work, and what value do they provide, both now and in the futurennirst, the basics.  erkle tree, in the most general sense, is a way of hashing a large number of "chunks" of data together which relies on splitting the chunks into buckets, where each bucket contains only a few chunks, then taking the hash of each bucket and repeating the same process, continuing to do so until the total number of hashes remaining becomes only one the root hash.nnhe most common and simple form of erkle tree is the binary ekle tree, where a bucket always consists of two adjacent chunks or hashes it can be depicted as followsnno what is the benefit of this strange kind of hashing algorithm hy not just concatenate all the chunks together into a single big chunk and use a regular hashing algorithm on that he answer is that it allows for a neat mechanism known as erkle proofsnn erkle proof consists of a chunk, the root hash of the tree, and the "branch" consisting of all of the hashes going up along the path from the chunk to the root. omeone reading the proof can verify that the hashing, at least for that branch, is consistent going all the way up the tree, and therefore that the given chunk actually is at that position in the tree. he application is simple suppose that there is a large database, and that the entire contents of the database are stored in a erkle tree where the root of the erkle tree is publicly known and trusted (eg. it was digitally signed by enough trusted parties, or there is a lot of proof of work on it). hen, a user who wants to do a key-value lookup on the database (eg. "tell me the object in position ") can ask for a erkle proof, and upon receiving the proof verify that it is correct, and therefore that the value receivednnactually isnnat position  in the database with that particular root. t allows a mechanism for authenticating annsmallnnamount of data, like a hash, to be etended to also authenticatennlargenndatabases of potentially unbounded size.nnerkle roofs in itcoinnnhe original application of erkle proofs was in itcoin, as described and created by atoshi akamoto in . he itcoin blockchain uses erkle proofs in order to store the transactions in every blocknnhe benefit that this provides is the concept that atoshi described as "simplified payment verification" instead of downloadingnneverynntransaction and every block, a "light client" can only download the chain ofnnblock headersnn, -byte chunks of data for each block that contain only five thingsnn hash of the previous headernn timestampnn mining difficulty valuenn proof of work noncenn root hash for the erkle tree containing the transactions for that block.nnf the light client wants to determine the status of a transaction, it can simply ask for a erkle proof showing that a particular transaction is in one of the erkle trees whose root is in a block header for the main chain.nnhis gets us pretty far, but itcoin-style light clients do have their limitations. ne particular limitation is that, while they can prove the inclusion of transactions, they cannot prove anything about the current state (eg. digital asset holdings, name registrations, the status of financial contracts, etc). ow many bitcoins do you have right now  itcoin light client can use a protocol involving querying multiple nodes and trusting that at least one of them will notify you of any particular transaction spending from your addresses, and this will get you quite far for that use case, but for other more comple applications it isn't nearly enough the precise nature of the effect of a transaction can depend on the effect of several previous transactions, which themselves depend on previous transactions, and so ultimately you would have to authenticate every single transaction in the entire chain. o get around this, thereum takes the erkle tree concept one step further.nnerkle roofs in thereumnnvery block header in thereum contains not just one erkle tree, butnnthreenntrees for three kinds of objectsnnransactionsnneceipts (essentially, pieces of data showing thenneffectnnof each transaction)nntatennhis allows for a highly advanced light client protocol that allows light clients to easily make and get verifiable answers to many kinds of queriesnnas this transaction been included in a particular blocknnell me all instances of an event of type  (eg. a crowdfunding contract reaching its goal) emitted by this address in the past  daysnnhat is the current balance of my accountnnoes this account eistnnretend to run this transaction on this contract. hat would the output bennhe first is handled by the transaction tree the third and fourth are handled by the state tree, and the second by the receipt tree. he first four are fairly straightforward to compute the server simply finds the object, fetches the erkle branch (the list of hashes going up from the object to the tree root) and replies back to the light client with the branch.nnhe fifth is also handled by the state tree, but the way that it is computed is more comple. ere, we need to construct what can be called annerkle state transition proofnn. ssentially, it is a proof which make the claim "if you run transactionnnnnon the state with rootnnnn, the result will be a state with rootnn'nn, with lognnnnand outputnnnn" ("output" eists as a concept in thereum because every transaction is a function call it is not theoretically necessary).nno compute the proof, the server locally creates a fake block, sets the state to , and pretends to be a light client while applying the transaction. hat is, if the process of applying the transaction requires the client to determine the balance of an account, the light client makes a balance query. f the light client needs to check a particular item in the storage of a particular contract, the light client makes a query for that, and so on. he server "responds" to all of its own queries correctly, but keeps track of all the data that it sends back. he server then sends the client the combined data from all of these requests as a proof. he client then undertakes the eact same procedure, butnnusing the provided proof as its databasenn if its result is the same as what the server claims, then the client accepts the proof.nnatricia reesnnt was mentioned above that the simplest kind of erkle tree is the binary erkle tree however, the trees used in thereum are more comple - this is the "erkle atricia tree" that you hear about in our documentation. his article won't go into the detailed specification that is best done bynnthis articlennandnnthis onenn, though  will discuss the basic reasoning.nninary erkle trees are very good data structures for authenticating information that is in a "list" format essentially, a series of chunks one after the other. or transaction trees, they are also good because it does not matter how much time it takes tonneditnna tree once it's created, as the tree is created once and then forever frozen solid.nnor the state tree, however, the situation is more comple. he state in thereum essentially consists of a key-value map, where the keys are addresses and the values are account declarations, listing the balance, nonce, code and storage for each account (where the storage is itself a tree). or eample, the orden testnet genesis state looks as followsnn{
    "" {
        "balance" ""
    },
    "" {
        "balance" ""
    },
    "" {
        "balance" ""
    },
    "" {
        "balance" ""
    },
    "efdfbcdadadfeeceec" {
        "balance" ""
    }
}nnnlike transaction history, however, the state needs to be frequently updated the balance and nonce of accounts is often changed, and what's more, new accounts are frequently inserted, and keys in storage are frequently inserted and deleted. hat is thus desired is a data structure where we can quickly calculate the new tree root after an insert, update edit or delete operation, without recomputing the entire tree. here are also two highly desirable secondary propertiesnnhe depth of the tree is bounded, even given an attacker that is deliberately crafting transactions to make the tree as deep as possible. therwise, an attacker could perform a denial of service attack by manipulating the tree to be so deep that each individual update becomes etremely slow.nnhe root of the tree depends only on the data, not on the order in which updates are made. aking updates in a different order and even recomputing the tree from scratch should not change the root.nnhennatricia treenn, in simple terms, is perhaps the closest that we can come to achieving all of these properties simultaneously. he simplest eplanation for how it works is that the key under which a value is stored is encoded into the "path" that you have to take down the tree. ach node has  children, so the path is determined by he encoding for eample, the keynndognnhe encoded isnn     nn, so you would start with the root, go down the th child, then the fourth, and so forth until you reach the end. n practice, there are a few etra optimizations that we can make to make the process much more efficient when the tree is sparse, but that is the basic principle. he twonnarticlesnnmentionednnabovenndescribe all of the features in much more detail.