Titre: The Question of Mining\nAuteur: Vitalik Buterin\nDate: March 20, 2014\nURL: https://blog.ethereum.org/2014/03/20/the-question-of-mining\nCatégorie: Non catégorisé\n\n==================================================\n\nhere are a lot of interesting changes to the thereum protocol that are in the works, which will hopefully improve the power of the system, add further features such as light-client friendliness and a higher degree of etensibility, and make thereum contracts easier to code. heoretically, none of these changes are necessary the thereum protocol is fine as it stands today, and can theoretically be released as is once the clients are further built up somewhat rather, the changes are there to make thereum better. owever, there is one design objective of thereum where the light at the end of the tunnel is a bit further mining decentralization. lthough we always have the backup option of simply sticking with agger,nnlashernnor , it is entirely unclear that any of those algorithms can truly remain decentralized and mining pool and -resistant in the long term (lasher is guaranteed to be decentralized because it’s proof of stake, but has its own moderately problematic flaws).nnhe basic idea behind the mining algorithm that we want to use is essentially in place however, as in many cases, the devil is in the details.nnhis version of the thereum mining algorithm is a ashcash-based implementation, similar to itcoin’s  and itecoin’s scrypt the idea is for the miner to repeatedly compute a pseudorandom function on a block and a nonce, trying a different nonce each time, until eventually some nonce produces a result which starts with a large number of zeroes. he only room to innovate in this kind of implementation is changing the function in thereum’s case, the rough outline of the function, taking the blockchain state (defined as the header, the current state tree, and all the data of the last  blocks), is as followsnnetnnhi]  sha(sha(block_header) ++ nonce ++ i)nnfornn &lt i &lt nnetnnnnbe the blockchain state  blocks ago.nnetnni]nnbe the transaction count of the blocknninnblocks ago. etnni]nnbe thenn(hi] mod i])nnth transaction from the blocknninnblocks ago.nnpplynn]nn,nn]nn…nn]nnsequentially tonnnn. owever, every time the transaction leads to processing a contract, (pseudo-)randomly make minor modifications to the code of all contracts affected.nnetnn'nnbe the resulting state. etnnrnnbe the sha of the root ofnn'nn.nnfnnr &lt ^ / diffnn, thennnnoncennis a valid nonce.nno summarize in non-programmatic language, the mining algorithm requires the miner to grab a few random transactions from the last  blocks, run the computation of applying them to the state  blocks ago with a few random modifications, and then take the hash of the result. very new nonce that the miner tries, the miner would have to repeat this process over again, with a new set of random transactions and modifications each time.nnhe benefits of this arennt requires the entire blockchain state to mine, essentially requiring every miner to be a full node. his helps with network decentralization, because a larger number of full nodes eist.nnecause every miner is now required to be a full node, mining pools become much less useful. n the itcoin world, mining pools serve two key purposes. irst, pools even out the mining reward instead of every block providing a miner with a .% chance of mining annnn,nnnnbnnlnnonncnnknn,nnannmnninnnnnennrnncnnannnnnmnninnnnnenninnnnntnnonntnnhnnennpnnonnonnlnnannnnndnntnnhnnennpnnonnonnlnngnninnvnnennsnntnnhnnennmnninnnnnennrnnannnn, block, a miner can mine into the pool and the pool gives the miner a % chance of receiving a payout ofnnnn,nnnnbnnlnnocnnknn,nnaminnnercnnanminnnenninnntnnonntnnhnnennpnnoonnlnnannndnntnnhnnennpnnoonnlnngnninnvnnesnntnnhnnennminnnernnannnn.. econd, however, pools also provide centralized block validation. nstead of having to run a full itcoin client themselves, a miner can simply grab block header data from the pool and mine using that data without actually verifying the block for themselves. ith this algorithm, the second argument is moot, and the first concern can be adequately met by peer-to-peer pools that do not give control of a significant portion of network hashpower to a centralized service.nnt's -resistant almost by definition. ecause the  language is uring-complete, any kind of computation that can be done in a normal programming language can be encoded into  code. herefore, an  that can run all of  is by necessity an  for generalized computation – in other words, a . his also has a rimecoin-like social benefit effort spent toward building  s also havs the side benefit of building hardware to make the network faster.nnhe algorithm is relatively computationally quick to verify, although there is no “nice” verification formula that can be run inside  code.nnowever, there are still several major challenges that remain. irst, it is not entirely clear that the system of picking random transactions actually ends up requiring the miner to use the entire blockchain. deally, the blockchain accesses would be random in such a setup, a miner with half the blockchain would succeed only on about  in  nonces. n reality, however, % of all transactions will likely use % of the blockchain in such a system, a node with % of the memory will only take a slowdown penalty of about .nnecond, and more importantly, however, it is difficult to say how much an  miner could be optimized. he algorithm definition above asks the miner to “randomly make minor modifications” to the contract. his part is crucial. he reason is this most transactions have results that are independent of each other the transactions might be of the form “ sends to ”, “ sends to ”, “ sends to contract  that affects  and ”, etc, with no overlap. ence, without random modification there would be little need for an  miner to actually do much computation the computation would happen once, and then the miner would just precompute and store the deltas and apply them immediately. he random modifications mean that the miner has to actually make new  computations each time the algorithm is run. owever, this solution is itself imperfect in two ways. irst of all, random modifications can potentially easily result in what would otherwise be very comple and intricate calculations simply ending early, or at least calulations for which the optimizations are very different from the optimizations applied to standard transactions. econd, mining algorithms may deliberately skip comple contracts in favor of simple or easily optimizable ones. here are heuristic tricks for battling both problems, but it is entirely unclear eactly what those heuristics would be.nnnother interesting point in favor of this kind of mining is that even if optimized hardware miners emerge, the community has the ability to work together to essentially change the mining algorithm by “poisoning” the transaction pool. ngineers can analyze eisting s, determine what their optimizations are, and dump transactions into the blockchain that such optimizations simply do not work with. f % of all transactions are effectively poisoned, then s cannot possibly have a speedup of more than . he nice thing is that there is a reason why people would pay the transaction fees to do this each individual  company has the incentive to poison the well for its competitors.nnhese are all challenges that we will be working on heavily in the net few months.