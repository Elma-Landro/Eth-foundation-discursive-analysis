Titre: The Latest EVM: “Ethereum Is A Trust-Free Closure System”\nAuteur: Vitalik Buterin\nDate: March 20, 2014\nURL: https://blog.ethereum.org/2014/03/20/the-latest-evm-ethereum-is-a-trust-free-closure-system\nCatégorie: Non catégorisé\n\n==================================================\n\nn the past two weeks our lead ++ developer, avin ood, and myself have been spending a lot of time meeting the local thereum community in an rancisco and ilicon alley. e were very ecited to see such a large amount of interest in our project, and the fact that after only two months we have a meetup group that comes together every week, just like the itcoin meetup, with over thirty people attending each time. eople in the community are taking it upon themselves to make educational videos, organize events and eperiment with contracts, and one person is even independently starting to write an implementation of thereum in node.js. t the same time, however, we had the chance to take another look at the thereum protocols, see where things are still imperfect, and agree on a large array of changes that will be integrated, likely with only minimal modification, into the o . clients.nnransactions as losuresnnn  and , the  opcode, which allowed contracts to send transactions triggering other contracts, had one very non-intuitive feature although one would naturally epect  to be like a function call, processing the entire transaction immediately and then continuing on with the rest of the code, in reality  did not work this way. nstead, the eecution of the call is deferred toward the end – when  was called, a new transaction would be pushed to the front of the transaction stack of the block, and when the eecution of the first transaction ends the eecution of the second transaction begins. or eample, this is something that you might epect to worknn  array()
]  "george"
]  nnmkt(,^,,)nnif contract.storage()"george"]  
registration_successful  
else
registration_successful  nn// do more stuff...nnse the namecoin contract to try to register “george”, then use the  opcode to see if the registration is successful. his seems like it should work. owever, of course, it doesn’t.nnn  (no longer ), we fi this problem. e do this by taking an idea from  – creating a concept of reusable code, functions and software libraries, and an idea from  – keeping it simple by keeping code as a sequential set of instructions in the state, and merging the two together into a concept of “message calls”.  message call is an operation eecuted from inside a contract which takes a destination address, an ether value, and some data as input and calls the contract with that ether value and data, but which also, unlike a transaction, returns data as an output. here is thus also a new  opcode which allows contract eecution to return data.nnith this system, contracts can now be much more powerful. ontracts of the traditional sort, performing certain data upon receiving message calls, can still eist. ut now, however, two other design patterns also become possible. irst, one can now create a proprietary data feed contract for eample, loomberg can publish a contract into which they push various asset prices and other market data, and include in its contract an  that returns the internal data as long as the incoming message call sends at least  finney along with it. he fee can’t go too high otherwise contracts that fetch data from the loomberg contract once per block and then provide a cheaper passthrough will be profitable. owever, even with fees equal to the value of perhaps a quarter of a transaction fee, such a data-feeding business may end up being very viable. he  opcode is removed to facilitate this functionality, ie. contracts are now opaque from inside the system, although from the outside one can obviously simply look at the erkle tree.nnecond, it is possible to create contracts that represent functions for eample, one can have a  contract or an  contract to compute those respective functions. here is one problem with this twenty bytes to store the address to call a particular function might be a bit much. owever, this can be solved by creating one “stdlib” contract which contains a few hundred clauses for common functions, and contracts can store the address of this contract once as a variable and then access it many times simply as “” (technically, “  ”). his is the  way of integrating the other major idea from , the concept of standard libraries.nnther and asnnnother important change is this contracts no longer pay for contract eecution, transactions do. hen you send a transaction, you now need to include a  and a maimum number of steps that you’re willing to pay for. t the start of transaction eecution, the  multiplied by the masteps is immediately subtracted from your balance.  new counter is then instantiated, called , that starts off with the number of steps that you have left. hen, transaction eecution starts as before. very step costs  , and eecution continues until either it naturally halts, at which point all remaining gas times the provided  is returned to the sender, or the eecution runs out of  in that case, all eecution is reverted but the entire fee is still paid.nnhis approach has two important benefits. irst, it allows miners to know ahead of time the maimum quantity of  that a transaction will consume. econd, and much more importantly, it allows contract writers to spend much less time focusing on making the contract “defensible” against dummy transactions that try to sabotage the contract by forcing it to pay fees. or eample, consider the old -line amecoinnnif t.value  block.basefee * 
stop
if !contract.storaget.data]] or t.data]  
contract.storaget.data]]  t.data]nnwo lines, no checks. uch simpler. ocus on the logic, not the protocol details. he main weakness of the approach is that it means that, if you send a transaction to a contract, you need to precalculate how long the eecution will take (or at least set a reasonable upper bound you’re willing to pay), and the contract has the power to get into an infinite loop, use up all the gas, and force you to pay your fee with no effect. owever, this is arguably a non-issue when you send a transaction to someone, you are already implicitly trusting them not to throw the money into a ditch (or at least not complain if they do), and it’s up to the contract to be reasonable. ontracts may even choose to include a flag stating how much gas they epect to require ( hereby nominate prepending “   ” to eecution code as a voluntary standard)nnhere is one important etension to this idea, which applies to the concept of message calls when a contract makes a message call, the contract also specifies the amount of gas that the contract on the other end of the call has to use. ust as at the top level, the receiving contract can either finish eecution in time or it can run out of gas, at which point eecution reverts to the start of the call but the gas is still consumed. lternatively, contracts can put a zero in the gas fields in that case, they are trusting the sub-contract with all remaining gas. he main reason why this is necessary is to allow automatic contracts and human-controlled contracts to interact with each other if only the option of calling a contract with all remaining gas was available, then automatic contracts would not be able to use any human-controlled contracts without absolutely trusting their owners. his would make m-of-n data feed applications essentially nonviable. n the other hand, this does introduce the weakness that the eecution engine will need to include the ability to revert to certain previous points (specifically, the start of a message call).nnhe ew erminology uidennith all of the new concepts that we have introduced, we have standardized on a few new terms that we will use hopefully, this will help clear up discussion on the various topics.nnternal ctornn  person or other entity able to interface to an thereum node, but eternal to the world of thereum. t can interact with thereum through depositing signed ransactions and inspecting the block-chain and associated state. as one (or more) intrinsic ccounts.nnddressnn  -bit code used for identifying ccounts.nnccountnn ccounts have an intrinsic balance and transaction count maintained as part of the thereum state. hey are owned either by ternal ctors or intrinsically (as an indentity) an utonomous bject within thereum. f an ccount identifies an utonomous bject, then thereum will also maintain a torage tate particular to that ccount. ach ccount has a single ddress that identifies it.nnransactionnn  piece of data, signed by an ternal ctor. t represents either a essage or a new utonomous bject. ransactions are recorded into each block of the block-chain.nnutonomous bjectnn  virtual object eistant only within the hypothetical state of thereum. as an intrinsic address. ncorporated only as the state of the storage component of the .nntorage tatenn he information particular to a given utonomous bject that is maintained between the times that it runs.nnessagenn ata (as a set of bytes) and alue (specified as ther) that is passed between two ccounts in a perfectly trusted way, either through the deterministic operation of an utonomous bject or the cryptographically secure signature of the ransaction.nnessage allnn he act of passing a message from one ccount to another. f the destination account is an utonomous bject, then the  will be started with the state of said bject and the essage acted upon. f the message sender is an utonomous bject, then the all passes any data returned from the  operation.nnasnn he fundamental network cost unit. aid for eclusively by ther (as of o-.), which is converted freely to and from as as required. as does not eist outside of the internal thereum computation engine its price is set by the ransaction and miners are free to ignore ransactions whose as price is too low.nnong erm iewnnoon, we will release a full formal spec of the above changes, including a new version of the whitepaper that takes into account all of these modifications, as well as a new version of the client that implements it. ater on, further changes to the  will likely be made, but the - will be changed as little as possible thus, it is perfectly safe to write contracts in - now and they will continue to work even if the language changes.nne still do not have a final idea of how we will deal with mandatory fees the current stop-gap approach is now to have a block limit of  operations (ie.  spent) per block. conomically, a mandatory fee and a mandatory block limit are essentially equivalent however, the block limit is somewhat more generic and theoretically allows a limited number of transactions to get in for free. here will be a blog post covering our latest thoughts on the fee issue shortly. he other idea that  had, stack traces, may also be implemented later.nnn the long term, maybe even beyond thereum ., perhaps the holy grail is attack the last two “intrinsic” parts of the system, and see if we can turn them too into contracts ether and . n such a system, ether would still be the privileged currency in the system the current thinking is that we will premine the ether contract into the inde “″ so it takes nineteen fewer bytes to use it. owever, the eecution engine would become simpler since there would no longer be any concept of a currency – instead, it would all be about contracts and message calls. nother interesting benefit is that this would allow ether and  to be decoupled, making ether optionally quantum-proof if you want, you could make an ether account using an  or amport contract instead.  detriment, however, is that proof of stake would not be possible without a currency that is intrinsic at the protocol level that may be a good reason not to go in this direction.