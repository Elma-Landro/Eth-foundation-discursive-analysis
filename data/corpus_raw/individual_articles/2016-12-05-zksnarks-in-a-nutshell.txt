Titre: zkSNARKs in a nutshell\nAuteur: Christian Reitwiessner\nDate: December 5, 2016\nURL: https://blog.ethereum.org/2016/12/05/zksnarks-in-a-nutshell\nCatégorie: Non catégorisé\n\n==================================================\n\nhe possibilities of zks are impressive, you can verify the correctness of computations without having to eecute them and you will not even learn what was eecuted - just that it was done correctly. nfortunately, most eplanations of zks resort to hand-waving at some point and thus they remain something "magical", suggesting that only the most enlightened actually understand how and why (and if) they work. he reality is that zks can be reduced to four simple techniques and this blog post aims to eplain them. nyone who can understand how the  cryptosystem works, should also get a pretty good understanding of currently employed zks. et's see if it will achieve its goal!nnpdf versionnns a very short summary, zks as currently implemented, have  main ingredients (don't worry, we will eplain all the terms in later sections)nn) ncoding as a polynomial problemnnhe program that is to be checked is compiled into a quadratic equation of polynomials t() h()  w() v(), where the equality holds if and only if the program is computed correctly. he prover wants to convince the verifier that this equality holds.nn) uccinctness by random samplingnnhe verifier chooses a secret evaluation point s to reduce the problem from multiplying polynomials and verifying polynomial function equality to simple multiplication and equality check on numbers t(s)h(s)  w(s)v(s)nnhis reduces both the proof size and the verification time tremendously.nn) omomorphic encoding / encryptionnnn encoding/encryption function  is used that has some homomorphic properties (but is not fully homomorphic, something that is not yet practical). his allows the prover to compute (t(s)), (h(s)), (w(s)), (v(s)) without knowing s, she only knows (s) and some other helpful encrypted values.nn) ero nowledgennhe prover permutes the values (t(s)), (h(s)), (w(s)), (v(s)) by multiplying with a number so that the verifier can still check their correctnnstructurennwithout knowing the actual encoded values.nnhe very rough idea is that checking t(s)h(s)  w(s)v(s) is identical to checking t(s)h(s) k  w(s)v(s) k for a random secret number k (which is not zero), with the difference that if you are sent only the numbers (t(s)h(s) k) and (w(s)v(s) k), it is impossible to derive t(s)h(s) or w(s)v(s).nnhis was the hand-waving part so that you can understand the essence of zks, and now we get into the details.nn and ero-nowledge roofsnnet us start with a quick reminder of how  works, leaving out some nit-picky details. emember that we often work with numbers modulo some other number instead of full integers. he notation here is "a + b ≡ c (mod n)", which means "(a + b) % n  c % n". ote that the "(mod n)" part does not apply to the right hand side "c" but actually to the "≡" and all other "≡" in the same equation. his makes it quite hard to read, but  promise to use it sparingly. ow back to nnhe prover comes up with the following numbersnnp, q two random secret primesnnn  p qnnd random number such that   d  n - nne a number such that  d e ≡  (mod (p-)(q-)).nnhe public key is (e, n) and the private key is d. he primes p and q can be discarded but should not be revealed.nnhe message m is encrypted viann(m)  mnnenn% nnnand c  (m) is decrypted viann(c)  cnndnn% n.nnecause of the fact that cnndnn≡ (mnnenn% n)nndnn≡ mnnednn(mod n) and multiplication in the eponent of m behaves like multiplication in the group modulo (p-)(q-), we get mnnednn≡ m (mod n). urthermore, the security of  relies on the assumption that n cannot be factored efficiently and thus d cannot be computed from e (if we knew p and q, this would be easy).nnne of the remarkable feature of  is that it isnnmultiplicatively homomorphicnn. n general, two operations are homomorphic if you can echange their order without affecting the result. n the case of homomorphic encryption, this is the property that you can perform computations on encrypted data.nnully homomorphic encryptionnn, something that eists, but is not practical yet, would allow to evaluate arbitrary programs on encrypted data. ere, for , we are only talking about group multiplication. ore formally () (y) ≡ nnennynnenn≡ (y)nnenn≡ ( y) (mod n), or in words he product of the encryption of two messages is equal to the encryption of the product of the messages.nnhis homomorphicity already allows some kind of zero-knowledge proof of multiplication he prover knows some secret numbers  and y and computes their product, but sends only the encrypted versions a  (), b  (y) and c  ( y) to the verifier. he verifier now checks that (a b) % n ≡ c % n and the only thing the verifier learns is the encrypted version of the product and that the product was correctly computed, but she neither knows the two factors nor the actual product. f you replace the product by addition, this already goes into the direction of a blockchain where the main operation is to add balances.nnnteractive erificationnnaving touched a bit on the zero-knowledge aspect, let us now focus on the other main feature of zks, the succinctness. s you will see later, the succinctness is the much more remarkable part of zks, because the zero-knowledge part will be given "for free" due to a certain encoding that allows for a limited form of homomorphic encoding.nns are short fornnsuccinct non-interactive arguments of knowledgenn. n this general setting of so-called interactive protocols, there is annprovernnand annverifiernnand the prover wants to convince the verifier about a statement (e.g. that f()  y) by echanging messages. he generally desired properties are that no prover can convince the verifier about a wrong statement (nnsoundnessnn) and there is a certain strategy for the prover to convince the verifier about any true statement (nncompletenessnn). he individual parts of the acronym have the following meaningnnuccinct the sizes of the messages are tiny in comparison to the length of the actual computationnnon-interactive there is no or only little interaction. or zks, there is usually a setup phase and after that a single message from the prover to the verifier. urthermore, s often have the so-called "public verifier" property meaning that anyone can verify without interacting anew, which is important for blockchains.nnguments the verifier is only protected against computationally limited provers. rovers with enough computational power can create proofs/arguments about wrong statements (ote that with enough computational power, any public-key encryption can be broken). his is also called "computational soundness", as opposed to "perfect soundness".nnof nowledge it is not possible for the prover to construct a proof/argument without knowing a certain so-callednnwitnessnn(for eample the address she wants to spend from, the preimage of a hash function or the path to a certain erkle-tree node).nnf you add thennzero-knowledgennprefi, you also require the property (roughly speaking) that during the interaction, the verifier learns nothing apart from the validity of the statement. he verifier especially does not learn thennwitness stringnn- we will see later what that is eactly.nns an eample, let us consider the following transaction validation computation f(σnnnn, σnnnn, s, r, v, pnnsnn, pnnrnn, v)   if and only if σnnnnand σnnnnare the root hashes of account erkle-trees (the pre- and the post-state), s and r are sender and receiver accounts and pnnsnn, pnnrnnare erkle-tree proofs that testify that the balance of s is at least v in σnnnnand they hash to σnnnninstead of σnnnnif v is moved from the balance of s to the balance of r.nnt is relatively easy to verify the computation of f if all inputs are known. ecause of that, we can turn f into a zk where only σnnnnand σnnnnare publicly known and (s, r, v, pnnsnn, pnnrnn, v) is the witness string. he zero-knowledge property now causes the verifier to be able to check that the prover knows some witness that turns the root hash from σnnnnto σnnnnin a way that does not violate any requirement on correct transactions, but she has no idea who sent how much money to whom.nnhe formal definition (still leaving out some details) of zero-knowledge is that there is annsimulatornnthat, having also produced the setup string, but does not know the secret witness, can interact with the verifier -- but an outside observer is not able to distinguish this interaction from the interaction with the real prover.nn and ompleity-heoretic eductionsnnn order to see which problems and computations zks can be used for, we have to define some notions from compleity theory. f you do not care about what a "witness" is, what you willnnnotnnknow after "reading" a zero-knowledge proof or why it is fine to have zks only for a specific problem about polynomials, you can skip this section.nn and nnirst, let us restrict ourselves to functions that only output  or  and call such functionsnnproblemsnn. ecause you can query each bit of a longer result individually, this is not a real restriction, but it makes the theory a lot easier. ow we want to measure how "complicated" it is to solve a given problem (compute the function). or a specific machine implementation  of a mathematical function f, we can always count the number of steps it takes to compute f on a specific input  - this is called thennruntimennof  on . hat eactly a "step" is, is not too important in this contet. ince the program usually takes longer for larger inputs, this runtime is always measured in the size or length (in number of bits) of the input. his is where the notion of e.g. an "nnnnnalgorithm"  comes from - it is an algorithm that takes at most nnnnnsteps on inputs of size n. he notions "algorithm" and "program" are largely equivalent here.nnrograms whose runtime is at most nnnknnfor some k are also called "polynomial-time programs".nnwo of the main classes of problems in compleity theory are  and nn is the class of problems  that have polynomial-time programs.nnven though the eponent k can be quite large for some problems,  is considered the class of "feasible" problems and indeed, for non-artificial problems, k is usually not larger than . erifying a bitcoin transaction is a problem in , as is evaluating a polynomial (and restricting the value to  or ). oughly speaking, if you only have to compute some value and not "search" for something, the problem is almost always in . f you have to search for something, you mostly end up in a class called .nnhe lass nnhere are zks for all problems in the class  and actually, the practical zks that eist today can be applied to all problems in  in a generic fashion. t is unknown whether there are zks for any problem outside of .nnll problems in  always have a certain structure, stemming from the definition of nn is the class of problems  that have a polynomial-time program  that can be used to verify a fact given a polynomially-sized so-called witness for that fact. ore formally
()   if and only if there is some polynomially-sized string w (called thennwitness) snnuch that (, w)  nns an eample for a problem in , let us consider the problem of boolean formula satisfiability (). or that, we define a boolean formula using an inductive definitionnnany variable nnnn, nnnn, nnnn,... is a boolean formula (we also use any other character to denote a variablennif f is a boolean formula, then ¬f is a boolean formula (negation)nnif f and g are boolean formulas, then (f ∧ g) and (f ∨ g) are boolean formulas (conjunction / and, disjunction / or).nnhe string "((nnnn∧ nnnn) ∧ ¬nnnn)" would be a boolean formula.nn boolean formula isnnsatisfiablennif there is a way to assign truth values to the variables so that the formula evaluates to true (where ¬true is false, ¬false is true, true ∧ false is false and so on, the regular rules). he satisfiability problem  is the set of all satisfiable boolean formulas.nn(f)   if f is a satisfiable boolean formula and  otherwisennhe eample above, "((nnnn∧ nnnn) ∧ ¬nnnn)", is not satisfiable and thus does not lie in . he witness for a given formula is its satisfying assignment and verifying that a variable assignment is satisfying is a task that can be solved in polynomial time.nn  nnf you restrict the definition of  to witness strings of length zero, you capture the same problems as those in . ecause of that, every problem in  also lies in . ne of the main tasks in compleity theory research is showing that those two classes are actually different - that there is a problem in  that does not lie in . t might seem obvious that this is the case, but if you can prove it formally, you cannnwin $  millionnn. h and just as a side note, if you can prove the converse, that  and  are equal, apart from also winning that amount, there is a big chance that cryptocurrencies will cease to eist from one day to the net. he reason is that it will be much easier to find a solution to a proof of work puzzle, a collision in a hash function or the private key corresponding to an address. hose are all problems in  and since you just proved that   , there must be a polynomial-time program for them. ut this article is not to scare you, most researchers believe that  and  are not equal.nn-ompletenessnnet us get back to . he interesting property of this seemingly simple problem is that it does not only lie in , it is also -complete. he word "complete" here is the same complete as in "uring-complete". t means that it is one of the hardest problems in , but more importantly -- and that is the definition of -complete -- an input to any problem in  can be transformed to an equivalent input for  in the following sensennor any -problem  there is a so-callednnreduction functionnnf, which is computable in polynomial time such thatnn()  (f())nnuch a reduction function can be seen as a compiler t takes source code written in some programming language and transforms in into an equivalent program in another programming language, which typically is a machine language, which has the some semantic behaviour. ince  is -complete, such a reduction eists for any possible problem in , including the problem of checking whether e.g. a bitcoin transaction is valid given an appropriate block hash. here is a reduction function that translates a transaction into a boolean formula, such that the formula is satisfiable if and only if the transaction is valid.nneduction amplennn order to see such a reduction, let us consider the problem of evaluating polynomials. irst, let us define a polynomial (similar to a boolean formula) as an epression consisting of integer constants, variables, addition, subtraction, multiplication and (correctly balanced) parentheses. ow the problem we want to consider isnnolyero(f)   if f is a polynomial which has a zero where its variables are taken from the set {, }nne will now construct a reduction from  to olyero and thus show that olyero is also -complete (checking that it lies in  is left as an eercise).nnt suffices to define the reduction function r on the structural elements of a boolean formula. he idea is that for any boolean formula f, the value r(f) is a polynomial with the same number of variables and f(annnn,..,annknn) is true if and only if r(f)(annnn,..,annknn) is zero, where true corresponds to  and false corresponds to , and r(f) only assumes the value  or  on variables from {, }nnr(nninn)  ( - nninn)nnr(¬f)  ( - r(f))nnr((f ∧ g))  ( - ( - r(f))( - r(g)))nnr((f ∨ g))  r(f)r(g)nnne might have assumed that r((f ∧ g)) would be defined as r(f) + r(g), but that will take the value of the polynomial out of the {, } set.nnsing r, the formula (( ∧ y) ∨¬) is translated to ( - ( - ( - ))( - ( - y))( - ( - )),nnote that each of the replacement rules for r satisfies the goal stated above and thus r correctly performs the reductionnn(f)  olyero(r(f)) or f is satisfiable if and only if r(f) has a zero in {, }nnitness reservationnnrom this eample, you can see that the reduction function only defines how to translate the input, but when you look at it more closely (or read the proof that it performs a valid reduction), you also see a way to transform a valid witness together with the input. n our eample, we only defined how to translate the formula to a polynomial, but with the proof we eplained how to transform the witness, the satisfying assignment. his simultaneous transformation of the witness is not required for a transaction, but it is usually also done. his is quite important for zks, because the the only task for the prover is to convince the verifier that such a witness eists, without revealing information about the witness.nnuadratic pan rogramsnnn the previous section, we saw how computational problems inside  can be reduced to each other and especially that there are -complete problems that are basically only reformulations of all other problems in  - including transaction validation problems. his makes it easy for us to find a generic zk for all problems in  e just choose a suitable -complete problem. o if we want to show how to validate transactions with zks, it is sufficient to show how to do it for a certain problem that is -complete and perhaps much easier to work with theoretically.nnhis and the following section is based on the papernnnn(the linked technical report has much more information than the journal paper), where the authors found that the problem called uadratic pan rograms () is particularly well suited for zks.  uadratic pan rogram consists of a set of polynomials and the task is to find a linear combination of those that is a multiple of another given polynomial. urthermore, the individual bits of the input string restrict the polynomials you are allowed to use. n detail (the general s are a bit more relaed, but we already define thennstrongnnversion because that will be used later)nn  over a field  for inputs of length n consists ofnna set of polynomials vnnnn,...,vnnmnn, wnnnn,...,wnnmnnover this field ,nna polynomial t over  (the target polynomial),nnan injective function f {(i, j) |  ≤ i ≤ n, j ∈ {, }} → {, ..., m}nnhe task here is roughly, to multiply the polynomials by factors and add them so that the sum (which is called annlinear combinationnn) is a multiple of t. or each binary input string u, the function f restricts the polynomials that can be used, or more specific, their factors in the linear combinations. or formallynnn input u isnnacceptednn(verified) by the  if and only if there are tuples a  (annnn,...,annmnn), b  (bnnnn,...,bnnmnn) from the field  such thatnnannknn,bnnknn  if k  f(i, ui]) for some i, (ui] is the ith bit of u)nnannknn,bnnknn  if k  f(i,  - ui]) for some i andnnthe target polynomial t divides vnnannwnnbnnwhere vnnann vnnnn+ annnnvnnnn+ ... + annmnnvnnmnn, wnnbnn wnnnn+ bnnnnwnnnn+ ... + bnnmnnwnnmnn.nnote that there is still some freedom in choosing the tuples a and b if n is smaller than m. his means  only makes sense for inputs up to a certain size - this problem is removed by using non-uniform compleity, a topic we will not dive into now, let us just note that it works well for cryptography where inputs are generally small.nns an analogy to satisfiability of boolean formulas, you can see the factors annnn,...,annmnn, bnnnn,...,bnnmnnas the assignments to the variables, or in general, the  witness. o see that  lies in , note that all the verifier has to do (once she knows the factors) is checking that the polynomial t divides vnnannwnnbnn, which is a polynomial-time problem.nne will not talk about the reduction from generic computations or circuits to  here, as it does not contribute to the understanding of the general concept, so you have to believe me that  is -complete (or rather complete for some non-uniform analogue like /poly). n practice, the reduction is the actual "engineering" part - it has to be done in a clever way such that the resulting  will be as small as possible and also has some other nice features.nnne thing about s that we can already see is how to verify them much more efficiently he verification task consists of checking whether one polynomial divides another polynomial. his can be facilitated by the prover in providing another polynomial h such that t h  vnnannwnnbnnwhich turns the task into checking a polynomial identity or put differently, into checking that t h - vnnannwnnbnn , i.e. checking that a certain polynomial is the zero polynomial. his looks rather easy, but the polynomials we will use later are quite large (the degree is roughly  times the number of gates in the original circuit) so that multiplying two polynomials is not an easy task.nno instead of actually computing vnnann, wnnbnnand their product, the verifier chooses a secret random point s (this point is part of the "toic waste" of zash), computes the numbers t(s), vnnknn(s) and wnnknn(s) for all k and from them,  vnnann(s) and wnnbnn(s) and only checks that t(s) h(s)  vnnann(s) wnnbnn(s). o a bunch of polynomial additions, multiplications with a scalar and a polynomial product is simplified to field multiplications and additions.nnhecking a polynomial identity only at a single point instead of at all points of course reduces the security, but the only way the prover can cheat in case t h - vnnannwnnbnnis not the zero polynomial is if she manages to hit a zero of that polynomial, but since she does not know s and the number of zeros is tiny (the degree of the polynomials) when compared to the possibilities for s (the number of field elements), this is very safe in practice.nnhe zk in etailnne now describe the zk for  in detail. t starts with a setup phase that has to be performed for every single . n zash, the circuit (the transaction verifier) is fied, and thus the polynomials for the  are fied which allows the setup to be performed only once and re-used for all transactions, which only vary the input u. or the setup, which generates thenncommon reference stringnn(), the verifier chooses a random and secret field element s and encrypts the values of the polynomials at that point. he verifier uses some specific encryption  and publishes (vnnknn(s)) and (wnnknn(s)) in the . he  also contains several other values which makes the verification more efficient and also adds the zero-knowledge property. he encryption  used there has a certain homomorphic property, which allows the prover to compute (v(s)) without actually knowing vnnknn(s).nnow to valuate a olynomial uccinctly and with ero-nowledgennet us first look at a simpler case, namely just the encrypted evaluation of a polynomial at a secret point, and not the full  problem.nnor this, we fi a group (an elliptic curve is usually chosen here) and a generator g. emember that a group element is callednngeneratornnif there is a number n (the group order) such that the list gnnnn, gnnnn, gnnnn, ..., gnnn-nncontains all elements in the group. he encryption is simply ()  gnnnn. ow the verifier chooses a secret field element s and publishes (as part of the )nn(snnnn), (snnnn), ..., (snndnn) - d is the maimum degree of all polynomialsnnfter that, s can be (and has to be) forgotten. his is eactly what zash calls toic waste, because if someone can recover this and the other secret values chosen later, they can arbitrarily spoof proofs by finding zeros in the polynomials.nnsing these values, the prover can compute (f(s)) for arbitrary polynomials f without knowing s ssume our polynomial is f()  nnnn+  +  and we want to compute (f(s)), then we get (f(s))  (snnnn+ s + )  gnns^ + s + nn (snnnn)nnnn(snnnn)nnnn(snnnn)nnnn, which can be computed from the published  without knowing s.nnhe only problem here is that, because s was destroyed, the verifier cannot check that the prover evaluated the polynomial correctly. or that, we also choose another secret field element, α, and publish the following "shifted" valuesnn(αsnnnn), (αsnnnn), ..., (αsnndnn)nns with s, the value α is also destroyed after the setup phase and neither known to the prover nor the verifier. sing these encrypted values, the prover can similarly compute (α f(s)), in our eample this is (αsnnnn+ αs + α)  (αsnnnn)nnnn(αsnnnn)nnnn(αsnnnn)nnnn. o the prover publishes   (f(s)) and   (α f(s))) and the verifier has to check that these values match. he does this by using another main ingredient  so-callednnpairing functionnne. he elliptic curve and the pairing function have to be chosen together, so that the following property holds for all , ynne(gnnnn, gnnynn)  e(g, g)nnynnsing this pairing function, the verifier checks that e(, gnnαnn)  e(, g) -- note that gnnαnnis known to the verifier because it is part of the  as (αsnnnn). n order to see that this check is valid if the prover does not cheat, let us look at the following equalitiesnne(, gnnαnn)  e(gnnf(s)nn, gnnαnn)  e(g, g)nnα f(s)nne(, g)  e(gnnα f(s)nn, g)  e(g, g)nnα f(s)nnhe more important part, though, is the question whether the prover can somehow come up with values ,  that fulfill the check e(, gnnαnn)  e(, g) but are not (f(s)) and (α f(s))), respectively. he answer to this question is "we hope not". eriously, this is called the "d-power knowledge of eponent assumption" and it is unknown whether a cheating prover can do such a thing or not. his assumption is an etension of similar assumptions that are made for proving the security of other public-key encryption schemes and which are similarly unknown to be true or not.nnctually, the above protocol does not really allow the verifier to check that the prover evaluated the polynomial f()  nnnn+  + , the verifier can only check that the prover evaluatednnsomennpolynomial at the point s. he zk for  will contain another value that allows the verifier to check that the prover did indeed evaluate the correct polynomial.nnhat this eample does show is that the verifier does not need to evaluate the full polynomial to confirm this, it suffices to evaluate the pairing function. n the net step, we will add the zero-knowledge part so that the verifier cannot reconstruct anything about f(s), not even (f(s)) - the encrypted value.nnor that, the prover picks a random δ and instead of   (f(s)) and   (α f(s))), she sends over '  (δ + f(s)) and   (α (δ + f(s)))). f we assume that the encryption cannot be broken, the zero-knowledge property is quite obvious. e now have to check two things . the prover can actually compute these values and . the check by the verifier is still true.nnor ., note that '  (δ + f(s))  gnnδ + f(s)nn gnnδnngnnf(s)nn (δ) (f(s))  (δ)  and similarly, '  (α (δ + f(s))))  (α δ + α f(s)))  gnnα δ + α f(s)nn gnnα δnngnnα f(s)nn (α)nnδnn(α f(s))  (α)nnδnn.nnor ., note that the only thing the verifier checks is that the values  and  she receives satisfy the equation   (a) und   (α a) for some value a, which is obviously the case for a  δ + f(s) as it is the case for a  f(s).nnk, so we now know a bit about how the prover can compute the encrypted value of a polynomial at an encrypted secret point without the verifier learning anything about that value. et us now apply that to the  problem.nn  for the  roblemnnemember that in the  we are given polynomials vnnnn,...,vnnmnn, wnnnn,...,wnnm,nna target polynomial t (of degree at most d) and a binary input string u. he prover finds annnn,...,annm,nnbnnnn,...,bnnmnn(that are somewhat restricted depending on u) and a polynomial h such thatnnt h  (vnnnn+ annnnvnnnn+ ... + annmnnvnnmnn) (wnnnn+ bnnnnwnnnn+ ... + bnnmnnwnnmnn).nnn the previous section, we already eplained how the common reference string () is set up. e choose secret numbers s and α and publishnn(snnnn), (snnnn), ..., (snndnn) and (αsnnnn), (αsnnnn), ..., (αsnndnn)nnecause we do not have a single polynomial, but sets of polynomials that are fied for the problem, we also publish the evaluated polynomials right awaynn(t(s)), (α t(s)),nn(vnnnn(s)), ..., (vnnmnn(s)), (α vnnnn(s)), ..., (α vnnmnn(s)),nn(wnnnn(s)), ..., (wnnmnn(s)), (α wnnnn(s)), ..., (α wnnmnn(s)),nnand we need further secret numbers βnnvnn, βnnwnn, γ (they will be used to verify that those polynomials were evaluated and not some arbitrary polynomials) and publishnn(γ), (βnnvnnγ), (βnnwnnγ),nn(βnnvnnvnnnn(s)), ..., (βnnvnnvnnmnn(s))nn(βnnwnnwnnnn(s)), ..., (βnnwnnwnnmnn(s))nn(βnnvnnt(s)), (βnnwnnt(s))nnhis is the full common reference string. n practical implementations, some elements of the  are not needed, but that would complicated the presentation.nnow what does the prover do he uses the reduction eplained above to find the polynomial h and the values annnn,...,annm,nnbnnnn,...,bnnmnn. ere it is important to use a witness-preserving reduction (see above) because only then, the values annnn,...,annm,nnbnnnn,...,bnnmnncan be computed together with the reduction and would be very hard to find otherwise. n order to describe what the prover sends to the verifier as proof, we have to go back to the definition of the .nnhere was an injective function f {(i, j) |  ≤ i ≤ n, j ∈ {, }} → {, ..., m} which restricts the values of annnn,...,annm,nnbnnnn,...,bnnmnn. ince m is relatively large, there are numbers which do not appear in the output of f for any input. hese indices are not restricted, so let us call them nnfreennand define vnnfreenn()  Σnnknnannknnvnnknn() where the k ranges over all indices in nnfreenn. or w()  bnnnnwnnnn() + ... + bnnmnnwnnmnn(), the proof now consists ofnnnnfreenn (vnnfreenn(s)),     (w(s)),     (h(s)),nn'nnfreenn (α vnnfreenn(s)),   '  (α w(s)),   '  (α h(s)),nn  (βnnvnnvnnfreenn(s) + βnnwnnw(s)))nnwhere the last part is used to check that the correct polynomials were used (this is the part we did not cover yet in the other eample). ote that all these encrypted values can be generated by the prover knowing only the .nnhe task of the verifier is now the followingnnince the values of annknn, where k is not a "free" inde can be computed directly from the input u (which is also known to the verifier, this is what is to be verified), the verifier can compute the missing part of the full sum for vnn(vnninnn(s))  (Σnnknnannknnvnnknn(s)) where the k ranges over all indicesnnnotnnin nnfreenn.nnith that, the verifier now confirms the following equalities using the pairing function e (don't be scared)nne('nnfreenn, g)  e(nnfreenn, gnnαnn),     e(', ())  e(, (α)),     e(', ())  e(, (α))nne((γ), )  e((βnnvnnγ), nnfreenn) e((βnnwnnγ), )nne((vnnnn(s)) (vnninnn(s)) nnfreenn,   (wnnnn(s)) )  e(,   (t(s)))nno grasp the general concept here, you have to understand that the pairing function allows us to do some limited computation on encrypted values e can do arbitrary additions but just a single multiplication. he addition comes from the fact that the encryption itself is already additively homomorphic and the single multiplication is realized by the two arguments the pairing function has. o e(', ())  e(, (α)) basically multiplies ' by  in the encrypted space and compares that to  multiplied by α in the encrypted space. f you look up the value  and ' are supposed to have - (w(s)) and (α w(s)) - this checks out if the prover supplied a correct proof.nnf you remember from the section about evaluating polynomials at secret points, these three first checks basically verify that the prover did evaluate some polynomial built up from the parts in the . he second item is used to verify that the prover used the correct polynomials v and w and not just some arbitrary ones. he idea behind is that the prover has no way to compute the encrypted combination (βnnvnnvnnfreenn(s) + βnnwnnw(s))) by some other way than from the eact values of (vnnfreenn(s)) and (w(s)). he reason is that the values βnnvnnare not part of the  in isolation, but only in combination with the values vnnknn(s) and βnnwnnis only known in combination with the polynomials wnnknn(s). he only way to "mi" them is via the equally encrypted γ.nnssuming the prover provided a correct proof, let us check that the equality works out. he left and right hand sides are, respectivelynne((γ), )  e((γ), (βnnvnnvnnfreenn(s) + βnnwnnw(s)))  e(g, g)nnγ(βnnvnnvnnfreenn(s) + βnnwnnw(s))nne((βnnvnnγ), nnfreenn) e((βnnwnnγ), )  e((βnnvnnγ), (vnnfreenn(s))) e((βnnwnnγ), (w(s)))  e(g, g)nn(βnnvnnγ) vnnfreenn(s)nne(g, g)nn(βnnwnnγ) w(s)nn e(g, g)nnγ(βnnvnnvnnfreenn(s) + βnnwnnw(s))nnhe third item essentially checks that (vnnnn(s) + annnnvnnnn(s) + ... + annmnnvnnmnn(s)) (wnnnn(s) + bnnnnwnnnn(s) + ... + bnnmnnwnnmnn(s))  h(s) t(s), the main condition for the  problem. ote that multiplication on the encrypted values translates to addition on the unencrypted values because () (y)  gnnnngnnynn gnn+ynn ( + y).nndding ero-nowledgenns  said in the beginning, the remarkable feature about zk is rather the succinctness than the zero-knowledge part. e will see now how to add zero-knowledge and the net section will be touch a bit more on the succinctness.nnhe idea is that the prover "shifts" some values by a random secret amount and balances the shift on the other side of the equation. he prover chooses random δnnfreenn, δnnwnnand performs the following replacements in the proofnnvnnfreenn(s) is replaced by vnnfreenn(s) + δnnfreennt(s)nnw(s) is replaced by w(s) + δnnwnnt(s).nny these replacements, the values nnfreennand , which contain an encoding of the witness factors, basically become indistinguishable form randomness and thus it is impossible to etract the witness. ost of the equality checks are "immune" to the modifications, the only value we still have to correct is  or h(s). e have to ensure thatnn(vnnnn(s) + annnnvnnnn(s) + ... + annmnnvnnmnn(s)) (wnnnn(s) + bnnnnwnnnn(s) + ... + bnnmnnwnnmnn(s))  h(s) t(s), or in other wordsnn(vnnnn(s) + vnninnn(s) + vnnfreenn(s)) (wnnnn(s) + w(s))  h(s) t(s)nnstill holds. ith the modifications, we getnn(vnnnn(s) + vnninnn(s) + vnnfreenn(s) + δnnfreennt(s)) (wnnnn(s) + w(s) + δnnwnnt(s))nnand by epanding the product, we see that replacing h(s) bynnh(s) + δnnfreenn(wnnnn(s) + w(s)) + δnnwnn(vnnnn(s) + vnninnn(s) + vnnfreenn(s)) + (δnnfreennδnnwnn) t(s)nnwill do the trick.nnradeoff between nput and itness izenns you have seen in the preceding sections, the proof consists only of  elements of a group (typically an elliptic curve). urthermore, the work the verifier has to do is checking some equalities involving pairing functions and computing (vnninnn(s)), a task that is linear in the input size. emarkably, neither the size of the witness string nor the computational effort required to verify the  (without s) play any role in verification. his means that -verifying etremely comple problems and very simple problems all take the same effort. he main reason for that is because we only check the polynomial identity for a single point, and not the full polynomial. olynomials can get more and more comple, but a point is always a point. he only parameters that influence the verification effort is the level of security (i.e. the size of the group) and the maimum size for the inputs.nnt is possible to reduce the second parameter, the input size, by shifting some of it into the witnessnnnstead of verifying the function f(u, w), where u is the input and w is the witness, we take a hash function h and verifynnf'(, (u, w))  f(u, w) ∧ h(u)  .nnhis means we replace the input u by a hash of the input h(u) (which is supposed to be much shorter) and verify that there is some value  that hashes to (u) (and thus is very likely equal to u) in addition to checking f(, w). his basically moves the original input u into the witness string and thus increases the witness size but decreases the input size to a constant.nnhis is remarkable, because it allows us to verify arbitrarily comple statements in constant time.nnow is this elevant to thereumnnince verifying arbitrary computations is at the core of the thereum blockchain, zks are of course very relevant to thereum. ith zks, it becomes possible to not only perform secret arbitrary computations that are verifiable by anyone, but also to do this efficiently.nnlthough thereum uses a uring-complete virtual machine, it is currently not yet possible to implement a zk verifier in thereum. he verifier tasks might seem simple conceptually, but a pairing function is actually very hard to compute and thus it would use more gas than is currently available in a single block. lliptic curve multiplication is already relatively comple and pairings take that to another level.nnisting zk systems like zash use the same problem / circuit / computation for every task. n the case of zash, it is the transaction verifier. n thereum, zks would not be limited to a single computational problem, but instead, everyone could set up a zk system for their specialized computational problem without having to launch a new blockchain. very new zk system that is added to thereum requires a new secret trusted setup phase (some parts can be re-used, but not all), i.e. a new  has to be generated. t is also possible to do things like adding a zk system for a "generic virtual machine". his would not require a new setup for a new use-case in much the same way as you do not need to bootstrap a new blockchain for a new smart contract on thereum.nnetting zks to thereumnnhere are multiple ways to enable zks for thereum. ll of them reduce the actual costs for the pairing functions and elliptic curve operations (the other required operations are already cheap enough) and thus allows also the gas costs to be reduced for these operations.nnimprove the (guaranteed) performance of the nnimprove the performance of the  only for certain pairing functions and elliptic curve multiplicationsnnhe first option is of course the one that pays off better in the long run, but is harder to achieve. e are currently working on adding features and restrictions to the  which would allow better just-in-time compilation and also interpretation without too many required changes in the eisting implementations. he other possibility is to swap out the  completely and use something like e.nnhe second option can be realized by forcing all thereum clients to implement a certain pairing function and multiplication on a certain elliptic curve as a so-called precompiled contract. he benefit is that this is probably much easier and faster to achieve. n the other hand, the drawback is that we are fied on a certain pairing function and a certain elliptic curve. ny new client for thereum would have to re-implement these precompiled contracts. urthermore, if there are advancements and someone finds better zks, better pairing functions or better elliptic curves, or if a flaw is found in the elliptic curve, pairing function or zk, we would have to add new precompiled contracts.