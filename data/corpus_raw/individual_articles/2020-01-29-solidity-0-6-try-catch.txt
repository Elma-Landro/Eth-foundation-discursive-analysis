Titre: Solidity 0.6.x features: try/catch statement\nAuteur: Elena Gesheva\nDate: January 29, 2020\nURL: https://blog.ethereum.org/2020/01/29/solidity-0-6-try-catch\nCatégorie: Non catégorisé\n\n==================================================\n\nhenntry/catch synta introduced in ..nnis arguably the biggest leap in error handling capabilities in olidity, since reason strings fornnrevertnnandnnrequirennwere released in v... othnntrynnandnncatchnnhave been reserved keywordsnnsince v..nnand now we can use them to handle failures innneternalnnfunction calls without rolling back the complete transaction (state changes in the called function are still rolled back, but the ones in the calling function are not).nne are moving one step away from the purist "all-or-nothing" approach in a transaction lifecycle, which falls short of practical behaviour we often want.nnandling eternal call failuresnnhe try/catch statement allows you to react on failednneternalnncalls andnncontract creationnncalls, so you cannot use it fornninternalnnfunction calls. ote that to wrap a public function call within the same contract with try/catch, it can be made eternal by calling the function withnnthis.nn.nnhe eample below demonstrates how try/catch is used in a factory pattern where contract creation might fail. he followingnnharityplitternncontract requires a mandatory address propertynn_ownernnin its constructor.nnpragma solidity ^..nnnncontract harityplitternn{nnaddress public ownernnnnconstructornn(nnaddress _ownernn)nnpublicnn{nnrequirenn(nn_ownernn!nnaddressnn(nnnn)nn,nn"no-owner-provided"nn)nnnnownernnnn_ownernnnn}nn}nnhere is a factory contract —nnharityplitteractorynnwhich is used to create and manage instances ofnnharityplitternn. n the factory we can wrap thennnew harityplitter(charitywner)nnin a try/catch as a failsafe for when that constructor might fail because of an emptynncharitywnernnbeing passed.nnpragma solidity ^..nnnnimportnn"./harityplitter.sol"nnnncontract harityplitteractorynn{nnmappingnn(nnaddressnnnnnnharityplitternn)nnpublic charityplittersnnnnuint public errorountnnnnevent rrorandlednn(nnstring reasonnn)nnnnevent rrorotandlednn(nnbytes reasonnn)nnnnfunctionnncreateharityplitternn(nnaddress charitywnernn)nnpublicnn{nntry new harityplitternn(nncharitywnernn)nnreturnsnn(nnharityplitter newharityplitternn)nn{nncharityplittersnnnnmsg.sendernn]nnnnnewharityplitternnnn}nncatchnn{nnerrorount++nnnn}nn}nn}nnote that with try/catch, only eceptions happening inside the eternal call itself are caught. rrors inside the epression are not caught, for eample if the input parameter for thennnew harityplitternnis itself part of an internal call, any errors it raises will not be caught. ample demonstrating this behaviour is the modifiednncreateharityplitternnfunction. ere thennharityplitternnconstructor input parameter is retrieved dynamically from another function —nngetharitywnernn. f that function reverts, in this eample withnn"revert-required-for-testing"nn, that will not be caught in the try/catch statement.nnfunctionnncreateharityplitternn(nnaddress _charitywnernn)nnpublicnn{nntry new harityplitternn(nngetharitywnernn(nn_charitywner,nnfalsenn))nnreturnsnn(nnharityplitter newharityplitternn)nn{nncharityplittersnnnnmsg.sendernn]nnnnnewharityplitternnnn}nncatchnn(nnbytes memory reasonnn)nn{nn..nn.nn}nn}nnfunctionnngetharitywnernn(nnaddress _charitywner, bool _toassnn)nninternal returnsnn(nnaddressnn)nn{nnrequirenn(nn_toass,nn"revert-required-for-testing"nn)nnnnreturnnn_charitywnernnnn}nnetrieving the error messagenne can further etend the try/catch logic in thenncreateharityplitternnfunction to retrieve the error message if one was emitted by a failingnnrevertnnornnrequirennand emit it in an event. here are two ways to achieve thisnn. singnncatch rror(string memory reason)nnfunctionnncreateharityplitternn(nnaddress _charitywnernn)nnpublicnn{nntry new harityplitternn(nn_charitywnernn)nnreturnsnn(nnharityplitter newharityplitternn)nn{nncharityplittersnnnnmsg.sendernn]nnnnnewharityplitternnnn}nncatch rrornn(nnstring memory reasonnn)nn{nnerrorount++nnnnharityplitter newharityplitternnnnnewnnharityplitternn(nnmsg.sendernn)nnnncharityplittersnnnnmsg.sendernn]nnnnnewharityplitternnnn// mitting the errornninnneventnnemit rrorandlednn(nnreasonnn)nnnn}nncatchnn{nnerrorount++nnnn}nn}nnhich emits the following event on a failed constructor require errornnharityplitteractory.rrorandlednn(nnreasonnn'no-owner-provided'nn(nntype stringnn)nn)nn. singnncatch (bytes memory reason)nnfunctionnncreateharityplitternn(nnaddress charitywnernn)nnpublicnn{nntry new harityplitternn(nncharitywnernn)nnreturnsnn(nnharityplitter newharityplitternn)nn{nncharityplittersnnnnmsg.sendernn]nnnnnewharityplitternnnn}nncatchnn(nnbytes memory reasonnn)nn{nnerrorount++nnnnemit rrorotandlednn(nnreasonnn)nnnn}nn}nnhich emits the following event on a failed constructor require errornnharityplitteractory.rrorotandlednn(nnreason henn'caefdfedf'nn(nntype bytesnn)nnhe above two methods for retrieving the error string produce a similar result. he difference is that the second method does not -decode the error string. he advantage of the second method is that it is also eecuted if  decoding the error string fails or if no reason was provided.nnuture plansnnhere are plans to release support for error types meaning we will be able to declare errors in a similar way to events allowing us to catch different type of errors, for eamplenncatch ustomrrornn(nnuint datann)nn{nn…nn}nncatch ustomrrornn(nnuintnnnn]nnmemory datann)nn{nn…nn}nncatchnn{nn}