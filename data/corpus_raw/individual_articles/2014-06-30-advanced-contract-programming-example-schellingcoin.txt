Titre: Advanced Contract Programming Example: SchellingCoin\nAuteur: Vitalik Buterin\nDate: June 30, 2014\nURL: https://blog.ethereum.org/2014/06/30/advanced-contract-programming-example-schellingcoin\nCatégorie: Non catégorisé\n\n==================================================\n\nriting effective decentralized applications in thereum is at the same time easy and hard. he easy part we all know rather than needing to create your own blockchain, manage complicated database code, deal with networking and  traversal, or any of the other compleities involving writing a peer-to-peer app from scratch, you can write code in a simple, high-level programming language like erpent or utan (or  if you prefer mucking around a bit lower-level), with the simplicity of a toy scripting language but the power and security of a full blockchain backing it up. n entire implementation of a basic name registry can be done in two lines of code that encompass the essential logic of the programnnif not contract.storagemsg.data]] contract.storagemsg.data]]  msg.data]nn. se the zeroth data item in the message as a key and the first as a value if the key is not yet taken then set the key to the desired value.  phone book that you can add entries to, but where entries, once made, cannot be changed. owever, there is also a hard part decentralized applications are likely to involve logic that is fundamentally comple, and there is no way that any simplifications to the programming environment can ever remove that fact (however, libraries built on top of the programming language might alleviate specific issues). urthermore, any dapps doing anything truly interesting is likely to involve cryptographic protocols and economics, and we all know how comple those are.nnhe purpose of this article will be to go through a contract that is an important component of a fully decentralized cryptoeconomic ecosystem a decentralized oracle. he oracle will be implemented using the chellingoin protocol, describednnin a previous blog postnn. he core idea behind the protocol is that everyone "votes" on a particular value (in this case, we'll use wei per  cent as an eample, as that will end up very useful in financial contracts), and everyone who submitted a vote that is between the th and  percentile (ie. close to median) receives a reward. he median is taken to be the "true value". n order to increase security, each round is done via a two-step commitment protocol in the first phase, everyone selects a valuennnnwhich is the value they will be voting for, and submitsnn  sha(msg.sender, ])nnto the contract, and in the second phase everyone submits thennnnthat they selected and the contract accepts only those values that match the previously provided hash. ewarding and evaluation is then done at the end.nnhe reason why it works is this. uring the first phase, everyone is so to speak "in the dark" they do not know what the others will be submitting, seeing perhaps only hashes of other votes. he only information they have is that they are supposed to be submitting the price of a  cent in wei. hus, knowing only that the only value that other people's answers are going to be biased towards is the actual wei/cent, the rational choice to vote for in order to maimize one's chance of being near-median is the wei/cent itself. ence, it's in everyone's best interests to come together and all provide their best estimate of the wei/cent price. n interesting philosophical point is that this is also the same way that proof-of-work blockchains work, ecept that in that case what you are voting on is the time order of transactions instead of some particular numeric value this moderately strongly suggests that this protocol is likely to be viable at least for some applications.nnf course, in reality various kinds of special scenarios and attacks are possible, and the fact that the price of any asset is quite often controlled by a small number of centralized echanges makes things more difficult. or eample, one imaginable failure mode is that if there is a market share split between the / on itstamp, itfine and to, and to is the most popular echange, then the incentives might drive all the votes to aggregate around the -/ price specifically, and at that point it is entirely unclear what would happen when to gets hacked and the price on that echange alone, and not the others, falls to $. veryone may well end up following their individual incentives and sticking to each other to the protocol's collective doom. ow to deal with these situations and whether or not they are even significant is an entirely empirical issue it is hard to say what the real world will do beforehand.nnormalizing the protocol, we have the followingnnvery set of  blocks (here, we set   ) constitutes a separate "epoch". e define the epoch number asnnfloor(block.number / )nn, and we define the block number modulo  to be the "residual".nnf the residual is less than , then anyone can submit a transaction with any value  and hashnn  sha(msg.sender, , ])nn, wherennnnis their estimate of the price of   cent in wei (remember,  wei  nn-nnether, and  cent  nn-nn) andnnnnis a random number.nnf the residual is greater than , then anyone who submitted a hash can submitnnnn, and the contract will check ifnnsha(msg.sender, ])nnmatches the hash.nnt the end of the epoch (or, more precisely, at the point of the first "ping" during the net epoch), everyone who submitted a value fornnnnbetween the th and th percentile, weighted by deposit, gets their deposit back plus a small reward, everyone else gets their deposit minus a small penalty, and the median value is taken to be the true cent/wei price. veryone who failed to submit a valid value fornnnngets their deposit back minus a small penalty.nnote that there are possible optimizations to the protocol for eample, one might introduce a feature that allows anyone with a particularnnnnvalue to steal the deposit from whoever submitted the hash, making it impractical to share one'snnnnto try to influence people's votes before residual  hits and the second phase starts. owever, to keep this eample from getting too complicated we will not do this additionally,  personally am skeptical of "forced private data revelation" strategies in general because  predict that many of them will become useless with the eventual advent ofnngeneralized zero-knowledge proofsnn,nnfully homomorphic encryptionnnandnnobfuscationnn. or eample, one might imagine an attacker beating such a scheme by supplying a zero-knowledge proof that theirnnnnvalue is within a particular nnnnwei-wide range, giving enough information to give users a target but not enough to practically locate the eact value ofnnnn. iven these concerns, and given the desire for simplicity, for now the simple two-round protocol with no bells-and-whistles is best.nnefore we start coding chellingoin itself, there is one other contract that we will need to create a sorting function. he only way to calculate the median of a list of numbers and determine who is in a particular percentile range is to sort the list, so we will want a generalized function to do that. or added utility, we will make our sorting function generic we will sort pairs instead of integers. hus, for eamples,nn, , , , , , , ]nnwould becomenn , , , , , , ,  ]nn. sing this function, one can sort a list containing any kind of object simply by making an array of pairs where the first number is the key to sort by and the second number is a pointer to the object in parent memory or storage. ere'snnthe codennnnifnnmsg.datasizennnnnnnnreturnnn(nnnn]nn,nnnn)nnelsennlownnnnarraynn(nnmsg.datasizenn)nnlsznnnnnnhighnnnnarraynn(nnmsg.datasizenn)nnhsznnnnnninnnnnnwhilenninnnnmsg.datasizennifnnmsg.datannnninn]nnnnmsg.datannnnnn]nnnnlownnnnlsznn]nnnnmsg.datannnninn]nnlownnnnlsz +nnnn]nnnnmsg.datannnni +nnnn]nnlsznn+nnnnelsennhighnnnnhsznn]nnnnmsg.datannnninn]nnhighnnnnhsz +nnnn]nnnnmsg.datannnni +nnnn]nnhsznn+nnnninnnni +nnnnlownnnncallnn(nncontract.address, low, lsz, lsznn)nnhighnnnncallnn(nncontract.address, high, hsz, hsznn)nnonnnnarraynn(nnmsg.datasizenn)nninnnnnnwhilenninnnnlsznnonnnninn]nnnnlownnnninn]nninn+nnnnonnnnlsznn]nnnnmsg.datannnnnn]nnonnnnlsz +nnnn]nnnnmsg.datannnnnn]nnjnnnnnnwhilennjnnnnhsznnonnnnlsz +nnnn+ jnn]nnnnhighnnnnjnn]nnjnn+nnnnreturnnn(nno, msg.datasizenn)nnomputer students may recognize this as a quicksort implementation the idea is that we first split the list into two, with one half containing everything less than the first item and the other half containing everything greater, then we recursively sort the first and second lists (the recursion terminates eventually, since eventually the sub-lists will have zero or one items, in which case we just return those values directly), and finally we concatenatennoutput  sorted_less_than_list + first item + sorted_greater_than_listnnand return that array. ow, putting that into "quicksort_pairs.se", let's build the codennfor the actual chellingoinnn. eel free to go to the github to see the code all in one piece here, we will go through it a few lines at a time.nnirst, some initialization codenninitnncontract.storagennnnnn]nnnnblock.numbernncontract.storagennnnnn]nnnncreatenn(nn'quicksort_pairs.se'nn)nncodennnnnnnn^nnnnnnnn^nnhe first code block sets contract storage inde  to the current block number at initialization time, and then creates a quicksort contract and saves that in storage inde . ote that theoretically you would want to just create the quicksort contract once and refer to it by address we're just doing an inline create for simplicity and to show the feature. n the code we start off by declaring two variables to serve as pseudo-constants   nnnnas the pointer for where we store hashes, and   nnnnas the pointer for where we store values from the second phase.nnow, from here let's skip to the bottom half of the code, because that turns out to be more convenient and it's the code that actually gets run "first" over the course of the contract's lifetime.nn# ash submissionnnifnnmsg.datannnnnn]nnnnnnnnifnnblock.number %nnnnnnnnnncurnnnncontract.storagennnnnn]nnposnnnn + cur *nnnncontract.storagennnnposnn]nnnnmsg.datannnnnn]nncontract.storagennnnpos +nnnn]nnnnmsg.valuenncontract.storagennnnpos +nnnn]nnnnmsg.sendernncontract.storagennnnnn]nnnncur +nnnnreturnnn(nncurnn)nn# alue submissionnnelifnnmsg.datannnnnn]nnnnnnnnifnnshann(nnnnmsg.sender, msg.datannnnnn]nn, msg.datannnnnn]nn]nn,nnnn)nnnncontract.storagennnn + msg.datannnnnn]nn*nnnn]nnnncontract.storagennnn + msg.datannnnnn]nn]nnnnmsg.datannnnnn]nnreturnnn(nnnn)nn# alance requestnnelifnnmsg.datannnnnn]nnnnnnnnreturnnn(nncontract.balancenn)nn# alue requestnnelsennreturnnn(nncontract.storagennnnnn]nn)nnhe first important paradigm that we see here is usingnnmsg.data]nnto refer to a "message type" messages with zeroth data item  are hash submissions,  are value submissions,  are balance requests and  are requests for the current cent/wei price. his is a standard interface that you will likely see across very many contracts. he first clause, the one for submitting hashes, is somewhat involved, so let us break it down step by step. he primary purpose here is to allow people to submit hashes, and record submissions in storage. o that end, the contract is storing the data sequentially in storage starting at inde nnnn. e need to store three pieces of data - the actual hash, the size of the accompanying deposit, and the sender address, for each hash, so we do that. e also use storage inde  to store how many hashes have already been submitted. hus, if two hashes have been submitted, storage will look something like thisnnhe precise instructions in the clause arennroceed only if the residual is less than .nnet the variablenncurnnto storage inde , where we are going to be storing the number of hashes that have already been submittednnet the variablennposnnto the inde in storage in which we will be putting the new hashnnave the hash (supplied as the first data item), the sender address and the value in storagennet the new number of hashes tonncur + nneturn the inde of the hash suppliednnechnically, if the only users of chellingoin are people, step  is unnecessary although the inde will be necessary in a later step, a smart client could potentially simply scan thenncurnnvariable immediately after the transaction, removing the need for the opcodes needed to handle the return. owever, since we epect that in thereum we will have plenty of instances of contracts using other contracts, we will provide the return value as a habit of good machine interface.nnhe net clause is for submitting values. ere, we ask for two data items as input the inde where the hash was saved during the first step of the protocol (this is the return value of the previous clause), and the actual value. e then hash the sender and value together, and if the hash matches then we save the result in another place in contract storage an alternative approach is to use one single starting storage location and simply have four slots per hash instead of three. e return  is successful, and nothing for a failure. he third and fourth clauses are simply trivial data requests the third is a balance check, and the fourth returns the contract's current view of the price.nnhat's all for the interface side of the contract however, the one part that we still need to do is the part that actually aggregates the votes. e'll break that up into parts. irst, we havennnnnnnn^nnnnnnnn^nnifnnblock.number /nnnnnncontract.storagennnnnn]nn/nnnnnn# ort all hashesnnnnnncontract.storagennnnnn]nnonnnnarraynn(nnnn)nninnnnnnjnnnnnnwhilenninnnnnnifnncontract.storagennnn + inn]nnnnonnnnjnn]nnnncontract.storagennnn + inn]nnonnnnj +nnnn]nnnninnjnn+nnnninn+nnnnvaluesnnnncallnn(nncontract.storagennnnnn]nn, o, j, jnn)nnirst, we use storage inde  to store the last accessed epoch, and we check if the current epoch is higher than the last accessed epoch. f it is, then that signals the start of a new epoch, so we need to process all the votes and clear the contract for the net epoch. e start off by copying the values that have been submitted to an array (values that have not been submitted, ie. zeroes, are not put into this array). e keep two running counters,nninnandnnjnn the counternninnruns through all value slots, but the counternnjnncounts only the value slots that have something inside them. ote that the array that we produce is of the formnn val, inde, val, inde ... ]nn, wherennindennetc are the indices of the associated values in the original values array in contract storage, thus for eample, the following values would lead to the following arraynnhen, we send that array through the quicksort contract, which sorts data pairs in the array. fter the sort, we end up withnnow, what we have is a sorted list of all the values that people have submitted, alongside pointers to where the associated metadata is stored in cold storage. he net part of the code will handle three things simultaneously. irst, it will compute the total amount that has been deposited this is useful in figuring out the median. econd, we will make two arrays to represent deposits and their associated addresses, and we will remove that data from the contract. inally, we will .% refund anyone who did not submit a value. heoretically, we could make it a % refund or a % refund, but that might make the contract too risky for people to throw their life savings in (which is actually what we want in a proof-of-stake-weighted system the more ether is thrown in by legitimate users the harder it is for an attacker to muster enough funds to launch an attack). here's the code feel free to understand each line yourselfnn# alculate total deposit, refund non-submitters andnn# cleanupnndepositsnnnnarraynn(nnj /nnnn)nnaddressesnnnnarraynn(nnj /nnnn)nninnnnnntotal_depositnnnnnnwhilenninnnnj /nnnnnnbase_indennnn + valuesnnnni *nnnn+nnnn]nn*nnnncontract.storagennnnbase_indenn]nnnnnndepositsnnnninn]nnnncontract.storagennnnbase_inde +nnnn]nncontract.storagennnnbase_inde +nnnn]nnnnnnaddressesnnnninn]nnnncontract.storagennnnbase_inde +nnnn]nncontract.storagennnnbase_inde +nnnn]nnnnnnifnncontract.storagennnn + valuesnnnni *nnnn+nnnn]nn]nnnntotal_depositnn+nndepositsnnnninn]nnelsennsendnn(nnaddressesnnnninn]nn, depositsnnnninn]nn*nnnn/nnnn)nninn+nnnnow, we come to the last part of the code, the part the computes the median and rewards people. ccording to the specification, we need to reward everyone between the th and th percentile, and take the median (ie. th percentile) as the truth. o actually do this, we needed to first sort the data now that the data is sorted, however, it's as simple as maintaining a running counter of "total deposited value of everything in the list up to this point". f that value is between % and % of the total deposit, then we send a reward slightly greater than what they sent in, otherwise we send a slightly smaller reward. ere is the codenninverse_profit_rationnnntotal_deposit /nn(nncontract.balance /nnnn)nn+nnnn# eward everyonenninnnnnnrunning_deposit_sumnnnnnnhalfway_passednnnnnnwhilenninnnnj /nnnnnnnew_deposit_sumnnnnrunning_deposit_sum + depositsnnnninn]nnifnnnew_deposit_sumnnnntotal_deposit /nnnnand running_deposit_sumnnnntotal_deposit *nnnn/nnnnnnsendnn(nnaddressesnnnninn]nn, depositsnnnninn]nn+ depositsnnnninn]nn/ inverse_profit_ratio *nnnn)nnelsennsendnn(nnaddressesnnnninn]nn, depositsnnnninn]nn- depositsnnnninn]nn/ inverse_profit_rationn)nnifnnnot halfway_passed and new_deposit_sumnnnntotal_deposit /nnnnnncontract.storagennnnnn]nnnncontract.storagennnn + inn]nnhalfway_passednnnnnncontract.storagennnn + inn]nnnnnnrunning_deposit_sumnnnnnew_deposit_sumnninn+nnnncontract.storagennnnnn]nnnnblock.numbernncontract.storagennnnnn]nnnnnnt the same time, you can see we also zero out the values in contract storage, and we update the epoch and reset the number of hashes to zero. he first value that we calculate, the "inverse profit ratio", is basically the inverse of the "interest rate" you get on your deposit ifnninverse_profit_ratio  nn, and you submitted  wei, then you get  wei back if you are close to the median and  if you are not (ie. your epected return is  wei). ote that although this amount is tiny, it happens per hundred blocks, so really it is quite large. nd that's all there is to it. f you want to test, then try running the following ython scriptnnimportnnpyethereumnntnnnnpyethereum.testernnsnnnnt.statenn(nn)nns.minenn(nnnn)nncnnnns.contractnn(nn'schellingcoin.se'nn)nncnnnns.contractnn(nn'schellinghelper.se'nn)nnvalsnnnnnnnnnn,nnnn]nn,nnnnnn,nnnn]nn,nnnnnn,nnnn]nn,nnnnnn,nnnn]nn,nnnnnn,nnnn]nn,nnnnnn,nnnn]nn,nnnnnn,nnnn]nn]nns.sendnn(nnt.k, c,nnnn**nn)nnprintnn"ubmitting hashes"nnfornni,nnvnninnnenumeratenn(nnvalsnn)nnnnprint s.sendnn(nnt.keysnnnninn]nn, c, vnnnnnn]nn,nnnnnn]nn+ s.sendnn(nnt.keysnnnninn]nn, c,nnnn,nnnnvnnnnnn]nn,nnnn]nn))nns.minenn(nnnn)nnprintnn"ubmitting vals"nnfornni,nnvnninnnenumeratenn(nnvalsnn)nnnnifnninn!nnnnnnprint s.sendnn(nnt.keysnnnninn]nn, c,nnnn,nnnnnn, i, vnnnnnn]nn,nnnn]nn)nnelsennprint s.sendnn(nnt.keysnnnninn]nn, c,nnnn,nnnnnn, i,nnnn]nn)nnprintnn"inal check"nns.minenn(nnnn)nnprint s.sendnn(nnt.k, c,nnnn,nnnnnn]nn)nnefore running the script, be sure to fill the 'schellinghelper.se' file withnnreturn(sha(msg.sender, msg.data], msg.data]], ))nn here, we're just being lazy and using erpent itself to help us put the hash together in reality, this should definitely be done off-chain. f you do that, and run the script, the last value printed by the contract should return .nnote that this contract as it stands is not really scalable by itself at + users, whoever supplies the first transaction at the start of each epoch would need to pay a very large amount of gas. he way to fi this economically is of course to reward the submitter of the transaction, and take a flat fee off every participant to pay for the reward. lso, however, the interest rate per epoch is tiny, so it may already not be worth it for users to participate unless they have a signigicant amount of cash, and the flat fee may make this problem even worse.nno allow people to participate with small amounts of ether, the simplest solution is to create a "stake pool" where people put their ether into a contract for the long term, and then the pool votes together, randomly selecting a participant weighted by stake to supply the value to vote for in each epoch. his would reduce the load from two transactions per user per epoch to three transactions per pool per epoch (eg.  pool   users) plus one transaction per user to deposit/withdraw. ote that, unlike itcoin mining pools, this stake pool is completely decentralized and blockchain-based, so it introduces at most very small centralization risks. owever, this is an instructive eample to show how a single contract or  may end up leading to an entire ecosystem of infrastructure working on the blockchain with contracts talking to each other a specialized chellingoin blockchain would not be able to invent pooling mechanisms after the fact and integrate them so efficiently.nns far as applications go, the most immediate one is contracts for difference, and eventually a decentralized cryptographic  dollar if you want to see an attempt at such a contract seennherenn, although that code is almost certainly vulnerable to market manipulation attacks (buy a very large amount of  inside the system, then buy  on the market to move the price .%, then sell the  inside the system for a quick .% profit). he core idea behind the decentralized crypto-dollar is simple have a bank with two currencies,  and ether (or rather, cent and wei), with the ability to have a positive or negative quantity of dollars, and manipulate the interest rate on dollar deposits in order to keep the contract's net dollar eposure always close to zero so that the contract does not have any net obligations in currencies that it does not have the ability to hold.  simpler approach would simply be to have an epanding-supply currency that adjusts its supply function to target the , but that is problematic because there is no protection if the value falls too much. hese kinds of applications, however, will likely take quite a long time (in crypto terms quite fast in traditional finance terms of course) to get built.