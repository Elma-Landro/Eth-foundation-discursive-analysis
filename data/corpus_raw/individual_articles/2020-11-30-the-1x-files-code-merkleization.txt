Titre: The Burden of Proof(s): Code Merkleization\nAuteur: Griffin Ichiba Hotchkiss\nDate: November 30, 2020\nURL: https://blog.ethereum.org/2020/11/30/the-1x-files-code-merkleization\nCatégorie: Non catégorisé\n\n==================================================\n\nnote about the tateless thereum initiativennesearch activity has (understandably) slowed in the second half of  as all contributors have adjusted to life on the weird timeline. ut as the ecosystem moves incrementally closer to erenity and the th/th merge, tateless thereum work will become increasingly relevant and impactful. pect a more substantial year-end tateless thereum retrospective in the coming weeks.nnet's roll through the re-cap one more time he ultimate goal of tateless thereum is to remove thennrequirementnnof an thereum node to keep a full copy of the updated state trie at all times, and to instead allow for changes of state to rely on a (much smaller) piece of data that proves a particular transaction is making a valid change. oing this solves a major problem for thereum a problem that has so far only been pushed further out by improved client softwarenntate growthnn.nnhe erkle proof needed for tateless thereum is called a 'witness', and it attests to a state change by providing all of thennunchangednnintermediate hashes required to arrive at a new valid state root. itnesses are theoretically a lot smaller than the full thereum state (which takes  hours at best to sync), but they are stillnna lot largernnthan a block (which needs to propagate to the whole network in just a few seconds). eaning out the size of witnesses is therefore paramount to getting tateless thereum to minimum-viable-utility.nnust like the thereum state itself, a lot of the etra (digital) weight in witnesses comes from smart contract code. f a transaction makes a call to a particular contract, the witness will by default need to include the contract bytecodennin its entiretynnwith the witness. ode erkelization is a general technique to reduce burden of smart contract code in witnesses, so that contract calls only need to include the bits of code that they 'touch' in order to prove their validity. ith this technique alone we might see a substantial reduction in witness, but there are a lot of details to consider when breaking up smart contract code into byte-sized chunks.nnhat is ytecodennhere are some trade-offs to consider when splitting up contract bytecode. he question we will eventually need to ask is "how big will the code chunks be" – but for now, let's look at some real bytecode in a very simple smart contract, just to understand what it isnnpragma soliditynnnn.nn.nnnn.nn.nnnncontract toragenn{nnuint numbernnnnfunctionnnstorenn(nnuint numnn)nnpublicnn{nnnumbernnnnnumnnnn}nnfunctionnnretrievenn(nn)nnpublic view returnsnn(nnuintnn)nn{nnreturnnnnumbernnnn}nn}nnhen this simple storage contract is compiled, it turns into the machine code meant to run 'inside' the . ere, you can see the same simple storage contract shown above, but complied into individual  instructions (opcodes)nn                                                                                                                                                              nns eplained innna previous postnn, these opcode instructions are the basic operations of the 's stack architecture. hey define the simple storage contract, and all of the functions it contains. ou can find this contract as one of the eample solidity contracts in thennemi nn(ote that the machine code above is an eample of the storage.solnnafter it's already been deployednn, and not the output of the olidity compiler, which will have some etra 'bootstrapping' opcodes). f you un-focus your eyes and imagine a physical stack machine chugging along with step-by-step computation on opcode cards, in the blur of the moving stack you can almost see the outlines of functions laid out in the olidity contract.nnhenever the contract receives a message call, this code runs inside every thereum node validating new blocks on the network. n order to submit a valid transaction on thereum today, one needs a full copy of the contract's bytecode, because running that code from beginning to end is the only way to obtain the (deterministic) output state and associated hash.nntateless thereum, remember, aims to change this requirement. et's say that all you want to do is call the functionnnretrieve()nnand nothing more. he logic describing that function is only a subset of the whole contract, and in this case the  only really needs two of thennbasic blocksnnof opcode instructions in order to return the desired valuenn       ,nn                     nnn the tateless paradigm, just as a witness provides the missing hashes of un-touched state, a witness should also provide the missing hashes for un-eecuted pieces of machine code, so that a stateless client only requires the portion of the contract it's eecuting.nnhe ode's itnessnnmart contracts in thereum live in the same place that eternally-owned accounts do as leaf nodes in the enormous single-rooted state trie. ontracts are in many ways no different than the eternally-owned accounts humans use. hey have an address, can submit transactions, and hold a balance of ther and any other token. ut contract accounts are special because they must contain their own program logic (code), or a hash thereof. nother associated erkle-atricia rie, called thennstorageriennkeeps any variables or persistent state that an active contract uses to go about its business during eecution.nnhis witness visualization provides a good sense of how important code merklization could be in reducing the size of witnesses. ee that giant chunk of colored squares and how much bigger it is than all the other elements in the trie hat's a single full serving of smart contract bytecode.nnet to it and slightly below are the pieces of persistent state in thennstoragerienn, such as  balance mappings or  digital item ownership manifests. ince this is eample is of a witness and not a full state snapshot, those too are made mostly of intermediate hashes, and only include the changes a stateless client would require to prove the net block.nnode merkleization aims to split up that giant chunk of code, and to replace the fieldnncodeashnnin an thereum account with the root of another erkle rie, aptly named thenncoderienn.nnorth its eight in ashesnnet's look at an eample fromnnthis thereum ngineering roup videonn, which analyzes some methods of code chunking using annn tokennncontract. ince many of the tokens you've heard of are made to the - standard, this is a good real-world contet to understand code merkleization.nnecause bytecode is long and unruly, let's use a simple shorthand of replacing four bytes of code ( heidecimal characters) with either annn.nnornnnncharacter, with the latter representing bytecode required for the eecution of a specific function (in the eample, thenn.transfer()nnfunction is used throughout).nnn the  eample, calling thenntransfer()nnfunction uses a little less than half of the whole smart contractnn.nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn.nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn.nn..nn..nn..nn..nn..nn..nnnn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nnnn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn.nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nnnnnn..nn..nn..nn..nn..nn..nn..nn.nnnn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn.nnnn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nnnnnn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nn..nnf we wanted to split up that code into chunks of  bytes, only  out of the  chunks would be required to eecute a statelessnntransfer()nntransaction, with the rest of the required data coming from a witness.nn|nn.nn|nnnn..nn..nn..nn..nn..nn|nn..nn..nn..nn..nn..nn..nn..nn..nn|nn..nn..nn..nn..nn..nn..nn..nn..nn|nn..nn..nn..nn..nn..nn..nn..nn..nn|nn..nn..nn.nn..nn..nn.nn|nn..nn..nn..nn..nn..nn..nn..nn..nn|nn..nn..nn..nn..nn..nn..nn..nn..nn|nn..nn..nn..nn..nn..nn..nnnn|nnnn..nn..nn..nn..nn|nn..nn..nn..nn..nn..nn..nn..nn..nn|nn..nn..nn..nn..nn..nn..nn..nn..nn|nn..nn..nn..nn..nn..nn..nn..nn..nn|nn..nn..nn..nn..nnnn..nn..nn.nn|nn..nn..nn..nn..nn..nn..nn..nn..nn|nn..nn..nn..nn..nn..nn..nnnn..nn|nn..nn..nn..nn..nn..nn..nn..nn..nn|nn..nn..nn..nn..nn..nn..nn..nn..nn|nn..nn..nn..nn..nn..nn..nn..nn..nn|nn..nn..nn..nnnn|nnnn|nnnn..nn..nn..nn..nn..nn..nn..nn|nn.nn|nnnn|nnnn|nnnn..nn|nn..nn..nn..nn..nn..nn..nn..nn..nn|nn..nn..nn..nn..nn..nn..nn..nn..nn|nn..nn..nn..nn..nn..nn..nn..nn..nn|nn..nn..nn..nn..nn..nn..nn..nn..nn|nn..nn..nn..nn..nn..nn..nn..nn..nn|nn..nn..nn..nn.nn|nnnn|nnnn..nn.nn|nn..nn..nn..nn..nn..nn..nn..nn..nn|nn..nn..nn..nn..nn..nn..nn..nn.nn|nnnn..nn..nn..nn..nn|nn..nn..nn..nn..nn..nn..nn..nn..nn|nn..nn..nn..nn..nn..nn..nn..nn..nn|nn..nn..nn..nn..nn..nn..nn..nn..nn|nn..nn..nnompare that to  out of  chunks in a  byte chunking schemenn|nn.nn|nnnn|nnnn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn.nn|nnnn..nn..nn.nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nnnn|nnnn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nnnn..nn..nn.nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nnnn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nnnn|nnnn|nnnn|nnnn|nnnn..nn..nn..nn|nn..nn..nn..nn..nn|nn.nn|nnnn|nnnn|nnnn|nnnn|nnnn|nnnn|nnnn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn.nn|nnnn|nnnn|nnnn|nnnn|nnnn..nn.nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn.nn|nnnn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nn..nn..nn|nn..nn..nnn the surface it seems like smaller chunks are more efficient than larger ones, because thennmostly-emptynnchunks are less frequent. ut here we need to remember that the unused code has a cost as well each un-eecuted code chunk is replaced by a hash ofnnfied sizenn. maller code chunks mean a greater number of hashes for the unused code, and those hashes could be as large as  bytes each (or as small as  bytes). ou might at this point eclaim "ol' up! f the hash of code chunks is a standard size of  bytes, how would it help to replace  bytes of code with  bytes of hash!".nnecall that the contract code isnnmerkleizednn, meaning that all hashes are linked together in thenncoderienn-- the root hash of which we need to validate a block. n that structure, anynnsequentialnnun-eecuted chunks only require one hash, no matter how many there are. hat is to say, one hash can stand in for a potentially large limb full of sequential chunk hashes on the merkleized code trie, so long as none of them are required for coded eecution.nne ust ollect dditional atannhe conclusion we've been building to is a bit of an anticlima here is no theoretically 'optimal' scheme for code merkleization. esign choices like fiing the size of code chunks and hashesnndepend on data collected about the 'real world'nn. very smart contract will merkleize differently, so the burden is on researchers to choose the format that provides the largest efficiency gains to observed mainnet activity. hat does that mean, eactlynnne thing that could indicate how efficient a code merkleization scheme isnnerkleization overheadnn, which answers the question "how much etra information beyond eecuted code is getting included in this witness"nnlready we havennsome promising resultsnn, collected usingnna purpose-built toolnndeveloped by oracio ijail from onsensys' eam research team, which shows overheads as small as % -- not bad at all!nnn short, the data shows that by-and-large smaller chunk sizes are more efficient than larger ones, especially if smaller hashes (-bytes) are used. ut these early numbers are by no means comprehensive, as they only represent about  recent blocks. f you're reading this and interested in contributing to the tateless thereum initiative by collecting more substantial code merkleization data, come introduce yourself on the ethresear.ch forums, or the #code-merkleization channel on the th/ research discord!nnnd as always, if you have questions, feedback, or requests related to "he . iles" and tateless thereum,  or gichiba on twitter.