Titre: Secret Sharing DAOs: The Other Crypto 2.0\nAuteur: Vitalik Buterin\nDate: December 26, 2014\nURL: https://blog.ethereum.org/2014/12/26/secret-sharing-daos-crypto-2-0\nCatégorie: Non catégorisé\n\n==================================================\n\nhe crypto . industry has been making strong progress in the past year developing blockchain technology, including the formalization and in some cases realization of proof of stake designs likennlashernnandnnnn, variousnnformsnnofnnscalablennblockchainnnalgorithmsnn, blockchains using "leader-free consensus" mechanisms derived fromnntraditional yzantine fault tolerance theorynn, as well as economic ingredients likennchellingnnconsensusnnschemesnnandnnstablenncurrenciesnn. ll of these technologies remedy key deficiencies of the blockchain design with respect to centralized servers scalability knocks down size limits and transaction costs, leader-free consensus reduces many forms of eploitability, stronger o consensus algorithms reduce consensus costs and improve security, and chelling consensus allows blockchains to be "aware" of real-world data. owever, there is one piece of the puzzle that all approaches so far have not yet managed to crack privacy.nnurrency, apps and rivacynnitcoin brings to its users a rather unique set of tradeoffs with respect to financial privacy. lthough itcoin does a substantially better job than any system that came before it at protecting thennphysical identitiesnnbehind each of its accounts - better than fiat and banking infrastructure because it requires no identity registration, and better than cash because it can be combined with or to completely hide physical location, the presence of the itcoin blockchain means that the actualnntransactionsnnmade by the accounts are more public than ever - neither the  government, nor hina, nor the thirteen year old hacker down the street even need so much as a warrant in order to determine eactly which account sent how much  to which destination at what particular time. n general, these two forces pull itcoin in opposite directions, and it is not entirely clear which one dominates.nnith thereum, the situation is similar in theory, but in practice it is rather different. itcoin is a blockchain intended for currency, and currency is inherently a very fungible thing. here eist techniques likennmerge avoidancennwhich allow users to essentially pretend to be  separate accounts, with their wallet managing the separation in the background.nnoinjoinnncan be used to "mi" funds in a decentralized way, and centralized miers are a good option too especially if one chains many of them together. thereum, on the other hand, is intended to store intermediate state ofnnanynnkind of processes or relationships, and unfortunately it is the case that many processes or relationships that are substantially more comple than money are inherently "account-based", and large costs would be incurred by trying to obfuscate one's activities via multiple accounts. ence, thereum, as it stands today, will in many cases inherit the transparency side of blockchain technology much more so than the privacy side (although those interested in using thereum for currency can certainly build higher-privacy cash protocols inside of subcurrencies).nnow, the question is, what if there are cases where people really want privacy, but a iaspora-style self-hosting-based solution or a erocash-style zero-knowledge-proof strategy is for whatever reason impossible - for eample, because we want to perform calculations that involve aggregating multiple users' private data ven if we solve scalability and blockchain data assets, will the lack of privacy inherent to blockchains mean that we simply have to go back to trusting centralized servers r can we come up with a protocol that offers the best of both worlds a blockchain-like system which offers decentralized control not just over the right to update the state, but even over the right to access the information at allnns it turns out, such a system is well within the realm of possibility, and was even conceptualized by ick zabonnin nnunder the moniker of "od protocols" (though, as ick zabo pointed out, we should not use that term for the protocols that we are about to describe here as od is generally assumed or evennndefinednnto be areto-superior tonneverythingnnelse and as we'll soon see these protocols are very far from that) but now with the advent of itcoin-style cryptoeconomic technology the development of such a protocol may for the first time actually be viable. hat is this protocol o give it a reasonably technically accurate but still understandable term, we'll call it a "secret sharing ".nnundamentals ecret haringnno skip the fun technical details and go straight to applications,nnclick herennecret computation networks rely on two fundamental primitives to store information in a decentralized way. he first isnnsecret sharingnn. ecret sharing essentially allows data to be stored in a decentralized way across  parties such that any  parties can work together to reconstruct the data, but - parties cannot recover any information at all.  and  can be set to any values desired all it takes is a few simple parameter tweaks in the algorithm.nnhe simplest way to mathematically describe secret sharing is as follows. e know that two points make a linenno, to implement -of- secret sharing, we take our secretnnnn, generate a random slopennmnn, and create the linenny  m + nn. e then give thennnnparties the points on the linenn(, m + )nn,nn(, m + )nn,nn(, m + )nn, etc. ny two of them can reconstruct the line and recover the original secret, but one person can do nothing if you receive the pointnn(, )nn, that could be from the linenny   + nn, ornny  - + nn, ornny   - nn. o implement -of- secret sharing, we just make a parabola instead, and give people points on the parabolannarabolas have the property that any three points on a parabola can be used to reconstruct the parabola (and no one or two points suffice), so essentially the same process applies. nd, more generally, to implement -of- secret sharing, we use a degree - polynomial in the same way. here is annset of algorithmsnnfor recovering the polynomial from a sufficient set of points in all such cases they are described in more details in ournnearlier article on erasure codingnn.nnhis is how the secret sharing  will store data. nstead of every participating node in the consensus storing a copy of the full system state, every participating node in the consensus will store a set ofnnsharesnnof the state - points on polynomials, one point on a different polynomial for each variable that makes up part of the state.nnundamentals omputationnnow, how does the secret sharing  do computation or this, we use a set of algorithms callednnsecure multiparty computationnn(). he basic principle behind  is that there eist ways to take data which is split among  parties using secret sharing, perform computations on it in a decentralized way, and end up with the result secret-shared between the parties, all without ever reconstituting any of the data on a single device.nn with addition is easy. o see how, let's go back to the two-points-make-a-line eample, but now let's have two linesnnuppose that thennnnpoint of both linesnnnnandnnnnis stored by computernn]nn, thennnnpoint is stored by computernn]nn, etc. ow, suppose thatnn]nncomputes a new value,nn()  () + ()nn, and  computesnn()  () + ()nn. ow, let's draw a line through those two pointsnno we have a new line,nnnn, such thatnn   + nnat pointsnnnnandnnnn. owever, the interesting thing is, this new line is actually equal tonn + nnonnneverynnpointnnhus, we have a rule sums of secret shares (at the same  coordinate) are secret shares of the sum. sing this principle (which also applies to higher dimensions), we can convert secret shares ofnnannand secret shares ofnnbnninto secret shares ofnna+bnn, allnnwithout ever reconstitutingnnannandnnbnnthemselvesnn. ultiplication by a known constant value works the same waynnknntimes the ith secret share ofnnannis equal to the ith secret share ofnna*knn.nnultiplication of two secret shared values, unfortunately, isnnmuch more involvednn. he approach will take several steps to eplain, and because it is fairly complicated in any case it's worth simply doing for arbitrary polynomials right away. ere's the magic. irst, suppose that there eist valuesnnannandnnbnn, secret shared among partiesnn]nn...nnn]nn, wherennai]nnrepresents the ith share ofnnann(and same fornnbi]nnandnnbnn). e start off like thisnnow, one option that you might think of is, if we can just make a new polynomialnnc  a + bnnby having every party storennci]  ai] + bi]nn, can't we do the same for multiplication as well he answer is, surprisingly, yes, but with a serious problem the new polynomial has a degree twice as large as the original. or eample, if the original polynomials werenny   + nnandnny   - nn, the product would benny  ^ +  - nn. ence, if we do multiplication more than once, the polynomial would become too big for the group of  to store.nno avoid this problem, we perform a sort of rebasing protocol where we convert the shares of the larger polynomial into shares of a polynomial of the original degree. he way it works is as follows. irst, partynni]nngenerates a new random polynomial, of the same degree asnnannandnnbnn, which evaluates tonnci]  ai]*bi]nnat zero, and distributes points along that polynomial (ie. shares ofnnci]nn) to all parties.nnhus,nnj]nnnow hasnnci]j]nnfor allnninn. iven this,nnj]nncalculatesnncj]nn, and so everyone has secret shares ofnncnn, on a polynomial with the same degree asnnannandnnbnn.nno do this, we used a clever trick of secret sharing because the secret sharing math itself involves nothing more than additions and multiplications by known constants, the two layers of secret sharing are commutative if we apply secret sharing layer  and then layer , then we can take layer  off first and still be protected by layer . his allows us to move from a higher-degree polynomial to a lower degree polynomial but avoid revealing the values in the middle - instead, the middle step involved both layers being appliednnat the same timenn.nnith addition and multiplication over  and , we have the ability to run arbitrary circuits inside of the  mechanism. e can definenn(a, b)  a * bnn(a, b)  a + b - a * bnn(a, b)  a + b -  * a * bnn(a)   - annence, we can run whatever programs we want, although with one key limitation we can't do secret conditional branching. hat is, if we had a computationnnif (  ) do  else do nnthen the nodes would need to know whether they are computing branch  or branch , so we would need to revealnnnnmidway through.nnhere are two ways around this problem. irst, we can use multiplication as a "poor man's if" - replace something likennif (  ) y  nnwithnny  (  ) *  + ( ! ) * ynn, using either circuits or clever protocols that implement equality checking through repeated multiplication (eg. if we are in annfinite fieldnnwe can check ifnna  bnnby usingnnermat's little theoremnnonnna-bnn). econd, as we will see, if we implement if statements inside the , and run the  inside , then we can resolve the problem, leaking only the information of how many steps the  took before computation eited (and if we really care, we can reduce the information leakage further, eg. round the number of steps to the nearest power of two, at some cost to efficiency).nnhe secret-sharing based protocol described above is only one way to do relatively simply  there are other approaches, and to achieve security there is also a need to add annverifiable secret sharingnnlayer on top, but that is beyond the scope of this article - the above description is simply meant to show how a minimal implementation is possible.nnuilding a urrencynnow that we have a rough idea of how  works, how would we use it to build a decentralized currency engine he general way that a blockchain is usually described in this blog is as a system that maintains a state,nnnn, accepts transactions, agrees on which transactions should be processed at a given time and computes a state transition functionnn(, ) - '  nn. ere, we will say thatnnallnntransactions are valid, and if a transactionnnnnis invalid then we simply havenn(, )  nn.nnow, since the blockchain is not transparent, we might epect the need for two kinds of transactions that users can send into the nnget requestsnn, asking for some specific information about an account in the current state, andnnupdate requestsnn, containing transactions to apply onto the state. e'll implement the rule that each account can only ask for balance and nonce information about itself, and can withdraw only from itself. e define the two types of requests as followsnnnnnnfrom_pubkey, from_id, to, value, nonce, signn]nnnnnnfrom_pubkey, from_id, signn]nnhe database is stored among the  nodes in the following formatnnssentially, the database is stored as a set of -tuples representing accounts, where each -tuple stores the owning pubkey, nonce and balance. o send a request, a node constructs the transaction, splits it off into secret shares, generates a random request  and attaches the  and a small amount of proof of work to each share. he proof of work is there because some anti-spam mechanism is necessary, and because account balances are private there is no way if the sending account has enough funds to pay a transaction fee. he nodes then independently verify the shares of the signature against the share of the public key supplied in the transaction (there are signature algorithms that allow you to do this kind of per-share verificationnnchnorr signaturesnnare one major category). f a given node sees an invalid share (due to proof of work or the signature), it rejects it otherwise, it accepts it.nnransactions that are accepted are not processed immediately, much like in a blockchain architecture at first, they are kept in a memory pool. t the end of every  seconds, we use some consensus algorithm - it could be something simple, like a random node from the  deciding as a dictator, or an advanced neo- algorithm like that used bynnebblenn- to agree on which set of request s to process and in which order (for simplicity, simple alphabetical order will probably suffice).nnow, to fufill a  request, the  will compute and reconstitute the output of the following computationnnowner_pubkeynnnnnnnnnn]nn*nn(nnfrom_idnnnnnn)nn+ nnnnnn]nn*nn(nnfrom_idnnnnnn)nn+nn..nn. + nnnnnn*nnn]nn*nn(nnfrom_idnnnnnnn)nnvalidnnnn(nnowner_pubkeynnnnfrom_pubkeynn)nnoutputnnnnvalid *nn(nnnnnnnn]nn*nn(nnfrom_idnnnnnn)nn+ nnnnnn]nn*nn(nnfrom_idnnnnnn)nn+nn..nn. + nnnnn +nnnn]nn*nn(nnfrom_idnnnnnnn))nno what does this formula do t consists of three stages. irst, we etract the owner pubkey of the account that the request is trying to get the balance of. ecause the computation is done inside of an , and so no node actually knows what database inde to access, we do this by simply taking all the database indices, multiplying the irrelevant ones by zero and taking the sum. hen, we check if the request is trying to get data from an account which is actually owns (remember that we checked the validity ofnnfrom_pubkeynnagainst the signature in the first step, so here we just need to check the account  against thennfrom_pubkeynn). inally, we use the same database getting primitive to get the balance, and multiply the balance by the validity to get the result (ie. invalid requests return a balance of , valid ones return the actual balance).nnow, let's look at the eecution of a . irst, we compute the validity predicate, consisting of checking that () the public key of the targeted account is correct, () the nonce is correct, and () the account has enough funds to send. ote that to do this we once again need to use the "multiply by an equality check and add" protocol, but for brevity we will abbreviatenn] * (  ) + ] * (  ) + ...nnwithnn * ]nn.nnvalidnnnn(nnnnnnfrom_id *nnnn]nnnnfrom_pubkeynn)nn*nn(nnnnnnfrom_id *nnnn+nnnn]nnnnnoncenn)nn*nn(nnnnnnfrom_id *nnnn+nnnn]nnnnvaluenn)nne then donnnnnnfrom_id *nnnn+nnnn]nn-nnnnvalue * validnnnnnnfrom_id *nnnn+nnnn]nn+nnvalidnnnnnnto *nnnn+nnnn]nn+nnvalue * validnnor updating the database,nn * ] + ynnepands to the set of instructionsnn] + y * (  ), ] + y * (  ) ...nn. ote that all of these can be parallelized. lso, note that to implement balance checking we used thennnnoperator. his is once again trivial using boolean logic gates, but even if we use a finite field for efficiency there do eistnnsome clever tricksnnfor performing the check using nothing but additions and multiplications.nnn all of the above we saw two fundamental limitations in efficiency in the  architecture. irst, reading and writing to a database has an (n) cost as you pretty much have to read and write every cell. oing anything less would mean eposing to individual nodes which subset of the database a read or write was from, opening up the possibility of statistical memory leaks. econd, every multiplication requires a network message, so the fundamental bottleneck here is not computation or memory but latency. ecause of this, we can already see that secret sharing networks are unfortunately not od protocols they can do business logic just fine, but they will never be able to do anything more complicated - even crypto verifications, with the eception of a select few crypto verifications specifically tailored to the platform, are in many cases too epensive.nnrom urrency to nnow, the net problem is, how do we go from this simple toy currency to a generic  processor ell, let us eamine the code for the virtual machine inside a single transaction environment.  simplified version of the function looks roughly as followsnndef run_evmnn(nnblock, t, msg, codenn)nnnnpcnnnnnngasnnnnmsg.gasnnstacknnnnnn]nnstack_sizennnnnneitnnnnnnwhilennnnnnopnnnncodennnnpcnn]nngas -nnnnnnifnngasnnnnnnor stack_sizennnnget_stack_reqnn(nnopnn)nnnneitnnnnnnifnnopnnnnnnnnnnstacknnnnstack_sizenn]nnynnnnstacknnnnstack_size -nnnn]nnstacknnnnstack_size -nnnn]nnnn + ynnstack_size -nnnnnnifnnopnnnnnnnnnnstacknnnnstack_sizenn]nnynnnnstacknnnnstack_size -nnnn]nnstacknnnnstack_size -nnnn]nnnn - ynnstack_size -nnnnnn..nn.nnifnnopnnnnnnpcnnnnstacknnnnstack_sizenn]nnstack_size -nnnnnn..nn.nnhe variables involved arennhe codennhe stacknnhe memorynnhe account statennhe program counternnence, we can simply store these as records, and for every computational step run a function similar to the followingnnopnnnncodennnnpcnn]nn* alive +nnnn*nn(nnnn- alivenn)nngas -nnnnnnstack_pnnnnnn]nnnnnnstack_pnnnnnn]nnnnnnstack_nnnnnnn]nnnnstacknnnnstack_sizenn]nn+ stacknnnnstack_size -nnnn]nnstack_sznnnnnn]nnnnstack_size -nnnnnew_pcnnnnnn]nnnnpc +nnnnstack_pnnnnnn]nnnnnnstack_pnnnnnn]nnnnnnstack_nnnnnnn]nnnnstacknnnnstack_sizenn]nn- stacknnnnstack_size -nnnn]nnstack_sznnnnnn]nnnnstack_size -nnnnnew_pcnnnnnn]nnnnpc +nnnn..nn.nnstack_pnnnnnn]nnnnnnstack_pnnnnnn]nnnnnnstack_nnnnnnn]nnnnstacknnnnstack_size -nnnn]nnstack_sznnnnnn]nnnnstack_size -nnnnnew_pcnnnnnn]nnnnstacknnnnstack_sizenn]nn..nn.nnstack_pnnnnnn]nnnnnnstack_pnnnnnn]nnnnnnstack_nnnnnnn]nnnnnnstack_sznnnnnn]nnnnnnnew_pcnnnnnn]nnnnnnpcnnnnnew_pcnnnnopnn]nnstacknnnnstack_size +nnnn]nnnnstack_pnnnnopnn]nnstacknnnnstack_sizenn]nnnnstack_pnnnnopnn]nnstacknnnnstack_size -nnnn]nnnnstack_nnnnnopnn]nnstack_sizennnnstack_sznnnnopnn]nnpcnnnnnew_pcnnnnopnn]nnalive *nnnn(nngasnnnnnn)nn*nn(nnstack_sizennnnnn)nnssentially, we compute the result of every single opcode in parallel, and then pick the correct one to update the state. hennalivennvariable starts off at , and if the alive variable at any point switches to zero, then all operations from that point simply do nothing. his seems horrendously inefficient, and it is, but remember the bottleneck is not computation time but latency. verything above can be parallelized. n fact, the astute reader may even notice that the entire process of running every opcode in parallel has only (n) compleity in the number of opcodes (particularly if you pre-grab the top few items of the stack into specified variables for input as well as output, which we did not do for brevity), so it is not even the most computationally intensive part (if there are more accounts or storage slots than opcodes, which seems likely, the database updates are). t the end of every  steps (or for even less information leakage every power of two of steps) we reconstitute thennalivennvariable and if we see thatnnalive  nnthen we halt.nnn an  with many participants, the database will likely be the largest overhead. o mitigate this problem, there are likely clever information leakage tradeoffs that can be made. or eample, we already know that most of the time code is read from sequential database indices. ence, one approach might be to store the code as a sequence of large numbers, each large number encoding many opcodes, and then usennbit decomposition protocolsnnto read off individual opcodes from a number once we load it. here are also likely many ways to make the virtual machine fundamentally much more efficient the above is meant, once again, as a proof of concept to show how a secret sharing  is fundamentally possible, not anything close to an optimal implementation. dditionally, we can look into architectures similar to the ones used innnscalability . techniquesnnto highly compartmentalize the state to further increase efficiency.nnpdating the nnhe  mechanism described above assumes an eisting  parties involved, and aims to be secure against any minority of them (or in some designs at least any minority less than / or /) colluding. owever, blockchain protocols need to theoretically last forever, and so stagnant economic sets do not work rather, we need to select the consensus participants using some mechanism like proof of stake. o do this, an eample protocol would work as followsnnhe secret sharing 's time is divided into "epochs", each perhaps somewhere between an hour and a week long.nnuring the first epoch, the participants are set to be the top  participants during the genesis sale.nnt the end of an epoch, anyone has the ability to sign up to be one of the participants in the net round by putting down a deposit.  participants are randomly chosen, and revealed.nn "decentralized handoff protocol" is carried out, where the  participants simultaneously split their shares among the new , and each of the new  reconstitutes their share from the pieces that they received - essentially, the eact same protocol as was used for multiplication. ote that this protocol can also be used to increase or decrease the number of participants.nnll of the above handles decentralization assuming honest participants but in a cryptocurrency protocol we also need incentives. o accomplish that, we use a set of primitives callednnverifiable secret sharingnn, that allow us to determine whether a given node was acting honestly throughout the secret sharing process. ssentially, this process works by doing the secret sharing math in parallel on two different levels using integers, and using elliptic curve points (other constructions also eist, but because cryptocurrency users are most familiar with the secpk elliptic curve we'll use that). lliptic curve points are convenient because they have a commutative and associative addition operator - in essence, they are magic objects which can be added and subtracted much like numbers can. ou can convert a number into a point, but not a point into a number, and we have the property thatnnnumber_to_point( + )  number_to_point() + number_to_point()nn. y doing the secret sharing math on the number level and the elliptic curve point level at the same time, and publicizing the elliptic curve points, it becomes possible to verify malfeasance. or efficiency, we can probably use annchellingcoin-style protocolnnto allow nodes to punish other nodes that are malfeasant.nnpplicationsnno, what do we have f the blockchain is a decentralized computer, a secret sharing  is anndecentralized computer with privacynn. he secret sharing  pays dearly for this etra property a network message is required per multiplication and per database access. s a result, gas costs are likely to be much higher than thereum proper, limiting the computation to only relatively simple business logic, and barring the use of most kinds of cryptographic calculations. calability technology may be used to partially offset this weakness, but ultimately there is a limit to how far you can get. ence, this technology will probably not be used for every use case instead, it will operate more like a special-purpose kernel that will only be employed for specific kinds of decentralized applications. ome eamples includennedical recordsnn- keeping the data on a private decentralized platform can potentially open the door for an easy-to-use and secure health information system that keeps patients in control of their data. articularly, note that proprietary diagnosis algorithms could run inside the secret sharing , allowing medical diagnosis as a service based on data from separate medical checkup firms without running the risk that they will intentionally or unintentionally epose your private details to insurers, advertisers or other firms.nnrivate key escrownn- a decentralized -of- alternative to centralized password recovery could be used for financial or non-financial applicationsnnultisig for anythingnn- even systems that do not natively support arbitrary access policies, or even -of- multisignature access, now will, since as long as they support cryptography you can stick the private key inside of a secret sharing .nneputation systemsnn- what if reputation scores were stored inside a secret sharing  so you could privately assign reputation to other users, and have your assignment count towards the total reputation of that user, without anyone being able to see your individual assignmentsnnrivate financial systemsnn- secret sharing s could provide an alternative route tonnerocashnn-style fully anonymous currency, ecept that here the functionality could be much more easily etended to decentralized echange and more comple smart contracts. usiness users may want to leverage some of the benefits of running their company on top of crypto without necessarily eposing every single one of their internal business processes to the general public.nnatchmaking algorithmsnn- find employers, employees, dating partners, drivers for your net ride on ecentralized ber, etc, but doing the matchmaking algorithm computations inside of  so that no one sees any information about you unless the algorithm determines that you are a perfect match.nnssentially, one can think of  as offering a set of tools roughly similar to that which it has been theorized would be offered bynncryptographically secure code obfuscationnn, ecept with one key difference it actually works on human-practical time scales.nnurther onsequencesnnside from the applications above, what else will secret sharing s bring articularly, is there anything to worry about s it turns out, just like with blockchains themselves, there are a few concerns. he first, and most obvious, issue is that secret sharing s will substantially increase the scope of applications that can be carried out in a completely private fashion. any advocates of blockchain technology often base a large part of their argument on the key point that while blockchain-based currencies offer an unprecedented amount of anonymity in the sense of not linking addresses to individual identities, they are at the same time the most public form of currency in the world because every transaction is located on a shared ledger. ere, however, the first part remains, but the second part disappears completely. hat we have left is essentially total anonymity.nnf it turns out to be the case that this level of anonymity allows for a much higher degree of criminal activity, and the public is not happy with the tradeoff that the technology brings, then we can predict that governments and other institutions in general, perhaps even alongside volunteer vigilante hackers, will try their best to take these systems down, and perhaps they would even be justified. ortunately for these attackers, however, secret sharing s do have an inevitable backdoor the % attack. f % of the maintainers of a secret sharing  at some particular time decide to collude, then they can uncover any of the data that is under their supervision. urthermore, this power has no statute of limitations if a set of entities who formed over half of the maintaining set of a secret sharing  at some point many years ago collude, then even then the group would be able to unearth the information from that point in time. n short, if society is overwhelmingly opposed to something being done inside of a secret sharing , there will be plenty of opportunity for the operators to collude to stop or reveal what's going on.nn second, and subtler, issue is that the concept of secret sharing s drives a stake through a cherished fact of cryptoeconomics that private keys are not securely tradeable. any protocols eplicitly, or implicitly, rely on this idea, includingnnnon-outsourceable proof of work puzzlesnn, lad amfir and avel ravchenko'snnproof of custodynn, economic protocols that use private keys as identities, any kind of economic status that aims to be untradeable, etc. nline voting systems often have the requirement that it should be impossible to prove that you voted with a particular key, so as to prevent vote selling with secret sharing s, the problem is that now you actually can sell your vote, rather simply by putting your private key into a contract inside of a secret sharing , and renting out access.nnhe consequences of this ability to sell private keys are quite far reaching - in fact, they go so far as tonnalmostnnthreaten the security of the strongest available system underlying blockchain security proof of stake. he potential concern is this proof of stake derives its security from the fact that users have security deposits on the blockchain, and these deposits can potentially be taken away if the user misacts in some fashion (double-voting, voting for a fork, not voting at all, etc). ere, private keys become tradeable, and so security deposits become tradeable as well. e must ask the question does this compromise proof of stakennortunately, the answer is no. irst of all, there are strongnnlemon-theoretic argumentsnnfor why no one would actuallynnwantnnto sell their deposit. f you have a deposit of $, to you that's worth $ minus the tiny probability that you will get hacked. ut if you try to sell that deposit to someone else, they will have a deposit which is worth $, unlessnnyounndecide to use your private key to double-vote and thus destroy the deposit. ence, from their point of view, there is a constant overhanging risk that you will act to take their deposit away, and you personally have no incentive not to do that. he very fact that you are trying to sell off your deposit should make them suspicious. ence, from their point of view, your deposit might only be worth, say, $. ou have no reason to sacrifice $ for $, so as a rational actor you will keep the deposit to yourself.nnecond, if the private key was in the secret sharing  right from the start, then by transferring access to the key you would personally lose access to it, so you would actually transfer the authority and the liability at the same time - from an economic standpoint, the effect on the system would be eactly the same as if one of the deposit holders simply had a change of personality at some point during the process. n fact, secret sharing s may even improve proof of stake, by providing a more secure platform for users to participate in decentralized stake pools even in protocols likennendermintnn, which do not natively support such functionality.nnhere are also other reasons why the theoretical attacks that secret sharing s make possible may in fact fail in practice. o take one eample, consider the case of non-outsourceable puzzles, computational problems which try to prove ownership of a private key and a piece of data at the same time. ne kind of implementation of a non-outsourceable puzzle, used bynnermacoinnn, involves a computation which needs to "bounce" back and forth between the key and the data hundreds of thousands of times. his is easy to do if you have the two pieces of data on the same piece of hardware, but becomes prohibitively slow if the two are separated by a network connection - and over a secret sharing  it would be nearly impossible due to the inefficiencies. s a result, one possible conclusion of all this is that secret sharing s will lead to the standardization of a signature scheme which requires several hundred millions of rounds of computation - preferably with lots and lots of serial multiplication - to compute, at which point every computer, phone or internet-of-things microchip would have a built-in  to do it trivially, secret sharing s would be left in the dust, and we would all move on with our lives.nnow ar waynno what is left before secret sharing  technology can go mainstream n short, quite a bit, but not too much. t first, there is certainly a moderate amount of technical engineering involved, at least on the protocol level. omeone needs to formalize an  implementation, together with how it would be combined with an  implementation, probably with many restrictions for efficiency (eg. hash functions inside of  arennverynnepensive, so erkle tree storage may disappear in favor of every contract having a finite number of storage slots), a punishment, incentive and consensus framework and a hypercube-style scalability framework, and then release the protocol specification. rom that point, it's a few months of development in ython (ython should be fine, as by far the primary bottleneck will be network latency, not computation), and we'll have a working proof of concept.nnecret sharing and  technology has been out there for many years, and academic cryptographers have been talking about how to build privacy-preserving applications using -of--based primitives and related technologies such as private information retrieval for over a decade. he key contribution made by itcoin, however, is the idea that -of- frameworks in general can be much more easily bootstrapped if we add in an economic layer.  secret sharing  with a currency built in would provide incentives for individuals to participate in maintaining the network, and would bootstrap it until the point where it could be fully self-sustaining on internal applications. hus, altogether, this technology is quite possible, and not nearly so far away it is only a matter of time until someone does it.