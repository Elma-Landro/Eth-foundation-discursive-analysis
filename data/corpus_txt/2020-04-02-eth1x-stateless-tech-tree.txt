Titre: The 1.x Files: The Updated Stateless Tech Tree\nAuteur: Griffin Ichiba Hotchkiss\nDate: April 2, 2020\nURL: https://blog.ethereum.org/2020/04/02/eth1x-stateless-tech-tree\nCatégorie: Non catégorisé\n\n==================================================\n\nhe pdated tateless thereum ech reennpologies for the delay in releasing this post there have been some unavoidable distractions in my life recently, as 'm sure there have been in yours.  hope that you are making the best of your circumstances, whatever they may be, and implore you to turn your empathy up to eleven for the net few months, and to help your community's at-risk people in whatever capacity you can pray.nnith that said, let's talk about tateless thereum, and the changes to the ech ree!nnraphically, the tree has been completely re-worked, but if you were to compare it tonnthe originalnn, you'd notice that a lot of the content is the same. or the sake of completeness and avoidance of confusion, we'll still go through everything in this post, though, so feel free to close that tab you just opened in the background. ithout further ado,  present to you the updated tateless ech reennach major milestone in pink represents a roughly defined category that must be "solved" before more advanced ones. hese are intentionally a little vague, and don't represent anything like specific s or unified features, although some of them could eventually be defined as such.nnmaller elements of the tree in purple are more specific dependencies that will lead to the major milestones being "unlocked". he purple ones arennrequirednnin the sense that they need to be fully understood before the milestone can be considered finished, but they don't necessarily need to be implemented or accepted. or eample, it is possible that after more research, we find that code merkleization doesn't reduce witness sizes sufficiently to justify the time and effort it would take to implement it we would then consider it 'finished', because it no longer needs to be investigated.nns you might have guessed already, items in green are the "side quests" that would theoretically be useful in tateless thereum, but which might not be the best use of the researcher's limited time and effort. here are likely more of these to be discovered along the way 'll add them as needed.nndditionally, we have elements in yellow that fall into the category of tools. hese are yet-uncreated software tools that will help to validate assumptions, test implementations, and more generally make the work go faster. deally these tools will be of high enough quality and properly maintained-- enough to be valuable to the larger developer ecosystem even outside of the tateless thereum contet.nnlternative ync rotocolnnne important takeaway from the summit in aris was thatnnsync is the first major milestone in tateless thereumnn. pecifically, we must find a way for new nodes to fetch the current state trie without relying on the network primitivennetodeatann. ntil we have a reliable alternative to this network primitive (beam sync and fast sync are both based on it), efforts to build tateless thereum will be impeded, and potentially even counterproductive. t's worth digging in here a bit to eplain why this is such a problem. f you're not familiar with the fundamentals of the thereum state,  recommend checking outnnmy previous postnnin this series on the subject.nnet's do some jargon-busting first. here isn't really a special technical definition for the term "network primitive" in this contet, it's just a hip way of saying "the basic grammar of thereum network communication". ne client asks "hey, what's the data for the node with hashnnfoonn nd a peer can respond "oh, it'snnbeefnn. or most cases, the response will contain additional hashes of child nodes in the trie, which can then be asked for in the same manner. his game of marco-polo continues until the requester is satisfied, usually after having asked for each of the ~ million nodes in the current state trie individually.nnyncing this way can still be fast, because a client can of course multi-task, and ask many other full nodes for different pieces of the state at the same time. ut there is a more fundamental problem here in the way the primitive works the 'leechers' requesting state get to do it on their own terms, and they can only get what they need from the 'seeders', i.e. full nodes with the complete state. his asymmetric relationship is just the way things work right now, and it works well enough because of two related facts about the network irst, there are a sufficient number of full nodes actively serving state by request. econd, anyone requesting state will eventually turn into a full node, so the demand for state is self-limiting.nnow we can see why this is a problem for tateless thereum in a stateless paradigm, nodes that aren't keeping the state data they request will need to justnnkeep requesting data indefinitelynn. f running a stateless node is easier than running a full node (it is), we'd epect the number of stateless nodes to grow faster than the number of full nodes, until eventually the state is unable to propagate fast enough throughout the network. h oh.nne don't have time to go into further detail here, so 'll refer you tonniper's write-up on the problemnn, and then we can move on to the emerging solutions, which are all different approaches tonnimproving the state sync protocolnn, to either make the problem less pronounced, or solve it entirely. ere are the  most promising alternative sync protocolsnnthereum napshot rotocol ()nn. e've talked about this previously, but  referred to it as "state tiling". ecently, it was morennverbosely described by eternnin the devpp repo. nap breaks the state into a handful of large chunks and proofs (on the order of , trie nodes) that can be re-assembled into the full state.  syncing node would request a sub-section of the state from multiple nodes, and in a short amount of time have an almost valid picture of the state stitched together from ~ different similar state roots. o finish, the client ‘patches up’ the chunk by switching back tonngetodeatannuntil it has a valid state.nnire ueen's ync.nnot much has changed since this was written about in the original tech tree article, ecept for the name, which is a combination of "nnfirehosenn" and "nned ueen'snn" sync. hese are very similar proposals to replacenngetodeatannwith an alternative set of primitives for various aspects of state.nnerry-go-round.nnhis is a new idea for syncnneplained at a high level in ethresear.chnnand morennconcretely described in notesnn. n merry-go-round sync, the whole state is passed around in a predetermined order, so that all participants gossip the same pieces of the state trie at the same time. o sync the whole state, one must complete a full “revolution” on the merry-go-round, covering all parts of the state. his design has some useful properties. irst, it allows new nodes joining to contribute immediately to state propagation, rather than only becoming useful to the network after a completed sync. econd, it inverts the current model of ‘leecher-driven sync’ whereby those with no data may request pieces of state from full nodes at will. ather, new syncing nodes in merry-go-round sync know what parts of state are being offered at a given time, and adjust accordingly.nnhe last sync method worth mentioning isnnbeam syncnn, which is now supported by not one, butnntwonnalternative clients. eam sync still relies onnngetodeatann, but it offers an ideal entry point for eperimentation and data collection for these alternative sync methods. t's important to note that there are many unknowns about sync still, and having these separate, independently developed approaches to solving sync is important. he net few months could be thought of as a sync hackathon of sorts, where ideas are prototyped and tested out. deally, the best aspects of each of these alternative sync protocols can be molded into one new standard for tateless thereum.nnitness pec rototypennhere is anndraft specificationnnin the tateless thereum specs repo that describes at a high level the structure of a block witness, and the semantics of building and modifying one from the state trie. he purpose of this document is to define witnesses without ambiguity, so that implementers, regardless of client or programming language, may write their own implementation and have reasonable certainty that it is the same thing as another, different implementation.nns mentioned in thennlatest call digestnn, there doesn't seem to be a downside to writing out a reference implementation for block witnesses and getting that into eisting clients for testing.  witness prototype feature on a client would be something like an optional flag to enable, and having a handful of testers on the network producing and relaying witnesses could provide valuable insight for researchers to incorporate into subsequent improvements.nnwo things need to be "solved" before witnesses are resilient enough to be considered ready for widespread use.nnitness ndeing.nnhis one is relatively straightforward we need a reliable way of determining which witness corresponds to which block and associated state. his could be as simple as putting annwitnessashnnfield into the block header, or something else that serves the same purpose but in a different way.nntateless  alidationnn. his is an interesting early problemnnthoroughly summarized on the ethresearch forumsnn. n summary, clients need to quickly check if incoming transactions (waiting to be mined into a future block) are at leastnneligiblennto be included in a future block. his prevents attackers from spamming the network with bogus transactions. he current check, however, requires accessing data which is a part of the state, i.e. the sender's nonce and account balance. f a client is stateless, it won't be able to perform this check.nnhere is certainly more work than these two specific problems that needs to be done before we have a working prototype of witnesses, but these two things are what absolutely need to be 'solved' as part of bringing a viable prototype to a beam-syncing node near you.nnnns in the original version of the tech tree, some changes will need to happen inside the  abstraction. pecifically, witnesses need to be generated and propagated across the network, and that activity needs to be accounted for in  operations. he topics tied to this milestone have to do with what those costs and incentives are, how they are estimated, and how they will be implemented with minimal impact on higher layers.nnitness gas accounting.nnhis remains unchanged from previous articles. very transaction will be responsible for a small part of the full block’s witness. enerating a block’s witness involves some computation that will be performed by the block’s miner, and therefore will need to have an associated gas cost, paid for by the transaction’s sender.nnode erkleization.nnne major component of a witness is accompanying code. ithout this feature, a transaction that contained a contract call would require the full bytecode of that contract in order to verify its codeash. hat could be a lot of data, depending on the contract. ode ‘merkleization’ is a method of splitting up contract bytecode so thatnnonly the portion of the code callednnis required to generate and verify a witness for the transaction. his is one technique of dramatically reducing the average size of witnesses, but it has not been fully investigated yet.nnhe  / ersionless thereum changes have been removed from the 'critical path' of tateless thereum. hese are still potentially beneficial features for thereum, but it became clear during the summit that their merits and particularities can and should be discussed independently of the tateless goals.nnhe ransition to inary riennwitching thereum’s state to a inary rie structure is key to getting witness sizes small enough to be gossiped around the network without running into bandwidth/latency issues. heoretically the reduction should be over -fold, but in practice that number is a little less dramatic (because of the size of contract code in witnesses, which is why code merkleization is potentially important).nnhe transition to a completely different data representation is a rather significant change, and enacting that transition through hard-fork will be a delicate process. wo strategies outlined in the previous article remain unchangednnrogressivenn. he current heary state trie woud be transformed piece-by-piece over a long period of time. ny transaction or  eecution touching parts of state would by this strategy automatically encode changes to state into the new binary form. his implies the adoption of a ‘hybrid’ trie structure that will leave dormant parts of state in their current heary representation. he process would effectively never complete, and would be comple for client developers to implement, but would for the most part insulate users and higher-layer developers from the changes happening under the hood in layer .nnlean-cutnn. his strategy would compute a fresh binary trie representation of the state at a predetermined time, then carry on in binary form once the new state has been computed. lthough more straightforward from an implementation perspective, a clean-cut requires coordination from all node operators, and would almost certainly entail some (limited) disruption to the network, affecting developer and user eperience during the transition.nnhere is, however, a new proposal for the transition, which offers a middle ground between the progressive and clean-cut strategies. t isnnoutlined in full on the ethresearch forumsnn.nnverlay.nnew values from transactions after a certain time are stored directly in a binary tree sitting “on top” of the heary, while the “historical” heary tree is converted in the background. hen the base layer has been fully converted, the two can be merged.nnne additional consideration for the transition to a binary trie is the database layouts of clients. urrently, all clients use the 'naive' approach to the state trie, storing each node in the trie as a key, value] pair where the hash of the node is the key. t is possible that the transition strategy could be an opportunity for clients to switch to an alternative database structure, following the eample of turbo-geth.nnrue tateless thereumnnhe final pieces of the tree come together after the witness prototype has been tested and improved, the necessary changes to the  have been enacted, and the state trie has become binary. hese are the more distant quests and side quests which we know must be completed eventually, but it's likely best not to think too deeply about until more pressing matters have been attended to.nnompulsory itnesses.nnitnesses need to be generated by miners, and right now it's not clear if spending that etra few milliseconds to generate a witness will be something miners will seek to avoid or not. art of this can be offset by tweaking the fees that miners get to keep from the partial witnesses included with transactions, but a sure-fire way is to just make witnesses part of the core thereum protocol. his is a change that can only happen after we'rennsurenneverything is working the way it's supposed to be, so it's one of the final changes in the tree.nnitness hunking.nnnother more distant feature to be considered is the ability for a stateless network to pass around smaller chunks of witnesses, rather than entire blocks. his would be especially valuable for partial-state nodes, which might choose to 'watch over' the parts of state they're interested in, and then rely on complementary witness chunks for other transactions.nnistorical ccumulators.nnriginally conceived as some sort of magic moon math zero-knowledge scheme, a historical accumulator would make verifying a historical witness much easier. his would allow a stateless node to perform checks and queries on, for eample, the historical balances of an account it was interested, without actually needing to fetch a specific piece of archived state.nn hain ata.nnlthough the idea of an thereum data delivery network fornnstatennhas been more or less abandoned, it would still be quite useful and far easier to implement one for historical chain data such as transaction receipts. his might be another approach to enabling stateless clients to have on-demand access to historical data that might ordinarily be gotten from an archive node.nntay afe, and tay unednnhanks for reading, and thank you for the many warm positive comments 've gotten recently about these updates.  have something more...nnmagicalnnplanned for subsequent posts about the tateless thereum research, which 'll be posting intermittently on the ellowship of the thereum agician's forum, and on this blog when appropriate. ntil net time, keep your social distance, and wash your hands often!nns always, if you have feedback, questions, or requests for topics, please gichiba or ancock on twitter.