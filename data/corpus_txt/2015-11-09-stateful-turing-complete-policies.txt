Titre: Stateful Turing-Complete Policies\nAuteur: Vitalik Buterin\nDate: November 9, 2015\nURL: https://blog.ethereum.org/2015/11/09/stateful-turing-complete-policies\nCatégorie: Non catégorisé\n\n==================================================\n\nne of the major security challenges of the internet over the last twenty years has consistently been the rather simple problem of securing user accounts. ight now, users have accounts with hundreds of websites, and dozens of passwords, leading tonnlargennnumbersnnofnnhacksnnas individual websites, often run by people not particularly skilled in the finer points of cryptography and internet security, find themselves eploited by increasingly clever hackers, and users frequently deal with the compleity of remembering hundreds of passwords by eithernnmaking them simplennornnmaking them all the samenn- with often verynnunfortunate resultsnn. ver time, a patchwork of ad-hoc solutions has certainly developed, including the use of one's email account as a universal backup, and "password manager" software like astpass, though at high cost such solutions either retain much of the underlying compleity of password-bsaed access or give centralized companies very high degrees of control over your online life.nnhere are many calls tonngetnnridnnofnnpasswordsnn, but the question is what do we replace them with here are many ideas, ranging from "one single password to rule them all" to smartphone authentication to specialized hardware devices and biometrics and all sorts of multi-factor -of- policies, but even these more comple constructions so far have typically been application-specific many banks now give you a specialized access device to log into your bank account, but if you trust its security you cannot also use it to access your email. n general, we see that the problem of how to best manage user access control and minimize key loss and theft risks is comple enough that it never will be solved "once and for all", and so the best way to solve it is to allow a free market of solutions to flourish and let each user pick which ones work best for them however, the way to make that actually happen is bynnunbundlingnnthe "access control solutions" market from the "services" market. hat is to say, eactly what we are to a large etentnnnotnndoing right now.nnhe hardware access device to my  bank account. emind me, why can't  also use this to secure my domains on amecheapnno how do we do that he first step is to introduce some well-placed use of the ultimate abstraction uring-complete code. ather than, at the protocol level, allowing users to specify a password, or providing a pre-selected set of providers, or even a standard which relies on talking to a server of the user's choice, allow access policies to be specified in code to be eecuted in a deterministic virtual machine (where the  is a good a start as any). ode can include digital signature verifications usingnnanynncryptographic algorithm (so you get forward-compatibility with quantum-safe crypto for free), potentially including keys held on the user's computer, keys directly derivednnfrom a passwordnn, keys held on a hardware device or any arbitrary policy including any combination of the above. his way, innovation can happen in access-control mechanismsnnwithout any neednnfor websites (or other systems requiring authentication) to do anything to accomodate new changes. dditionally, the system neatly allowsnnorganizationsnnto use the scheme using multi-person access controls right away, without any further need for integration.nnhe net step is uring-complete operation-dependent code. or many applications, you want the ability to authorize some users to carry out some operations but not others for eample, you may want to authorize a sysadmin to change the  address that a domain name points to, but not sell the domain outright. o accomodate this, the abstraction needs to change.  simple "uring-complete-code as signature" setup might have the following formnnnn(nncode, server-provided nonce ++ signaturenn)nnnnnnnnherennnnis a virtual machine that runs code, taking a server-provided nonce and a signature as input, and the verification check is to see whether or not the output is .  simple eample ofnncodennthat could be put in is an elliptic curve digital signature verifier. o allow different authorization requirements depending on the operation, you wantnnnn(nncode, server-provided nonce ++ operation_data ++ signaturenn)nnnnnnnn signature would need to be provided with every operation that the user wants to carry out (this has the benefit of providing definite, third-party-verifiable, proof that an operation was authorized) the operation data (imagine the function name and the arguments encoded in annnthereum-style nn) would be added as an argument for the virtual machine, and the signature would have to be over both the nonce and the operation data.nnhis gets you quite far, but in some cases not far enough. ne simple eample is this what if you want to give someone permission to withdraw small amounts of money but not large amounts, ie. a withdrawal limit n that case, the problem that you must overcome is simple what if someone limited by a withdrawal cap of $ tries to evade it by simply running a script to withdraw $ over and over again o solve this, you need a smarter withdrawal limit essentially, something like "maimum $ per day". nother natural case is key revocation if a key gets hacked or lost, you want to replace it, and you want to make sure that the world finds out that your policy was changed so that attackers cannot try to impersonate you under your old policy.nno get past this last hump, we need to go one step further we need uring-complete operation-dependentnnstatefulnnpolicies that is to say, operations should be able to change the state of the policy. nd here is where not just cryptography, but specifically blockchains come in. f course, you could just have a central server manage the whole thing, and many people are perfectly fine with trusting a central server, butnnblockchains are moderately valuablennhere because they are more convenient, provide a credible story of neutrality, and are easier to standardize around. ltimately, as it would be quite harmful for innovation to permanently choose "one blockchain to rule them all", the thing that we want to standardize is a mechanism by which users can download modules to supportnnanynnblockchain or centralized solution as they wish.nnor blockchain-based applications, having a stateful policy enforced right on the blockchain makes natural sense there is no need to involve yet another special class of intermediaries, and people can start doing it right now. he abstraction of an "account" that thereum offers makes it etremely easy to work with this approach if your application works with simple users holding private keys, it also works for just about every kind of individual, multiparty, hardware-driven, military-grade or whatever other policy users will come up with in the future.nnor other applications, users may want privacy, both in the state-changing operations that they perform and even in the nature of their policy at any one particular time. or this reason, you likely want a solution likennawknn, where the blockchain still ensures the security of the process but, thanks to the wonders of zero-knowledge-proof technology,nnknows nothing about what is being securednn before awk is implemented, simpler forms of cryptography such as ring signatures may suffice.nnther pplicationsnnccount security is the first, and most basic, application for the concept of code as policy, there are also others. ne simple one is a domain name registry. nename, one of the popular "decentralized name registry" services, is currently planning on implementing a feature where top-level domains can choose fee policies for subdomains based on the number of letters, consonants and vowels. his is useful, but of course economically ugly there are definitely hundreds of characteristics other than letters, consonants and vowels that can influence a domain name price, and people may even want to eperiment with other registration strategies likenndifferent types of auctionsnn.nnnce again, an even nicer solution is to apply some simple modularity let people create their own namespace in stateful uring-complete code. f you are doing this on a platform where stateful uring-complete code eists, you can just allow an address to control a subdomain, and then, tada, you support stateful uring-complete subdomain policies already. his is the essence of object-oriented programming epose an interface, and allow other objects, which can have arbitrarily comple internal code, satisfy that interface.nn further one is private stock trading. articularly in the case of privately held companies, stock trading is not, and cannot, be completely free and unrestricted the way that trading of cryptocurrencies is companies often want to have restrictions such asnniving employees shares and allowing them to sell them only after some period of timennequiring new shareholders to be approved by eisting shareholders, with the possibility of such approvals coming with a cap on how many shares can be owned by that specific holdernnorced-buyout proceduresnnestricting the maimum rate at which stocks are sold (ie. withdrawal limits) or requiring waiting periods or offering specific other holders right of first refusalnnure, you can create a private blockchain-based stock trading platform for one client, and provide the restrictions that that one client wants. ut what if other clients want different restrictions ou may as well nip the problem in the bud, at least at the "core application layer", and solve it once and for all by... allowing each individual stock, represented as a sub-currency, to havennrestrictions representednnas stateful uring-complete code.nnhis functionality can be represented in the "token"  by etending it, for eample, as followsnngetinimumalance(account)nn get the minimum balance that an account can hold at the current timenngetaimumalance(account)nn get the maimum balance that an account can hold at the current timennn short, applications don't have policies applications interact withnnobjectsnn(user accounts, currencies, etc), and objects have policies. lternatively, even shorternnre you building a blockchain-based financial derivatives application, and someone is asking you to add a feature to allow a vote between multiple data feed providers instead of just one on't even think about it instead, just set one data feed provider address, and allow users to come up with their own policies the upside is that whatever code they use or write, they'll be able to use to more securely provide data feeds for the arbitration dapp as well. re you building a  system, and someone is asking you to introduce support for specific auction types for subdomains on't to it at the root  level instead, allow subdomains to be addresses, and allow users to invent their own auction algorithms whatever algorithms they invent, they'll be able to use for their registry for decentralized chat usernames as well.nnhis is the benefit of abstraction account security policy design can become a self-contained field of study to itself, and whatever new solutions eist can instantly be applied everywhere. ome people will want to trust a third party others will want to have a multi-signature authorization between five of their own different devices, and some will want a key to themselves with the option for three of five friends to come together to reset the key to a new one. ome will want an access policy where, if they make no transactions within twelve months, they are presumed dead and a lawyer will gain access in order to be able to eecute on their will - fornnallnnof their digital assets. nd some will want a policy which gives one key full control for applications that declare themselves low-security but two of three keys for applications that declare themselves high-security. ame registry pricing policy design can become self-contained as well - as can digital asset ownership restriction policy, a field that would interest everyone from small and large traditional corporations to community-based s. nd that is the power of a stateful uring-complete code.