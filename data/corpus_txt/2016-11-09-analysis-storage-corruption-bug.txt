Titre: Analysis of Storage Corruption Bug\nAuteur: Christian Reitwiessner\nDate: November 9, 2016\nURL: https://blog.ethereum.org/2016/11/09/analysis-storage-corruption-bug\nCatégorie: Non catégorisé\n\n==================================================\n\nhis blog post provides an update on our findings following the discovery of the storage corruption bug last week. n summary, the bug was much less severe than we initially thought. he small number of affected contracts we found is either only eploitable by the owner, or the eploit can only cause a disruption in the user interface and not in the actual contract logic. ll eploitable contracts/dapps we reviewed can be fied without having to upgrade the contract itself. f course, please still check your contracts to be safe.nnollowing the discovery of the storage corruption bug in the olidity compiler and the realization that it may have serious effects on already-deployed contracts that cannot be updated, we started analyzing how common the bug is and how eploitable contracts can be addressed.nne focused on contracts with source code published on etherscan because important or popular smart contracts usually have their source code published there in order to gain trust from their users, who can then verify the compilation. urthermore, if the source code is not available, it is also much harder for an attacker to find a suitable eploit. inally, contracts that are privately used (and thus do not require publishing their source code) usually check that they are called from a certain address, and thus an attacker has no means to write to their storage.nnn order to automate the process of checking all contracts on etherscan, we created a modified version of the olidity compiler that can automatically detect the conditions for triggering the bug. his technique has already reduced the number of potentially vulnerable contracts to . e then manually checked those contracts for potential corruption of storage that would make them vulnerable to attacks.nnt turns out that only ten contracts were vulnerable, so we were able to contact most of the contract owners/developers. even out of ten of those contracts are only eploitable by the owner in that they are allowed to change certain parameters outside their permitted range, or allowed to unlock a previously locked contract. ne contract is eploitable by unprivileged users but have other major flaws in its design. he other two contracts found to be eploitable by unprivileged users either provided no advantages if eploited or only affected the user interface.nnhy are only so few contracts eploitablennirst, let us define what we mean by "eploitable"nnhe storage corruption bug is eploitable if it can be used to modify a variable in storage in a way that would not be possible without the bug, and this modification has consequences for the behaviour and use of the smart contract. or eample, we do not consider a contract eploitable in the following situationsnnhe same account would be able to overwrite the variable in the same state of the contract by regular means.nnverwriting can only happen at construction time (note that we did not check whether overwriting occurred at that time).nnverwriting is only triggered in unlikely situations where the contract logic was broken anyway (for eample, a -bit counter that is incremented once per block, oveflows).nnariables can be overwritten that are unused in the smart contract and look non-critical, but may be part of the public interface.nnhy is this critical bug only eploitable in so few casesnnt is a combination of the following factors that together multiply and dramatically reduce the probability of eploitability.nnince small types only provide an advantage in very rare cases, they are seldomly used.nnmall types must be adjacent to each other in storage – a single large type in between them prevents the bug from being triggered.nntate variables are often assigned one after the other, which removes the corruption at the second assignment.nnhe combination of "address" and "bool" is most common among the cases that are left, but here, the address variable is often an "owner" that is assigned fromnnmsg.sendernnand thus not eploitable. ven if the owner can be changed, the flag is often a flag that can be still be set by the owner through other means.nnow to fi affected contractsnn large majority of the eploitable contracts are only eploitable by the contract owner, administrator or developer, particularly though a single function that allows the owner to be changed. he eploit allows a further escalation of privileges for the owner. n order to prevent the owner from taking advantage of this eploit, a proy contract can be installed between the owner and the affected contract. his proy contract forwards calls from the owner, but disallows calling the eploitable functions. f calling the eploitable functions is still necessary, the proy contract can prevent malicious data from being forwarded to the contract.nnf you have specific questions or concerns regarding your contracts, please contact us onnngitternn.nn     nnhe statements in this post are recommendations to address the storage corruption bug in the olidity compiler. s you know, we are working in an emergent and evolving technical space. he same elements that make this work eciting – the innovation, the impact, the growing understanding of how contracts function – are the same ones that make it risky. f you choose to implement the recommendations in this post and continue to participate, you should make sure you understand how it impacts your specific contract and you should understand that there are risks involved. y choosing to implement these recommendations, you alone assume the risks of the consequences.