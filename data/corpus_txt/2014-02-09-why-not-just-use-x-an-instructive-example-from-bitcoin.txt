Titre: Why Not Just Use X? An Instructive Example from Bitcoin\nAuteur: Vitalik Buterin\nDate: February 9, 2014\nURL: https://blog.ethereum.org/2014/02/09/why-not-just-use-x-an-instructive-example-from-bitcoin\nCatégorie: Non catégorisé\n\n==================================================\n\nitcoin developer regory awell writes the followingnnon edditnnhere is a design flaw in the itcoin protocol where its possible for a third party to take a valid transaction of yours and mutate it in a way which leaves it valid and functionally identical but with a different transaction . his greatly complicates writing correct wallet software, and it can be used abusively to invalidate long chains of unconfirmed transactions that depend on the non-mutant transaction (since transactions refer to each other by tid).nnhis issue arises from several sources, one of them being pen’s willingness to accept and make sense of signatures with invalid encodings.  normal  signature encodes two large integers, the encoding isn’t constant length— if there are leading zeros you are supposed to drop them.nnt’s easy to write software that assumes the signature will be a constant length and then leave etra leading zeros in them.nnhis is a very interesting cautionary tale, and is particularly important because situations like these are part of the reason why we have made certain design decisions in our development philosophy. pecifically, the issue is this many people continue to bring up the point that we are in many places unnecessarily reinventing the wheel, creating our own serialization format,nnnn, instead of using the eistingnnprotobufnnand we’re building an application-specific scripting language instead of “just using ua”. his is a very valid concern not-invented-here syndrome is anncommonly-used pejorativenn, so doing such in-house development does require justification.nnnd the cautionary tale  quoted above provides precisely the perfect eample of the justification that  will provide. ternal technologies, whether protobuf, ua or pen, are very good, and have years of development behind them, but in many cases they were never designed with the perfect consensus, determinism and cryptographic integrity in mind that cryptocurrencies require. he pen situation above is the perfect eample aside from cryptocurrencies, there really is no other situations where the fact that you can take a valid signature and turn it into another valid signature with a different hash is a significant problem, and yet here it’s fatal. ne of our core principles in thereum is simplicity the protocol should be as simple as possible, and the protocol should not contain any black boes. very single feature of every single sub-protocol should be precisely % documented on the whitepaper or wiki, and implemented using that as a specification (ie. test-driven development). oing this for an eisting software package is arguably almost as hard as building an entirely new package from scratch in fact, it may even be harder, since eisting software packages often have more compleity than they need to in order to be feature-complete, whereas our alternatives do not – read thennprotobuf specnnand compare it to thenn specnnto understand what  mean.nnote that the above principle has its limits. or eample, we are certainly not foolish enough to start inventing our own hash algorithms, instead using the universally acclaimed and well-vetted , and for signatures we’re using the same old secpk as itcoin, although we’re using  to store the v,r,s triple (the v is an etra two bits for public key recovery purposes) instead of the pen buffer protocol. hese kinds of situations are the ones where “just using ” is precisely the right thing to do, because  has a clean and well-understood interface and there are no subtle differences between different implementations. he  of the empty string is cd...a in ++, in ython, and in avascript there’s no debate about it. n between these two etremes, it’s basically a matter of finding the right balance.