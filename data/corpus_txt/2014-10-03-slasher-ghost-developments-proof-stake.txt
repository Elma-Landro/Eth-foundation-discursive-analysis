Titre: Slasher Ghost, and Other Developments in Proof of Stake\nAuteur: Vitalik Buterin\nDate: October 3, 2014\nURL: https://blog.ethereum.org/2014/10/03/slasher-ghost-developments-proof-stake\nCatégorie: Non catégorisé\n\n==================================================\n\npecial thanks to lad amfir and ack ess for ongoing research and discussions on proof-of-stake algorithms and their own input into lasher-like proposalsnnne of thennhardest problems in cryptocurrencynndevelopment is that of devising effective consensus algorithms. ertainly, relatively passable default options eist. t the very least it is possible to rely on a itcoin-like proof of work algorithm based on either annrandomly-generated circuit approachnntargeted for specialized-hardware resitance, or failing that simple , and ournneisting  optimizationsnnallow for such an algorithm to provide block times of  seconds. owever, proof of work as a general category hasnnmany flawsnnthat call into question its sustainability as an eclusive source of consensus % attacks from altcoin miners, eventual  dominance and high energy inefficiency are perhaps the most prominent. ver the last few months we have become more and more convinced that some inclusion of proof of stake is a necessary component for long-term sustainability however, actually implementing a proof of stake algorithm that is effective is proving to bennsurprisingly complenn.nnhe fact that thereum includes a uring-complete contracting system complicates things further, as it makes certain kinds of collusion much easier without requiring trust, and creates a large pool of stake in the hands of decentralized entities that have the incentive to vote with the stake to collect rewards, but which are too stupid to tell good blockchains from bad. hat the rest of this article will show is a set of strategies that deal with most of the issues surrounding proof of stake algorithms as they eist today, and a sketch of how to etend our current preferred proof-of-stake algorithm,nnlashernn, into something much more robust.nnistorical verview roof of stake and lashernnf you're not yet well-versed in the nuances of proof of stake algorithms, first readnnhttps//blog.ethereum.org////stake/nnhe fundamental problem that consensus protocols try to solve is that of creating a mechanism for growing a blockchain over time in a decentralized way that cannot easily be subverted by attackers. f a blockchain does not use a consensus protocol to regulate block creation, and simply allows anyone to add a block at any time, then an attacker or botnet with very many  addresses could flood the network with blocks, and particularly they can use their power to performnndouble-spend attacksnn- sending a payment for a product, waiting for the payment to be confirmed in the blockchain, and then starting their own "fork" of the blockchain, substituting the payment that they made earlier with a payment to a different account controlled by themselves, and growing it longer than the original so everyone accepts this new blockchain without the payment as truth.nnhe general solution to this problem involves making a block "hard" to create in some fashion. n the case of proof of work, each block requires computational effort to produce, and in the case of proof of stake it requires ownership of coins - in most cases, it's a probabilistic process where block-making privileges are doled out randomly in proportion to coin holdings, and in more eotic "negative block reward" schemes anyone can create a block by spending a certain quantity of funds, and they are compensated via transaction fees. n any of these approaches, each chain has a "score" that roughly reflects the total difficulty of producing the chain, and the highest-scoring chain is taken to represent the "truth" at that particular time.nnor a detailed overview of some of the finer points of proof of stake, see the above-linked article for those readers who are already aware of the issues  will start off by presenting a semi-formal specification for lashernnlocks are produced by miners in order for a block to be valid it must satisfy a proof-of-work condition. owever, this condition is relatively weak (eg. we can target the mining reward to something like . the genesis supply every year)nnvery block has a set ofnndesignated signersnn, which are chosen beforehand (see below). or a block with valid o to be accepted as part of the chain it must be accompanied by signatures from at least two thirds of its designated signers.nnhen blocknnnnis produced, we say that the set ofnnpotential signersnnof blocknn + nnis the set of addresses such thatnnsha(address + block].hash)  block].balance(address) * nnwherennnnis a difficulty parameter targeting  signers per block (ie. if blocknnnnhas less than  signers it goes down otherwise it goes up). ote that the set of potential signers is very computationally intensive to fully enumerate, and we don't try to do so instead we rely on signers to self-declare.nnf a potential signer for blocknn + nnwants to become a designated signer for that block, they must send a special transaction accepting this responsibility and that transaction must get included between blocksnn + nnandnn + nn. he set of designated signers for blocknn + nnis the set of all individuals that do this. his "signer must confirm" mechanism helps ensure that the majority of signers will actually be online when the time comes to sign. or blocks  ... , the set of signers is empty, so proof of work alone suffices to create those blocks.nnhen a designated signer adds their signature to blocknn + nn, they are scheduled to receive a reward in blocknn + nn.nnf a signer signs two different blocks at heightnn + nn, then if someone detects the double-signing before blocknn + nnthey can submit an "evidence" transaction containing the two signatures, destroying the signer's reward and transferring a third of it to the whistleblower.nnf there is an insufficient number of signers to sign at a particular block heightnnhnn, a miner can produce a block with heightnnh+nndirectly on top of the block with heightnnh-nnby mining at an  higher difficulty (to incentivize this, but still make it less attractive than trying to create a normal block, there is a  higher reward). kipping over two blocks has higher factors of  diff and  reward, three blocks  and , etc.nnssentially, by eplicitly punishing double-signing, lasher in a lot of ways, although not all, makes proof of stake act like a sort of simulated proof of work. n important incidental benefit of lasher is the non-revert property. n proof of work, sometimes after one node mines one block some other node will immediately mine two blocks, and so some nodes will need to revert back one block upon seeing the longer chain. ere, every block requires two thirds of the signers to ratify it, and a signer cannot ratify two blocks at the same height without losing their gains in both chains, so assuming no malfeasance the blockchain will never revert. rom the point of view of a decentralized application developer, this is a very desirable property as it means that "time" only moves in one direction, just like in a server-based environment.nnowever, lasher is still vulnerable to one particular class of attack long-range attacks. nstead of trying to start a fork from ten blocks behind the current head, suppose that an attacker tries to start a fork starting from ten thousand blocks behind, or even the genesis block - all that matters is that the depth of the fork must be greater than the duration of the reward lockup. t that point, because users' funds are unlocked and they can move them to a new address to escape punishment, users have no disincentive against signing on both chains. n fact, we may even epect to see a black market of people selling their old private keys, culminating with an attacker single-handedly acquiring access to the keys that controlled over % of the currency supply at some point in history.nnne approach to solving the long-range double-signing problem is transactions-as-proof-of-stake, an alternative o solution that does not have an incentive to double-sign because it's the transactions that vote, and there is no reward for sending a transaction (in fact there's a cost, and the reward is outside the network) however, this does nothing to stop the black key market problem. o properly deal with that issue, we will need to rela a hidden assumption.nnubjective coring and rustnnor all its faults, proof of work does have some elegant economic properties. articularly, because proof of work requires an eternally rivalrous resource, something with eists and is consumed outside the blockchain, in order to generate blocks (namely, computational effort), launching a fork against a proof of work chain invariably requires having access to, and spending, a large quantity of economic resources. n the case of proof of stake, on the other hand, the only scarce value involved is value within the chain, andnnbetweennnmultiple chains that value is not scarce at all. o matter what algorithm is used, in proof of stake % of the owners of the genesis block could eventually come together, collude, and produce a longer (ie. higher-scoring) chain than everyone else.nnhis may seem like a fatal flaw, but in reality it is only a flaw if we implicitly accept an assumption that is made in the case of proof of work that nodes have no knowledge of history. n a proof-of-work protocol, a new node, having no direct knowledge of past events and seeing nothing but the protocol source code and the set of messages that have already been published, can join the network at any point and determine the score of all possible chains, and from there the block that is at the top of the highest-scoring main chain. ith proof of stake, as we described, such a property cannot be achieved, since it's very cheap to acquire historical keys and simulate alternate histories. hus, we will rela our assumptions somewhat we will say that we are only concerned with maintaining consensus between a static set of nodes that are online at least once every  days, allowing these nodes to use their own knowledge of history to reject obvious long-range forks using some formula, and new nodes or long-dormant nodes will need to specify a "checkpoint" (a hash of a block representing what the rest of the network agrees is a recent state) in order to get back onto the consensus.nnuch an approach is essentially a hybrid between the pure and perhaps harsh trust-no-one logic of itcoin and the total dependency on socially-driven consensus found in networks like ipple. n ipple's case, users joining the system need to select a set of nodes that they trust (or, more precisely, trust not to collude) and rely on those nodes during every step of the consensus process. n the case of itcoin, the theory is that no such trust is required and the protocol is completely self-contained the system works just as well between a thousand isolated cavemen with laptops on a thousand islands as it does in a strongly connected society (in fact, it might work better with island cavemen, since without trust collusion is more difficult). n our hybrid scheme, users need only look to the society outside of the protocol eactly once - when they first download a client and find a checkpoint - and can enjoy itcoin-like trust properties starting from that point.nnn order to determine which trust assumption is the better one to take, we ultimately need to ask a somewhat philosophical question do we want our consensus protocols to eist as absolute cryptoeconomic constructs completely independent of the outside world, or are we okay with relying heavily on the fact that these systems eist in the contet of a wider society lthough it is indeed a central tenet of mainstream cryptocurrency philosophy that too much eternal dependence is dangerous, arguably the level of independence that itcoin affords us in reality is no greater than that provided by the hybrid model. he argument is simple even in the case of itcoin, a user must also take a leap of trust upon joining the network - first by trusting that they are joining a protocol that contains assets that other people find valuable (eg. how does a user know that bitcoins are worth $ each and dogecoins only $. specially with the different capabilities of s for different algorithms, hashpower is only a very rough estimate), and second by trusting that they arenndownloading the correct software packagenn. n both the supposedly "pure" model and the hybrid model there is always a need to look outside the protocol eactly once. hus, on the whole, the gain from accepting the etra trust requirement (namely, environmental friendliness and security againstnnoligopolistic mining pools and  farmsnn) is arguably worth the cost.nndditionally, we may note that, unlike ipple consensus, the hybrid model is still compatible with the idea of blockchains "talking" to each each other by containing a minimal "light" implementation of each other's protocols. he reason is that, while the scoring mechanism is not "absolute" from the point of view of a node without history suddenly looking at every block, it is perfectly sufficient from the point of view of an entity that remains online over a long period of time, and a blockchain certainly is such an entity.nno far, there have been two major approaches that followed some kind of checkpoint-based trust modelnneveloper-issued checkpointsnn- the client developer issues a new checkpoint with each client upgrade (eg. used innnoinnn)nnevert limitnn- nodes refuse to accept forks that revert more than  (eg. ) blocks (eg. used innnendermintnn)nnhe first approach has been roundly criticized by the cryptocurrency community for being too centralized. he second, however, also has a flaw a powerful attacker can not only revert a few thousand blocks, but also potentially split the network permanently. n the -block revert case, the strategy is as follows. uppose that the network is currently at block , and   . he attacker starts a secret fork, and grows it by  blocks faster than the main network. hen the main network gets to , and some node produces block , the attacker reveals his own fork. ome nodes will see the main network's block , and refuse to switch to the attacker's fork, but the nodes that did not yet see that block will be happy to revert from  to  and then accept the attacker's fork. rom there, the network is permanently split.nnortunately, one can actually construct a third approach that neatly solves this problem, which we will callnneponentially subjective scoringnn. ssentially, instead of rejecting forks that go back too far, we simply penalize them on a graduating scale. or every block, a node maintains a score and a "gravity" factor, which acts as a multiplier to the contribution that the block makes to the blockchain's score. he gravity of the genesis block is , and normally the gravity of any other block is set to be equal to the gravity of its parent. owever, if a node receives a block whose parent already has a chain of  descendants (ie. it's a fork reverting  blocks), that block's gravity is penalized by a factor of .nnnn, and the penalty propagates forever down the chain and stacks multiplicatively with other penalties.nnhat is, a fork which starts  block ago will need to grow % faster than the main chain in order to overtake it, a fork which starts  blocks ago will need to grow . times as quickly, and a fork which starts  blocks ago will need to grow  times as quickly - clearly an impossibility with even trivial proof of work.nnhe algorithm serves to smooth out the role of checkpointing, assigning a small "weak checkpoint" role to each individual block. f an attacker produces a fork that some nodes hear about even three blocks earlier than others, those two chains will need to stay within % of each other forever in order for a network split to maintain itself.nnhere are other solutions that could be used aside from, or even alongside  a particular set of strategies involves stakeholders voting on a checkpoint every few thousand blocks, requiring every checkpoint produced to reflect a large consensus of the majority of the current stake (the reason the majority of the stake can't vote on every block is, of course, that having that many signatures would bloat the blockchain).nnlasher hostnnhe other large compleity in implementing proof of stake for thereum specifically is the fact that the network includes a uring-complete financial system where accounts can have arbitrary permissions and even permissions that change over time. n a simple currency, proof of stake isnnrelativelynneasy to accomplish because each unit of currency has an unambiguous owner outside the system, and that owner can be counted on to participate in the stake-voting process by signing a message with the private key that owns the coins. n thereum, however, things are not quite so simple if we do our job promoting proper wallet security right, the majority of ether is going to be stored in specialized storage contracts, and with uring-complete code there is no clear way of ascertaining or assigning an "owner".nnne strategy that we looked at was delegation requiring every address or contract to assign an address as a delegate to sign for them, and that delegate account would have to be controlled by a private key. owever, there is a problem with any such approach. uppose that a majority of the ether in the system is actually stored in application contracts (as opposed to personal storage contracts) this includes deposits in chellingoins and other stake-based protocols, security deposits innnprobabilistic enforcement systemsnn, collateral for financial derivatives, funds owned by s, etc. hose contracts do not have an owner even in spirit in that case, the fear is that the contract will default to a strategy of renting out stake-voting delegations to the highest bidder. ecause attackers are the only entities willing to bid more than the epected return from the delegation, this will make it very cheap for an attacker to acquire the signing rights to large quantities of stake.nnhe only solution to this within the delegation paradigm is to make it etremely risky to dole out signing privileges to untrusted parties the simplest approach is to modify lasher to require a large deposit, and slash the deposit as well as the reward in the event of double-signing. owever, if we do this then we are essentially back to entrusting the fate of a large quantity of funds to a single private key, thereby defeating much of the point of thereum in the first place.nnortunately, there is one alternative to delegation that is somewhat more effective letting contracts themselves sign. o see how this works, consider the following protocolnnhere is now a  opcode added.nn signature is a series ofnnvirtual transactionsnnwhich, when sequentially applied to the state at the end of the parent block, results in the  opcode being called. he nonce of the first  in the signature must be the prevhash being signed, the nonce of the second must be the prevhash plus one, and so forth (alternatively, we can make the nonces -, -, - etc. and require the prevhash to be passed in through transaction data so as to be eventually supplied as an input to the  opcode).nnhen the block is processed, the state transitions from the s are reverted (this is what is meant by "virtual") but a deposit is subtracted from each signing contract and the contract is registered to receive the deposit and reward in  blocks.nnasically, it is the contract's job to determine the access policy for signing, and the contract does this by placing the  opcode behind the appropriate set of conditional clauses.  signature now becomes a set of transactions which together satisfy this access policy. he incentive for contract developers to keep this policy secure, and not dole it out to anyone who asks, is that if it is not secure then someone can double-sign with it and destroy the signing deposit, taking a portion for themselves as per the lasher protocol. ome contracts will still delegate, but this is unavoidable even in proof-of-stake systems for plain currencies such as , many users end up delegating (eg.  even goes so far as to institutionalize delegation), and at least here contracts have an incentive to delegate to an access policy that is not likely to come under the influence of a hostile entity - in fact, we may even see an equilibrium where contracts compete to deliver secure blockchain-based stake pools that are least likely to double-vote, thereby increasing security over time.nnowever, the virtual-transactions-as-signatures paradigm does impose one complication it is no longer trivial to provide an evidence transaction showing two signatures by the same signer at the same block height. ecause the result of a transaction eecution depends on the starting state, in order to ascertain whether a given evidence transaction is valid one must prove everything up to the block in which the second signature was given. hus, one must essentially "include" the fork of a blockchain inside of the main chain. o do this efficiently, a relatively simple proposal is a sort of "lasher " protocol, where one can include side-blocks in the main chain as uncles. pecifically, we declare two new transaction typesnnblock_number, uncle_hash]nn- this transaction is valid if () the block with the givennnuncle_hashnnhas already been validated, () the block with the givennnuncle_hashnnhas the given block number, and () the parent of that uncle is either in the main chain or was included earlier as an uncle. uring the act of processing this transaction, if addresses that double-signed at that height are detected, they are appropriately penalized.nnblock_number, uncle_parent_hash, vt]nn- this transaction is valid if () the block with the givennnuncle_parent_hashnnhas already been validated, () the given virtual transaction is valid at the given block height with the state at the end ofnnuncle_parent_hashnn, and () the virtual transaction shows a signature by an address which also signed a block at the givennnblock_numbernnin the main chain. his transaction penalizes that one address.nnssentially, one can think of the mechanism as working like a "zipper", with one block from the fork chain at a time being zipped into the main chain. ote that for a fork to start, there must eist double-signers at every block there is no situation where there is a double-signer  blocks into a fork so a whistleblower must "zip"  innocent blocks into a chain before getting to the target block - rather, in such a case, even if  blocks need to be added, each one of them notifies the main chain about five separate malfeasors that double-signed at that height. ne somewhat complicated property of the scheme is that the validity of these "lasher uncles" depends on whether or not the node has validated a particular block outside of the main chain to facilitate this, we specify that a response to a "getblock" message in the wire protocol must include the uncle-dependencies for a block before the actual block. ote that this may sometimes lead to a recursive epansion however, the denial-of-service potential is limited since each individual block still requires a substantial quantity of proof-of-work to produce.nnlockmakers and verridesnninally, there is a third complication. n the hybrid-proof-of-stake version of lasher, if a miner has an overwhelming share of the hashpower, then the miner can produce multiple versions of each block, and send different versions to different parts of the network. alf the signers will see and sign one block, half will see and sign another block, and the network will be stuck with two blocks with insufficient signatures, and no signer willing to slash themselves to complete the process thus, a proof-of-work override will be required, a dangerous situation since the miner controls most of the proof-of-work. here are two possible solutions herennigners should wait a few seconds after receiving a block before signing, and only sign stochastically in some fashion that ensures that a random one of the blocks will dominate.nnhere should be a single "blockmaker" among the signers whose signature is required for a block to be valid. ffectively, this transfers the "leadership" role from a miner to a stakeholder, eliminating the problem, but at the cost of adding a dependency on a single party that now has the ability to substantially inconvenience everyone by not signing, or unintentionally by being the target of a denial-of-service attack. uch behavior can be disincentivized by having the signer lose part of their deposit if they do not sign, but even still this will result in a rather jumpy block time if the only way to get around an absent blockmaker is using a proof-of-work override.nnne possible solution to the problem in () is to remove proof of work entirely (or almost entirely, keeping a minimal amount for anti-o value), replacing it with a mechanism that lad amfir has coined "delegated timestamping". ssentially, every block must appear on schedule (eg. at  second intervals), and when a block appears the signers vote  if the block was on time, or  if the block was too early or too late. f the majority of the signers votes , then the block is treated as invalid - kept in the chain in order to give the signers their fair reward, but the blockmaker gets no reward and the state transition gets skipped over. oting is incentivized viannschellingcoinnn- the signers whose vote agrees with the majority get an etra reward, so assuming that everyone else is going to be honest everyone has the incentive to be honest, in a self-reinforcing equilibrium. he theory is that a -second block time is too fast for signers to coordinate on a false vote (the astute reader may note that the signers were decided  blocks in advance so this is not really true to fi this we can create two groups of signers, one pre-chosen group for validation and another group chosen at block creation time for timestamp voting).nnutting it all ogethernnaken together, we can thus see something like the following working as a functional version of lashernnvery block has anndesignated blockmakernn, a set ofnndesignated signersnn, and a set ofnndesignated timestampersnn. or a block to be accepted as part of the chain it must be accompanied by virtual-transactions-as-signatures from the blockmaker, two thirds of the signers and  timestampers, and the block must have some minimal proof of work for anti-o reasons (say, targeted to . per year)nnuring blocknnnn, we say that the set ofnnpotential signersnnof blocknn + nnis the set of addresses such thatnnsha(address + block].hash)  block].balance(address) * nnwherennnnis a difficulty parameter targeting  signers per block (ie. if blocknnnnhas less than  signers it goes down otherwise it goes up).nnf a potential signer for blocknn + nnwants to become a signer, they must send a special transaction accepting this responsibility and supplying a deposit, and that transaction must get included between blocksnn + nnandnn + nn. he set of designated signers for blocknn + nnis the set of all individuals that do this, and the blockmaker is the designated signer with the lowest value fornnsha(address + block].hash)nn. f the signer set is empty, no block at that height can be made. or blocks  ... , the blockmaker and only signer is the protocol developer.nnhe set of timestampers of the blocknn + nnis the set of addresses such thatnnsha(address + block].hash)  block].balance(address) * nn, wherennnnis targeted such that there is an average of  timestampers each block (ie. if blocknnnnhas less than  timestampers it goes down otherwise it goes up).nnet  be the timestamp of the genesis block. hen blocknn + nnis released, timestampers can supply virtual-transactions-as-signatures for that block, and have the choice of voting  or  on the block. oting  means that they saw the block within . seconds of timenn + ( + ) * nn, and voting  means that they received the block when the time was outside that range. ote that nodes should detect if their clocks are out of sync with everyone else's clocks on the blockchain, and if so adjust their system clocks.nnimestampers who voted along with the majority receive a reward, other timestampers get nothing.nnhe designated signers for blocknn + nnhave the ability to sign that block by supplying a set of virtual-transactions-as-a-signature. ll designated signers who sign are scheduled to receive a reward and their returned deposit in blocknn + nn. igners who skipped out are scheduled to receive their returned deposit minus twice the reward (this means that it's only economically profitable to sign up as a signer if you actually think there is a chance greater than / that you will be online).nnf the majority timestamper vote is , the blockmaker is scheduled to receive a reward and their returned deposit in blocknn + nn. f the majority timestamper vote is , the blockmaker is scheduled to receive their deposit minus twice the reward, and the block is ignored (ie. the block is in the chain, but it does not contribute to the chain's score, and the state of the net block starts from the end state of the block before the rejected block).nnf a signer signs two different blocks at heightnn + nn, then if someone detects the double-signing before blocknn + nnthey can submit an "evidence" transaction containing the two signatures to either or both chains, destroying the signer's reward and deposit and transferring a third of it to the whistleblower.nnf there is an insufficient number of signers to sign or the blockmaker is missing at a particular block heightnnhnn, the designated blockmaker for heightnnh + nncan produce a block directly on top of the block at heightnnh - nnafter waiting for  seconds instead of .nnfter years of research, one thing has become clear proof of stake is non-trivial - so non-trivial that some evennnconsider it impossiblenn. he issues of nothing-at-stake and long-range attacks, and the lack of mining as a rate-limiting device, require a number of compensatory mechanisms, and even the protocol above does not address the issue of how to randomly select signers. ith a substantial proof of work reward, the problem is limited, as block hashes can be a source of randomness and we can mathematically show that the gain from holding back block hashes until a miner finds a hash that favorably selects future signers is usually less than the gain from publishing the block hashes. ithout such a reward, however, other sources of randomness such as low-influence functions need to be used.nnor thereum ., we consider it highly desirable to both not ecessively delay the release and not try too many untested features at once hence, we will likely stick with -resistant proof of work, perhaps with non-lashernnproof of activitynnas an addon, and look at moving to a more comprehensive proof of stake model over time.