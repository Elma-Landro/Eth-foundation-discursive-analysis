Titre: Validated, staking on eth2: #3 - Sharding Consensus\nAuteur: Carl Beekhuizen\nDate: March 27, 2020\nURL: https://blog.ethereum.org/2020/03/27/sharding-consensus\nCatégorie: Non catégorisé\n\n==================================================\n\npecial thanks to acha ves aint-eger & oseph chweitzer for review.nnharding is one of the many improvements that eth has over eth. he term was borrowed from database research where a shard means a piece of a larger whole. n the contet of databases and eth, sharding means breaking up the storage and computation of the whole system into shards, processing the shards separately, and combining the results as needed. pecifically, eth implements many shard chains, where each shard has similar capabilities to the eth chain. his results in massive scaling improvements.nnowever, there's a less-well-known type of sharding in eth. ne which is arguably more eciting from a protocol design point of view.nnnter sharded consensus.nnharding onsensusnnn much the same way that the processing power of the slowest node limits the throughput of the network, the computing resources of a single validator limit the total number of validators that can participate in consensus. ince each additional validator introduces etra work for every other validator in the system, there’ll come a point where the validator with the least resources can no longer participate (because it can no longer keep track of the votes of all of the other validators). he solution eth employs to this isnnsharding consensusnn.nnreaking it downnnth breaks time down into two durations, slots and epochs.nn slot is the  second time-frame in which a new block is epected to be added to the chain. locks are the mechanism by which votes cast by validators are included on the chain in addition to the transactions that actually make the chain useful.nnn epoch is comprised of  slots (. minutes) during which the beacon chain performs all of the calculations associated with the upkeep of the chain, including justifying and finalising new blocks, and issuing rewards and penalties to validators.nns we touched upon in thennfirst post of this seriesnn, validators are organised into committees to do their work. t any one time, each validator is a member of eactly one beacon chain and one shard chain committee, and is called on to make an attestation eactly once per epoch – where an attestation is a vote for a beacon chain block that has been proposed for a slot.nnhe security model of eth's sharded consensus rests upon the idea that committees are more or less an accurate statistical representation of the overall validator set.nnor eample, if we have a situation in which % of validators in the overall set are malicious, there is a chance that they could end up in the same committee. his would be a disaster for our security model.nno we need a way to ensure that this can’t happen. n other words, we need a way to ensure that if % of validators are malicious, only about ~% of validators in a committee will be malicious.nnt turns out we can achieve this by doing two thingsnnnsuring committee assignments are randomnnequiring a minimum number of validators in each committeennor eample, with  randomly sampled validators per committee, the chance of an attacker with / of the validators gaining control of  / committee is vanishingly small (nnprobability less than ^-nn).nnuilding it upnnotes cast by validators are called attestations. n attestation is comprised of many elements, specificallynna vote for the current beacon chain headnna vote on which beacon block should be justified/finalisednna vote on the current state of the shard chainnnthe signatures of all of the validators who agree with that votenny combining as many components as possible into an attestation, the overall efficiency of the system is increased. his is possible since, instead of having to check votes and signatures for beacon blocks and shard blocks separately, nodes need only do the math on attestations to be informed about the state of the beacon chain and of every shard chain.nnf every validator produced their own attestation and every attestation needed to be verified by all other nodes, then being an eth node would be prohibitively epensive.nnnter aggregation.nnttestations are designed to be easily combined such that if two or more validators have attestations with the same votes, they can be combined by adding the signatures fields together in one attestation. his is what we mean by aggregation.nnommittees, by their construction, will have votes that are easy to aggregate because they are assigned to the same shard, and therefore should have the same votes for both the shard state and beacon chain. his is the mechanism by which eth scales the number of validators. y breaking the validators up into committees, validators need only to care about their fellow committee members and only have to check very few aggregated attestations from each of the other committees.nnignature aggregationnnth makes use of the  signatures -nna signature scheme defined over several elliptic curves that is friendly to aggregation.nnn the specific curve chosen, signatures arenn bytesnneach.nnf % of all  ends up staked, then there will be ~, validators on eth. his means that an epoch's worth of signatures would benn. megabytesnnwhich comes to ~nn. gigabytesnnper day. n this case, all of the false claims about thenneth state-size reaching  back in nnwould be true in eth's case in fewer than  days (based on signatures alone).nnhe trick here is that  signatures can be aggregated f lice produces signaturennnn, and ob's signature isnnnnon the same data, then both lice's and ob's signatures can be stored and checked together by only storingnn   + nn. y using signature aggregation, only  signature needs to be stored and checked for the entire committee. his reduces the storage requirements to less thannn megabytesnnper day.nnn summary,nny separating validators out into committees, the effort required to verify eth is reduced by orders of magnitude.nnor a node to validate the beacon chain and all of the shard chains, it only needs to look at the aggregated attestations from each of the committees. n this way it can know the state of every shard, and every validator's opinions on which blocks are and aren't a part of the chain.nnhe committee mechanism therefore helps eth achieve two of the design goals established in thennfirst articlenn namely that participating in the eth network must be possible on a consumer-grade laptop, and that it must strive to be maimally decentralised by supporting as many validators as possible.nno put numbers to it, while most yzantine ault olerant roof of take protocols scale to tens (and in etreme cases, hundreds of validators), eth is capable of having hundreds of thousands of validators all contributing to security without compromising on latency or throughput.