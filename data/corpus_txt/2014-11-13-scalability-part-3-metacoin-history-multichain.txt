Titre: Scalability, Part 3: On Metacoin History and Multichain\nAuteur: Vitalik Buterin\nDate: November 13, 2014\nURL: https://blog.ethereum.org/2014/11/13/scalability-part-3-metacoin-history-multichain\nCatégorie: Non catégorisé\n\n==================================================\n\npecial thanks to lad amfir for much of the thinking behind multi-chain cryptoeconomic paradigmsnnirst off, a history lesson. n ctober , when  was visiting srael as part of my trip around the itcoin world,  came to know the core teams behind thenncolored coinsnnandnnastercoinnnprojects. nce nnproperly understood astercoinnnand its potential,  was immediately drawn in by the sheer power of the protocol however,  disliked the fact that the protocol was designed as a disparate ensemble of "features", providing a subtantial amount of functionality for people to use, but offering no freedom to escape out of that bo. eeking to improve astercoin's potential,  came up with a draft proposal for something called "nnultimate scriptingnn" - a general-purpose stack-based programming language that astercoin could include to allow two parties to make a contract on an arbitrary mathematical formula. he scheme would generalize savings wallets, contracts for difference, many kinds of gambling, among other features. t was still quite limited, allowing only three stages (open, fill, resolve) and no internal memory and being limited to  parties per contract, but it was the first true seed of the thereum idea.nn submitted the proposal to the astercoin team. hey were impressed, but elected not to adopt it too quickly out of a desire to be slow and conservative a philosophy which the project keeps to to this day and which avid ohnston mentioned at the recent el viv conference as astercoin's primary differentiating feature. hus,  decided to go out on my own and simply build the thing myself. ver the net three weeks  created the original thereum whitepaper (unfortunately now gone, but a still very early versionnneists herenn). he basic building blocks were all there, ecept the progamming language was register-based instead of stack-based, and, because  was/am not skilled enough in pp networking to build an independent blockchain client from scratch, it was to be built as a meta-protocol on top of rimecoin - not itcoin, because  wanted to satisfy the concerns of itcoin developers who were angry at meta-protocols bloating the blockchain with etra data.nnnce competent developers like avin ood and effrey ilcke, who did not share my deficiencies in ability to write pp networking code, joined the project, and once enough people were ecited that  saw there would be money to hire more,  made the decision to immediately move to an independent blockchain. he reasoning for this choice  described in mynnwhitepaper in early anuarynnnnhe advantage of a metacoin protocol is that it can allow for more advanced transaction types, including custom currencies, decentralized echange, derivatives, etc, that are impossible on top of itcoin itself. owever, metacoins on top of itcoin have one major flaw simplified payment verification, already difficult with colored coins, is outright impossible on a metacoin. he reason is that while one can use  to determine that there is a transaction sending  metacoins to address , that by itself does not mean that address  has  metacoins what if the sender of the transaction did not have  metacoins to start with and so the transaction is invalid inding out any part of the current state essentially requires scanning through all transactions going back to the metacoin's original launch to figure out which transactions are valid and which ones are not. his makes it impossible to have a truly secure client without downloading the entire   itcoin blockchain.nnssentially, metacoins don't work for light clients, making them rather insecure for smartphones, users with old computers, internet-of-things devices, and once the blockchain scales enough for desktop users as well. thereum's independent blockchain, on the other hand, is specifically designed with a highly advanced light client protocol unlike with meta-protocols, contracts on top of thereum inherit the thereum blockchain's light client-friendliness properties fully. inally, long after that,  realized that by making an independent blockchain allows us to eperiment with stronger versions of -style protocols, safely knocking down the block time tonn secondsnn.nno what's the point of this story ssentially, had history been different, we easilynncouldnnhave gone the route of being "on top of itcoin" right from day one (in fact, we still could make that pivot if desired), but solid technical reasons eisted then why we deemed it better to build an independent blockchain, and these reasons still eist, in pretty much eactly the same form, today.nnince a number of readers were epecting a response to how thereum as an independent blockchain would be useful even in the face of the recent announcement ofnna metacoin based on thereum technologynn, this is it. calability. f you use a metacoin on , you gain the benefit of having easier back-and-forth interaction with the itcoin blockchain, but if you create an independent chain then you have the ability to achieve much stronger guarantees of security particularly for weak devices. here are certainly applications for which a higher degree of connectivity with  is important  for these cases a metacoin would certainly be superior (although note that even an independent blockchain can interact with  pretty well using basically the same technology that we'll describe in the rest of this blog post). hus, on the whole, it will certainly help the ecosystem if the same standardized  is available across all platforms.nneyond .nnowever, in the long term, even light clients are an ugly solution. f we truly epect cryptoeconomic platforms to become a base layer for a very large amount of global infrastructure, then there may well end up being so many crypto-transactions altogether that no computer, ecept maybe a few very large server farms run by the likes of oogle and mazon, is powerful enough to process all of them. hus, we need to breaknnthe fundamental barriernnof cryptocurrency that there need to eist nodes that process every transaction. reaking that barrier is what gets a cryptoeconomic platform's database from being merelynnmassively replicatednnto being trulynndistributednn. owever, breaking the barrier is hard, particularly if you still want to maintain the requirement that all of the different parts of the ecosystem should reinforce each other's security.nno achieve the goal, there are three major strategiesnnuilding protocolsnnon top of thereumnnthat use thereum only as an auditing-backend-of-last-resort, conserving transaction fees.nnurning the blockchain into something much closer to annhigh-dimensional interlinking meshnnwith all parts of the database reinforcing each other over time.nnoing back to a model of one-protocol (or one service)-per-chain, and coming up with mechanisms for the chains to () interact, and () share consensus strength.nnf these strategies, note that only () is ultimately compatible with keeping the blockchain in a form anything close to what the itcoin and thereum protocols support today. () requires a massive redesign of the fundamental infrastructure, and () requires the creation of thousands of chains, and for fragility mitigation purposes the optimal approach will be to use thousands of currencies (to reduce the compleity on the user side, we can usennstable-coinsnnto essentially create a common cross-chain currency standard, and any slight swings in the stable-coins on the user side would be interpreted in the  as interest or demurrage so the user only needs to keep track of one unit of account).nne already discussed () and () in previous blog posts, and so today we will provide an introduction to some of the principles involved in ().nnultichainnnhe model here is in many ways similar to thennitsharesnnmodel, ecept that we do not assume that  (or any other ) will be secure for arbitrarily small chains. ather, seeing the generalnnstrong parallels between cryptoeconomics and institutions in wider societynn, particularly legal systems, we note that there eists a largennbody of shareholder lawnnprotecting minority stakeholders in real-world companies against the equivalent of a % attack (namely, % of shareholders voting to pay % of funds to themselves), and so we try to replicate the same system here by having every chain, to some degree, "police" every other chain either directly or indirectly through an interlinking transitive graph. he kind of policing required is simple - policing aganist double-spends and censorship attacks from local majority coalitions, and so the relevant guard mechanisms can be implemented entirely in code.nnowever, before we get to the hard problem of inter-chain security, let us first discuss what actually turns out to be a much easier problem inter-chain interaction. hat do we mean by multiple chains "interacting" ormally, the phrase can mean one of two thingsnnnternal entities (ie. scripts, contracts) in chain  are able to securely learn facts about the state of chain  (nninformation transfernn)nnt is possible to create a pair of transactions,  in  and ' in , such that either both  and ' get confirmed or neither do (nnatomic transactionsnn)nn sufficiently general implementation of () implies (), since "' was (or was not) confirmed in " is a fact about the state of chain . he simplest way to do this is via erkle trees, described in more detailnnherennandnnherenn essentially erkle trees allow the entire state of a blockchain to be hashed into the block header in such a way that one can come up with a "proof" that a particular value is at a particular position in the tree that is only logarithmic in size in the entire state (ie. at most a few kilobytes long). he general idea is that contracts in one chain validate these erkle tree proofs of contracts in the other chain.nn challenge that is greater for some consensus algorithms than others is, how does the contract in a chain validate the actual blocks in another chain ssentially, what you end up having is a contract acting as a fully-fledged "light client" for the other chain, processing blocks in that chain and probabilistically verifying transactions (and keeping track of challenges) to ensure security. or this mechanism to be viable, at least some quantity of proof of work must eist on each block, so that it is not possible to cheaply produce many blocks for which it is hard to determine that they are invalid as a general rule, the work required by the blockmaker to produce a block should eceed the cost to the entire network combined of rejecting it.nndditionally, we should note that contracts are stupid they are not capable of looking at reputation, social consensus or any other such "fuzzy" metrics of whether or not a given blockchain is valid hence, purely "subjective" ipple-style consensus will be difficult to make work in a multi-chain setting. itcoin's proof of work is (fully in theory, mostly in practice) "objective" there is a precise definition of what the current state is (namely, the state reached by processing the chain with the longest proof of work), and any node in the world, seeing the collection of all available blocks, will come to the same conclusion on which chain (and therefore which state) is correct. roof-of-stake systems, contrary to what many cryptocurrency developers think, can be secure, butnnneed to be "weakly subjective"nn- that is, nodes that were online at least once every  days since the chain's inception will necessarily converge on the same conclusion, but long-dormant nodes and new nodes need a hash as an initial pointer. his is needed to prevent certain classes of unavoidable long-range attacks. eakly subjective consensus works fine with contracts-as-automated-light-clients, since contracts are always "online".nnote that it is possible to support atomic transactions without information transfer ierolan'snnsecret revelation protocolnncan be used to do this even between relatively dumb chains like  and . ence, in general interaction is not too difficult.nnecuritynnhe larger problem, however, is security. lockchains are vulnerable to % attacks, and smaller blockchains are vulnerable to smaller % attacks. deally, if we want security, we would like for multiple chains to be able to piggyback on each other's security, so that no chain can be attacked unless every chain is attacked at the same time. ithin this framework, there are two major paradigm choices that we can makenncentralizednnornndecentralizednn.nnentralizednnecentralizednn centralized paradigm is essentially every chain, whether directly or indirectly, piggybacking off of a single master chain itcoin proponents often love to see the central chain being itcoin, though unfortunately it may be something else since itcoin was not eactly designed with the required level of general-purpose functionality in mind.  decentralized paradigm is one that looks vaguely like ipple's network of unique node lists, ecept working across chains every chain has a list of other consensus mechanisms that it trusts, and those mechanisms together determine block validity.nnhe centralized paradigm has the benefit that it's simpler the decentralized paradigm has the benefit that it allows for a cryptoeconomy to more easily swap out different pieces for each other, so it does not end up resting on decades of outdated protocols. owever, the question is, how do we actually "piggyback" on one or more other chains' securitynno provide an answer to this question, we'll first come up with a formalism called annnassisted scoring functionnn. n general, the way blockchains work is they have some scoring function for blocks, and the top-scoring block becomes the block defining the current state. ssisted scoring functions work by scoring blocks based on not just the blocks themselves, but also checkpoints in some other chain (or multiple chains). he general principle is that we use the checkpoints to determine that a given fork, even though it may appear to be dominant from the point of view of the local chain, can be determined to have come later through the checkpointing process.nn simple approach is that a node penalizes forks where the blocks are too far apart from each other in time, where the time of a block is determined by the median of the earliest known checkpoint of that block in the other chains this would detect and penalize forks that happen after the fact. owever, there are two problems with this approachnnn attacker can submit the hashes of the blocks into the checkpoint chains on time, and then only reveal the blocks laternnn attacker may simply let two forks of a blockchain grow roughly evenly simultaneously, and then eventually push on his preferred fork with full forcenno deal with (), we can say that only the valid block of a given block number with the earliest average checkpointing time can be part of the main chain, thus essentially completely preventing double-spends or even censorship forks every new block wouldnnhavennto point to the last known previous block. owever, this does nothing against (). o solve (), the best general solutions involve some concept of "voting on data availability" (see alsonnasper den uden's previous postnntalking about a similar idea) essentially, the participants in the checkpointing contract on each of the other chains wouldnnchelling-votennon whether or not the entire data of the block was available at the time the checkpoint was made, and a checkpoint would be rejected if the vote leans toward "no".nnor a block to be valid, it must be signed off on by a positive result from one or more eternal chelling-vote mechanismsnnote that there are two versions of this strategy. he first is a strategy where participants vote on data availability only (ie. that every part of the block is out there online). his allows the voters to be rather stupid, and be able to vote on availability for any blockchain the process for determining data availability simply consists of repeatedly doing a reverse hash lookup query on the network until all the "leaf nodes" are found and making sure that nothing is missing.  clever way to force nodes to not be lazy when doing this check is to ask them to recompute and vote on the root hash of the block using a different hash function. nce all the data is available, if the block is invalid an efficient erkle-tree proof of invalidity can be submitted to the contract (or simply published and left for nodes to download when determining whether or not to count the given checkpoint).nnhe second strategy is less modular have the chelling-vote participants vote on block validity. his would make the process somewhat simpler, but at the cost of making it more chain-specific you would need to have the source code for a given blockchain in order to be able to vote on it. hus, you would get fewer voters providing security for your chain automatically. egardless of which of these two strategies is used, the chain could subsidize the chelling-vote contract on the other chain(s) via a cross-chain echange.nnhe calability artnnp until now, we still don't have any actual "scalability" a chain is only as secure as the number of nodes that are willing to download (although not process) every block. f course, there are solutions to this problem challenge-response protocols and randomly selected juries, both described innnthe previous blog post on hypercubesnn, are the two that are currently best-known. owever, the solution here is somewhat different instead of setting in stone and institutionalizing one particular algorithm, we are simply going to let the market decide.nnhe "market" is defined as followsnnhains want to be secure, and want to save on resources. hains need to select one or more chelling-vote contracts (or other mechanisms potentially) to serve as sources of security (demand)nnchelling-vote contracts serve as sources of security (supply). chelling-vote contracts differ on how much they need to be subsidized in order to secure a given level of participation (price) and how difficult it is for an attacker to bribe or take over the schelling-vote to force it to deliver an incorrect result (quality).nnence, the cryptoeconomy will naturally gravitate toward schelling-vote contracts that provide better security at a lower price, and the users of those contracts will benefit from being afforded more voting opportunities. owever, simply saying that an incentive eists is not enough a rather large incentive eists to cure aging and we're still pretty far from that. e also need to show that scalability is actually possible.nnhe better of the two algorithms described in the post on hypercubes, jury selection, is simple. or every block, a random  nodes are selected to vote on it. he set of  is almost as secure as the entire set of voters, since the specific  are not picked ahead of time and an attacker would need to control over % of the participants in order to have any significant chance of getting % of any set of . f we are separating voting on data availability from voting on validity, then these  can be chosen from the set of all participants in a single abstract chelling-voting contract on the chain, since it's possible to vote on the data availability of a block without actually understanding anything about the blockchain's rules. hus, instead of every node in the network validating the block, only  validate the data, and then only a few nodes need to look for actual errors, since if even one node finds an error it will be able to construct a proof and warn everyone else.nnonclusionnno, what is the end result of all this ssentially, we have thousands of chains, some with one application, but also with general-purpose chains like thereum because some applications benefit from the etremely tight interoperability that being inside a single virtual machine offers. ach chain would outsource the key part of consensus to one or more voting mechanisms on other chains, and these mechanisms would be organized in different ways to make sure they're as incorruptible as possible. ecause security can be taken from all chains, a large portion of the stake in the entire cryptoeconomy would be used to protect every chain.nnt may prove necessary to sacrifice security to some etent if an attacker has % of the stake then the attacker can do a % takeover of % of the subcontracted voting mechanisms or chelling-pools out there however, % of stake is still a large security margin to have in a hypothetical multi-trillion-dollar cryptoeconomy, and so the tradeoff may be worth it.nnhe true benefit of this kind of scheme is just how little needs to be standardized. ach chain, upon creation, can choose some number of chelling-voting pools to trust and subsidize for security, and via a customized contract it can adjust to any interface. erkle trees will need to be compatible with all of the different voting pools, but the only thing that needs to be standardized there is the hash algorithm. ifferent chains can use different currencies, using stable-coins to provide a reasonably consistent cross-chain unit of value (and, of course, these stable-coins can themselves interact with other chains that implement various kinds of endogenous and eogenousnnestimatorsnn). ltimately, the vision of one of thousands of chains, with the different chains "buying services" from each other. ervices might include data availability checking, timestamping, general information provision (eg. price feeds, estimators), private data storage (potentially even consensus on private data via secret sharing), and much more. he ultimate distributed crypto-economy.