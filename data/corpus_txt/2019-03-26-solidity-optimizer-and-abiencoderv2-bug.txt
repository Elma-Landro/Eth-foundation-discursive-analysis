Titre: Solidity Optimizer and ABIEncoderV2 Bug\nAuteur: Solidity and Security Team\nDate: March 26, 2019\nURL: https://blog.ethereum.org/2019/03/26/solidity-optimizer-and-abiencoderv2-bug\nCatégorie: Non catégorisé\n\n==================================================\n\nolidity ptimizer and ncoder ug nnouncementnnhrough the thereum bug bounty program, we received a report about a flaw within the new eperimental  encoder (referred to as ncoder). pon investigation, it was found that the component suffers from a few different variations of the same type. he first part of this announcement eplains this bug in detail. he new  encoder is still marked as eperimental, but we nevertheless think that this deserves a prominent announcement since it is already used on mainnet.nndditionally, two low-impact bugs in the optimizer have been identified over the past two weeks, one of which was fied with olidity v... oth were introduced with version ... ee the second part of this announcement for details.nnhenn.. releasenncontains the fies to all bugs eplained in this blog post.nnll the bugs mentioned here should be easily visible in tests that touch the relevant code paths, at least when run with all combinations of zero and nonzero values.nnredits to elonport team (ravis acobs & enna enk) and the elon ouncil (ick unoz-conald, artin undfall, att di errante & dam olar), who reported this via the thereum bug bounty program!nnho should be concernednnf you have deployed contracts which use the eperimental  encoder , then those might be affected. his means that only contracts which use the following directive within the source code can be affectednnpragma eperimental ncodernnnndditionally, there are a number of requirements for the bug to trigger. ee technical details further below for more information.nns far as we can tell, there are about  contracts live on mainnet that use the eperimental ncoder. t is not clear how many of them contain the bug.nnow to check if contract is vulnerablennhe bug only manifests itself when all of the following conditions are metnntorage data involving arrays or structs is sent directly to an eternal function call, tonnabi.encodennor to event data without prior assignment to a local (memory) variable nnthere is an array that contains elements with size less than  bytes or a struct that has elements that share a storage slot or members of typennbytesnnshorter than  bytes.nnn addition to that, in the following situations, your code is  affectednnif all your structs or arrays only usennuintnnornnintnntypesnnif you only use integer types (that may be shorter) and only encode at most one array at a timennif you only return such data and do not use it innnabi.encodenn, eternal calls or event data.nnf you have a contract that meets these conditions, and want to verify whether the contract is indeed vulnerable, you can reach out to us viannsecurityethereum.orgnn.nnow to prevent these types of flaws in the futurennn order to be conservative about changes, the eperimental  encoder has been available only when eplicitly enabled, to allow people to interact with it and test it without putting too much trust in it before it is considered stable.nne do our best to ensure high quality, and have recently started working on 'semantic' fuzzing of certain parts onnn-uzznn(we have previously crash-fuzzed the compiler, but that did not test compiler correctness).nnor developers -- bugs within the olidity compiler are difficult to detect with tools like vulnerability detectors, since tools which operate on source code or -representations do not detect flaws that are introduced only into the compiled bytecode.nnhe best way to protect against these types of flaws is to have a rigorous set of end-to-end tests for your contracts (verifying all code paths), since bugs in a compiler very likely are not "silent" and instead manifest in invalid data.nnossible consequencesnnaturally, any bug can have wildly varying consequences depending on the program control flow, but we epect that this is more likely to lead to malfunction than eploitability.nnhe bug, when triggered, will under certain circumstances send corrupt parameters on method invocations to other contracts.nnimelinenn--nneport via bug bounty, about corruption caused when reading from arrays of booleans directly from storage into  encoder.nn-- to --nnnvestigation of root cause, analysis of affected contracts. n unepectedly high count of contracts compiled with the eperimental encoder were found deployed on mainnet, many without verified source-code.nnnvestigation of bug found more ways to trigger the bug, e.g. using structs. urthermore, an array overflow bug was found in the same routine.nn handful of contracts found on ithub were checked, and none were found to be affected.nn bugfi to the  encoder was made.nn--nnecision to make information public.nneasoning t would not be feasible to detect all vulnerable contracts and reach out to all authors in a timely manner, and it would be good to prevent further proliferation of vulnerable contracts on mainnet.nn--nnew compiler release, version ...nnhis post released.nnechnical detailsnnackgroundnnhe ontract  is a specification how data can be echanged with contracts from the outside (a app) or when interacting between contracts. t supports a variety of types of data, including simple values like numbers, bytes and strings, as well as more comple data types, including arrays and structs.nnhen a contract receives input data, it must decode that (this is done by the " decoder") and prior to returning data or sending data to another contract, it must encode it (this is done by the " encoder"). he olidity compiler generates these two pieces of code for each defined function in a contract (and also fornnabi.encodennandnnabi.decodenn). n the olidity compiler the subsystem generating the encoder and decoder is called the " encoder".nnn mid- the olidity team started to work on a fresh implementation named " encoder " with the goal of having a more fleible, safe, performant and auditable code generator. his eperimental code generator, when eplicitly enabled, has been offered to users since the end of  with the .. release.nnhe flawnnhe eperimental  encoder does not handle non-integer values shorter than  bytes properly. his applies tonnbytesnntypes,nnboolnn,nnenumnnand other types when they are part of an array or a struct and encoded directly from storage. his means these storage references have to be used directly insidennabi.encode(...)nn, as arguments in eternal function calls or in event data without prior assignment to a local variable. singnnreturnnndoes not trigger the bug. he typesnnbytesnnandnnboolnnwill result in corrupted data whilennenumnnmight lead to an invalidnnrevertnn.nnurthermore, arrays with elements shorter than  bytes may not be handled correctly even if the base type is an integer type. ncoding such arrays in the way described above can lead to other data in the encoding being overwritten if the number of elements encoded is not a multiple of the number of elements that fit a single slot. f nothing follows the array in the encoding (note that dynamically-sized arrays are always encoded after statically-sized arrays with statically-sized content), or if only a single array is encoded, no other data is overwritten.nnwo unrelated bugsnnnrelated to the  encoder issue eplained above, two bugs have been found in the optimiser. oth have been introduced with .. (released on th of arch). hey are unlikely to occur in code generated by the compiler, unless inline assembly is used.nnhese two bugs have been identified through the recent addition of olidity tonn-uzznn- a security toolkit for finding discrepancies or issues in a variety of projects. or olidity we have included multiple different fuzzers testing different aspects of the compiler.nnhe optimizer turns opcode sequences likenn((  a)  b))nn, wherennannandnnbnnare compile-time constants, intonn(  (a + b))nnwhile not handling overflow in the addition properly.nnhe optimizer incorrectly handles thennbytennopcode if the constant  is used as second argument. his can happen when performing inde access onnnbytesnntypes with a compile-time constant value (not inde) of  or when using the byte opcode in inline assembly.nnhis post was jointly composed by aic, chriseth, holiman