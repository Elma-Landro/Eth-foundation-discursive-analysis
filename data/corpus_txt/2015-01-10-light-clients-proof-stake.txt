Titre: Light Clients and Proof of Stake\nAuteur: Vitalik Buterin\nDate: January 10, 2015\nURL: https://blog.ethereum.org/2015/01/10/light-clients-proof-stake\nCatégorie: Non catégorisé\n\n==================================================\n\npecial thanks to lad amfir and ae won for many of the ideas described in this postnnside from the primarynndebate around weak subjectivitynn, one of the important secondary arguments raised against proof of stake is the issue that proof of stake algorithms are much harder to make light-client friendly. hereas proof of work algorithms involve the production of block headers which can be quickly verified, allowing a relatively small chain of headers to act as an implicit proof that the network considers a particular history to be valid, proof of stake is harder to fit into such a model. ecause the validity of a block in proof of stake relies on stakeholder signatures, the validity depends on the ownership distribution of the currency in the particular block that was signed, and so it seems, at least at first glance, that in order to gain any assurances at all about the validity of a block, the entire block must be verified.nniven the sheer importance of light client protocols, particularly in light of thennrecent corporate interestnnin "internet of things" applications (which must often necessarily run on very weak and low-power hardware), light client friendliness is an important feature for a consensus algorithm to have, and so an effective proof of stake system must address it.nnight clients in roof of orknnn general, the core motivation behind the "light client" concept is as follows. y themselves, blockchain protocols, with the requirement that every node must process every transaction in order to ensure security, are epensive, and once a protocol gets sufficiently popular the blockchain becomes so big that many users become not even able to bear that cost. he itcoin blockchain is currentlynn  in sizenn, and so very few users are willing to continue to run "full nodes" that process every transaction. n smartphones, and especially on embedded hardware, running a full node is outright impossible.nnence, there needs to be some way in which a user with far less computing power to still get a secure assurance about various details of the blockchain state - what is the balance/state of a particular account, did a particular transaction process, did a particular event happen, etc. deally, it should be possible for a light client to do thisnnin logarithmic timenn- that is,nnsquaringnnthe number of transactions (eg. going from  t/day to  t/day) should onlynndoublenna light client's cost. ortunately, as it turns out, it is quite possible to design a cryptocurrency protocol that can be securely evaluated by light clients at this level of efficiency.nnasic block header model in thereum (note that thereum has a erkle tree for transactions and accounts in each block, allowing light clients to easily access more data)nnn itcoin, light client security works as follows. nstead of constructing a block as a monolithic object containing all of the transactions directly, a itcoin block is split up into two parts. irst, there is a small piece of data called thennblock headernn, containing three key pieces of datannhe hash of the previous block headernnhe erkle root of the transaction tree (see below)nnhe proof of work noncenndditional data like the timestamp is also included in the block header, but this is not relevant here. econd, there is thenntransaction treenn. ransactions in a itcoin block are stored in a data structure called a erkle tree. he nodes on the bottom level of the tree are the transactions, and then going up from there every node is the hash of the two nodes below it. or eample, if the bottom level had siteen transactions, then the net level would have eight nodesnnhash(t] + t])nn,nnhash(t] + t])nn, etc. he level above that would have four nodes (eg. the first node is equal tonnhash(hash(t] + t]) + hash(t] + t]))nn), the level above has two nodes, and then the level at the top has one node, the erkle root of the entire tree.nnhe erkle root can be thought of as a hash of all the transactions together, and has the same properties that you would epect out of a hash - if you change even one bit in one transaction, the erkle root will end up completely different, and there is no way to come up with two different sets of transactions that have the same erkle root. he reason why this more complicated tree construction needs to be used is that it actually allows you to come up with a compact proof that one particular transaction was included in a particular block. ow ssentially, just provide the branch of the tree going down to the transactionnnhe verifier will verify only the hashes going down along the branch, and thereby be assured that the given transaction is legitimately a member of the tree that produced a particular erkle root. f an attacker tries to change any hash anywhere going down the branch, the hashes will no longer match and the proof will be invalid. he size of each proof is equal to the depth of the tree - ie. logarithmic in the number of transactions. f your block contains nnnn(ie. ~ million) transactions, then the erkle tree will have only  levels, and so the verifier will only need to compute  hashes in order to verify a proof. f your block contains nnnn(ie. ~ billion) transactions, then the erkle tree will have  levels, and so a light client will be able to verify a transaction with just  hashes.nnthereum etends this basic mechanism with a two additional erkle trees in each block header, allowing nodes to prove not just that a particular transaction occurred, but also that a particular account has a particular balance and state, that a particular event occurred, and even that a particular account doesnnnotnneist.nnerifying the ootsnnow, this transaction verification process all assumes one thing that the erkle root is trusted. f someone proves to you that a transaction is part of a erkle tree that has some root, that by itself means nothing membership in a erkle tree only proves that a transaction is valid if the erkle root is itself known to be valid. ence, the other critical part of a light client protocol is figuring out eactly how to validate the erkle roots - or, more generally, how to validate the block headers.nnirst of all, let us determine eactly what we mean by "validating block headers". ight clients are not capable of fully validating a block by themselves protocols eist for doing validation collaboratively, but this mechanism is epensive, and so in order to prevent attackers from wasting everyone's time by throwing around invalid blocks we need a way of first quickly determining whether or not a particular block header isnnprobably validnn. y "probably valid" what we mean is thisnnif an attacker gives us a block that is determined to be probably valid, but is not actually valid, then the attacker needs to pay a high cost for doing sonn. ven if the attacker succeeds in temporarily fooling a light client or wasting its time, the attacker should still suffer more than the victims of the attack. his is the standard that we will apply to proof of work, and proof of stake, equally.nnn proof of work, the process is simple. he core idea behind proof of work is that there eists a mathematical function which a block header must satisfy in order to be valid, and it is computationally very intensive to produce such a valid header. f a light client was offline for some period of time, and then comes back online, then it will look for the longest chain of valid block headers, and assume that that chain is the legitimate blockchain. he cost of spoofing this mechanism, providing a chain of block headers that is probably-valid-but-not-actually-valid, is very high in fact, it is almost eactly the same as the cost of launching a % attack on the network.nnn itcoin, this proof of work condition is simplennsha(block_header)  **nn(in practice the "target" value changes, but once again we can dispense of this in our simplified analysis). n order to satisfy this condition, miners must repeatedly try different nonce values until they come upon one such that the proof of work condition for the block header is satisfied on average, this consumes about nnnncomputational effort per block. he elegant feature of itcoin-style proof of work is that every block header can be verified by itself, without relying on any eternal information at all. his means that the process of validating the block headers can in fact be done in constant time - download  bytes and run a hash of it - even better than the logarithmic bound that we have established for ourselves. n proof of stake, unfortunately we do not have such a nice mechanism.nnight lients in roof of takennf we want to have an effective light client for proof of stake, ideally we would like to achieve the eact same compleity-theoretic properties as proof of work, although necessarily in a different way. nce a block header is trusted, the process for accessing any data from the header is the same, so we know that it will take a logarithmic amount of time in order to do. owever, we want the process of validating the block headers themselves to be logarithmic as well.nno start off, let us describe an older version of lasher, which was not particularly designed to be eplicitly light-client friendlynnn order to be a "potential blockmaker" or "potential signer", a user must put down a security deposit of some size. his security deposit can be put down at any time, and lasts for a long period of time, say  months.nnuring every time slotnnnn(eg.nnnn  to  seconds after genesis), some function produces a random numbernnnn(there are many nuances behind making the random number secure, but they are not relevant here). hen, suppose that the set of potential signersnnpsnn(stored in a separate erkle tree) has sizennnn. e takennpssha() % ]nnas the blockmaker, andnnpssha( + ) % ]nn,nnpssha( + ) % ]nn...nnpssha( + ) % ]nnas the signers (essentially, usingnnnnas entropy to randomly select a signer and  blockmakers)nnlocks consist of a header containing (i) the hash of the previous block, (ii) the list of signatures from the blockmaker and signers, and (iii) the erkle root of the transactions and state, as well as (iv) auiliary data like the timestamp.nn block produced during time slotnnnnis valid if that block is signed by the blockmaker and at least  of the  signers.nnf a blockmaker or signer legitimately participates in the blockmaking process, they get a small signing reward.nnf a blockmaker or signer signs a block that is not on the main chain, then that signature can be submitted into the main chain as "evidence" that the blockmaker or signer is trying to participate in an attack, and this leads to that blockmaker or signer losing their deposit. he evidence submitter may receive % of the deposit as a reward.nnnlike proof of work, where the incentive not to mine on a fork of the main chain is the opportunity cost of not getting the reward on the main chain, in proof of stake the incentive is that if you mine on the wrong chain you will get eplicitly punished for it. his is important because a very large amount of punishment can be meted out per bad signature, a much smaller number of block headers are required to achieve the same security margin.nnow, let us eamine what a light client needs to do. uppose that the light client was last online  blocks ago, and wants to authenticate the state of the current block. hat does the light client need to do f a light client already knows that a blocknnk]nnis valid, and wants to authenticate the net blocknnk+]nn, the steps are roughly as followsnnompute the function that produces the random valuennnnduring blocknnk+]nn(computable either constant or logarithmic time depending on implementation)nnivennnnn, get the public keys/addresses of the selected blockmaker and signer from the blockchain's state tree (logarithmic time)nnerify the signatures in the block header against the public keys (constant time)nnnd that's it. ow, there is one gotcha. he set of potential signers may end up changing during the block, so it seems as though a light client might need to process the transactions in the block before being able to computennpssha( + k) % ]nn. owever, we can resolve this by simply saying that it's the potential signer set from the start of the block, or even a block  blocks ago, that we are selecting from.nnow, let us work out the formal security assurances that this protocol gives us. uppose that a light client processes a set of blocks,nn] ... n]nn, such that all blocks starting fromnnk + ]nnare invalid. ssuming that all blocks up tonnk]nnare valid, and that the signer set for blocknni]nnis determined from blocknni - ]nn, this means that the light client will be able to correctly deduce the signature validity for blocksnnk + ] ... k + ]nn. ence, if an attacker comes up with a set of invalid blocks that fool a light client, the light client can still be sure that the attacker will still have to pay ~ security deposits for the first  invalid blocks. or future blocks, the attacker will be able to get away with signing blocks with fake addresses, but  security deposits is an assurance enough, particularly since the deposits can be variably sized and thus hold many millions of dollars of capital altogether.nnhus, even this older version of lasher is, by our definition, light-client-friendly we can get the same kind of security assurance as proof of work in logarithmic time.nn etter ight-lient rotocolnnowever, we can do significantly better than the naive algorithm above. he key insight that lets us go further is that of splitting the blockchain up intonnepochsnn. ere, let us define a more advanced version of lasher, that we will call "epoch lasher". poch lasher is identical to the above lasher, ecept for a few other conditionsnnefine anncheckpointnnas a block such thatnnblock.number % n  nn(ie. everynnnnnblocks there is a checkpoint). hink ofnnnnnas being somewhere around a few weeks long it only needs to be substantially less than the security deposit length.nnor a checkpoint to be valid, / ofnnallnnpotential signers have to approve it. lso, the checkpoint must directly include the hash of the previous checkpoint.nnhe set of signers during a non-checkpoint block should be determined from the set of signers during the second-last checkpoint.nnhis protocol allows a light client to catch up much faster. nstead of processing every block, the light client would skip directly to the net checkpoint, and validate it. he light client can even probabilistically check the signatures, picking out a random  signers and requesting signatures for them specifically. f the signatures are invalid, then we can be statistically certain that thousands of security deposits are going to get destroyed.nnfter a light client has authenticated up to the latest checkpoint, the light client can simply grab the latest block and its  parents, and use a simpler per-block protocol to validate them as in the original lasher if those blocks end up being invalid or on the wrong chain, then because the light client has already authenticated the latest checkpoint, and by the rules of the protocol it can be sure that the deposits at that checkpoint are active until at least the net checkpoint, once again the light client can be sure that at least  deposits will be destroyed.nnith this latter protocol, we can see that not only is proof of stake just as capable of light-client friendliness as proof of work, but moreover it's actually even more light-client friendly. ith proof of work, a light client synchronizing with the blockchain must download and process every block header in the chain, a process that is particularly epensive if the blockchain is fast, as is one of our own design objectives. ith proof of stake, we can simply skip directly to the latest block, and validate the last  blocks before that to get an assurance that if we are on the wrong chain, at least  security deposits will be destroyed.nnow, there is still a legitimate role for proof of work in proof of stake. n proof of stake, as we have seen, it takes a logarithmic amount of effort to probably-validate each individual block, and so an attacker can still cause light clients a logarithmic amount of annoyance by broadcasting bad blocks. roof of work alone can be effectively validated in constant time, and without fetching any data from the network. ence, it may make sense for a proof of stake algorithm to still require a small amount of proof of work on each block, ensuring that an attacker must spend some computational effort in order to even slightly inconvenience light clients. owever, the amount of computational effort required to compute these proofs of work will only need to be miniscule.