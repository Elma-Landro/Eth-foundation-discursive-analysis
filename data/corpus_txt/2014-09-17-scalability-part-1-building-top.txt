Titre: Scalability, Part 1: Building on Top\nAuteur: Vitalik Buterin\nDate: September 17, 2014\nURL: https://blog.ethereum.org/2014/09/17/scalability-part-1-building-top\nCatégorie: Non catégorisé\n\n==================================================\n\nver the net few weeks,  am going to make a series of posts that is going to be a large overview of the possibilities for scalability of thereum, intending to create a precise understanding of the problems at bay in implementing a scalable cryptocurrency infrastructure, and where the least-bad tradeoffs and sacrifices required to solve those problems might lie. s a general outline of the form that this series is going to take,  intend to first discuss the fundamental problem with thereum . as it stands, as well as every other cryptocurrency platform in eistence, and introduce limited solutions to specific problems that allow for much more efficiency - in some cases increasing efficiency by a constant factor, and in other cases making a more fundamental compleity-theoretic improvement - but only in very specific use cases. n later posts,  will discuss further and further generalizations of such mechanisms, and finally culminating in the ultimate generalization applying the tactics that  describe to make certain programs run better inside of thereum to thereum itself - providing at least one route to thereum ..nnundamentally, the problem of scaling up something like itcoin and thereum is an etremely hard one the consensus architectures strongly rely on every node processing every transaction, and they do so in a very deep way. here do eist protocols for "light clients" to work with thereum, storing only a small part of the blockchain and using erkle trees to securely access the rest, but even still the network relies on a relatively large number of full nodes to achieve high degrees of security. caling up to isa or  levels of transaction volume is possible, but only at the cost of sacrificing decentralization as only a very small number of full nodes will survive. f we want to reach such levels, and go even higher with micropayments, we need to develop a consensus architecture which achieves a fundamental improvement over "every node processing every transaction". owever, as it turns out, there is a lot that we can do without going that far.nnrotocol enhancementsnnmage fromnnhttps//bitcoin.org/en/developer-guidennhe first step in increasing space efficiency is some structural alterations to the protocol - alterations that have already been part of thereum since day one. he first is a shift from -based architecture to account-based architecture. he itcoin blockchain relies on a concept of "unspent transaction outputs" - every transaction contains one or more inputs and one or more outputs, with the condition that each input must reference a valid and unspent previous output and the total sum of the outputs must be no greater than the total sum of the inputs. his requires transactions to be large, often containing multiple signatures from the same user, and requires about  bytes to be stored in the database for every transaction that a node receives. t is particularly inconvenient when you have an account that very many people are sending small payments to in the case of ethereum.org, it will take us hundreds of transactions to clear ournneodus addressnn.nnipple and thereum instead use a more conventional system of transactions depositing to and withdrawing from accounts, ensuring that each account takes up only about  bytes on the blockchain regardless of its level of usage.  second protocol adjustment, used by both ipple and thereum, is that of storing the full blockchain state in annatricia treennin every block. he atricia tree structure is designed to include maimal deduplication, so if you are storing many nearly-identical atricia trees for consecutive blocks you only need to store most of the data once. his allows nodes to more easily "start from the middle" and securely download the current state without having to process the entire history.nnhese schemes are, of course, counterbalanced by the fact that thereum opens itself up to a wider array of applications and thus a much more active array of usage, and at the end of the day such optimizations can only go so far. hus, to go further, we need to go beyond tweaks to the protocol itself, and build on top.nnatchingnnn itcoin, one transaction that spends ten previously unspent outputs requires ten signatures. n thereum, one transaction always requires one signature (although in the case of constructions like multisig accounts multiplenntransactionsnnmay be needed to process annwithdrawalnn). owever, one can go even further, and create a system where ten withdrawals only require one transaction and one signature. his is another constant-factor improvement, but a potentially rather powerful one batching.nnhe idea behind batching is simple put multiple sends into a single transaction in the data fields, and then have a forwarding contract split up the payment. ere is the simple implementation of such a contractnninnnnnnwhilenninnnnmsg.datasizennsendnn(nnmsg.datannnninn]nn, msg.datannnni+nn]nn)nninn+nnnne can also etend it to support forwarding messages, using some low-level  commands in serpent to do some byte-by-byte packingnninitnncontract.storagennnnnn]nnnnmsg.sendernncodennifnnmsg.sendernn!nncontract.storagennnnnn]nnnnstopnninnnnnnwhilenninnnn~calldatasizenn(nn)nnnntonnnn~calldataloadnn(nninn)nnvaluennnn~calldataloadnn(nni+nn)nn/nnnn^nndatasizennnn~calldataloadnn(nni+nn)nn/nnnn^nndatannnnallocnn(nndatasizenn)nn~calldatacopynn(nndata, i+, datasizenn)nn~callnn(nnt.gas -nnnn, to, value, data, datasize,nnnn,nnnn)nninn+nnnn+ datasizennnstead of using your normal account to interact with contracts, the idea is that you would store your funds and maintain your relationships with contracts using this account, and then you will be able to make as many operations as you need all at once with a single transaction.nnote that this scheme does have its limits. lthough it can arbitrarily magnify the amount of work that can be done with one signature, the amount of data that must be spent registering the recipient, value and message data, and the amount of computational resources that must be spent processing the transactions, still remains the same. he importance of signatures is not to be underestimated signature verification is likely the most epensive part of blockchain validation, but the efficiency gain from using this kind of mechanism is still limited to perhaps something like a factor of four for plain old sends, and even less for transactions that involve a lot of computation.nnicropayment hannelsnn common dream application of cryptocurrency is the idea of micropayments - having markets on very tiny chunks of computational or physical resources, paying for electricity, internet bandwidth, file storage, road usage or any other micro-meterable good one cent at a time. isting cryptocurrencies are certainly useful for much smaller payments than were possible before aypal charges a fied fee of $. per transaction, and itcoin currently charges ~$., making it logical to send payments as low as  cents in size. owever, if we want to pay $. at a time, then we need a much better scheme. here is no easy universal scheme to implement if there was, that would be thereum .. ather, there is a combination of different approaches, where each approach is suited for a particular use case. ne common use case is micropayment channels situations where one party is paying the other over time for a metered service (eg. a file download), and the transaction only needs to be processed at the end. itcoin supports micropayment channels thererum does as well, and arguably somewhat more elegantly.nnhe channel works roughly as follows the sender sends a transaction to initialize a channel, specifying a recipient, and the contract initializes a channel with value zero and supplies an  for the channel. o increase the payment on the channel, the sender signs a data packet of the formnnid, value]nn, withnnvaluennbeing the new value to transmit. hen the channel process is done, and the recipient wants to cash out, he must simply take the signednnid, value, v, r, s]nnpacket (thennv,r,snntriple being an elliptic curve signature) and push it to the blockchain as transaction data, and the contract verifies the signature. f the signature is valid, the contract waits  blocks for a higher-valued packet for the transaction  to be sent, and can then be pinged again to send the funds. ote that if the sender tries to cheat by submitting an earlier packet with a low value, the receiver has the  block interval to submit the higher-valued packet. he code for the validator is as followsnn# reate channel , to]nnifnnmsg.datannnnnn]nnnnnnnnnew_idnnnncontract.storagennnn-nn]nn# store from, to, value, mavalue, timeout] in contract storagenncontract.storagennnnnew_idnn]nnnnmsg.sendernncontract.storagennnnnew_id +nnnn]nnnnmsg.datannnnnn]nncontract.storagennnnnew_id +nnnn]nnnnnncontract.storagennnnnew_id +nnnn]nnnnmsg.valuenncontract.storagennnnnew_id +nnnn]nnnnnn^nn# increment net idnncontract.storagennnn-nn]nnnnnew_id +nnnn# return id of this channelnnreturnnn(nnnew_idnn)nnelif msg.data]  
id  msg.data] % ^ # heck if timeout has run out
if block.number  contract.storageid + ] # end funds
send(contract.storageid + ], contract.storageid + ]) # end refund
send(contract.storageid], contract.storageid + ] - contract.storageid + ]) # lear storage
contract.storageid]  
contract.storageid + ]  
contract.storageid + ]  
contract.storageid + ]  
contract.storageid + ]  nnnd there we go. ll that is needed now is a decent off-chain user interface for processing the consumer-merchant side of the transaction.nnrobabilistic icropaymentsnnut even still, micropayment channels are not a panacea. hat if you only need to pay $. to download a   file from someone, so even the entire transaction is not worth the single final transaction fee or this, we do something slightly more clever probabilistic micropayments. ssentially, a probabilistic micropayment occurs when a sender performs an action whichnnprovably has a specified probabilitynnof allowing a certain payment to happen in the future here, we might do a .% chance of paying $. n the long term, both epenses and receipts will be roughly the same as in the non-probabilistic model, but with the benefit of saving % on transaction fees.nno, how do we do probabilistic micropayments he general approach is to have the payment be a signed data packet of the formnnnonce, timeout, to, value, prob]nn, wherennnoncennis a random number,nntimeoutnnis a near-future block number,nntonnis the recipient,nnvaluennis the amount of ether to send andnnprobnnis the probability of sending multiplied by nnnn, and then when the block number surpassesnntimeoutnnallow the data packet to be supplied to the blockchain and cashed out only if a random number generator, seeded with the nonce, supplies a value which mod nnnnis less thannnprobnn.nnssuming a random number generator, the code snippet for the basic receiving function isnn# ash out , nonce, timeout, to, value, prob, v, r, s]nnifnnmsg.datannnnnn]nnnnnnnn# elper contracts (addresses obviously won't work on testnet or livenet)nnecrecovernnnnadbbdbfddffnnrandomnnnnbdafafcadeafbcfcdbnn# ariablesnntimeoutnnnnmsg.datannnnnn]nntonnnnmsg.datannnnnn]nnvaluennnnmsg.datannnnnn]nnprobnnnnmsg.datannnnnn]nn# s it time to cash outnnifnnblock.numbernnnntimeoutnn# andomnessnnifnncallnn(nnrandom,nnnnnn, nonce, timeoutnn]nn,nnnn)nn%nnnn^nnnnmsg.datannnnnn]nnnn# etermine sendernnhnnnnshann(nnslicenn(nnmsg.data,nnnn)nn,nnnn)nnsendernnnncallnn(nnecrecover,nnnnh, msg.datannnnnn]nn, msg.datannnnnn]nn, msg.datannnnnn]nn]nn,nnnn)nn# ithdrawnnifnncontract.storagennnnsendernn]nnnnvaluenncontract.storagennnnsendernn]nn-nnnnvaluennsendnn(nnto, valuenn)nnhere are two "hard parts" in the implementation of this approach. ne is double-spending attacks, and the other is how to build the random number generator. o defeat double-spending attacks, the strategy is simple require a very high security deposit in the contract alongside the account's ether balance available for sending. f the sendable balance drops below zero, destroy the entire deposit.nnhe second part is, of course, how to build a random number generator in the first place. enerally, the main source of randomness used in thereum is block hashes because micropayments are low-value applications, and because the different nonce on each transaction ensures that a block hash is etremely unlikely to favor any particular user in any particular way, block hashes will likely be sufficient for this purpose - however, we need to make sure we grab annspecificnnblock hash rather than simply the block hash when a request is sent (using the block hash when a request is sent also works, but less well, since the sender and receiver have an incentive to try to disrupt each other's attempts to send claim transactions during blocks that are unfavorable to them). ne option is to have a centralized contract maintain a list of the block hash for every block, incentivizing miners to ping it every block the contract can charge a micropayment for its  in order to pay for the service. or efficiency, one can limit the contract to providing a reward once every ten blocks. n the event that the contract skips over a block, the net block hash is used.nnhe code for the one-every-ten-blocks version isnn# f we get pinged for the first time in a new epoch, set the prevhashnnifnn!nncontract.storagennnnblock.number /nnnn]nnnnsendnn(nnmsg.sender,nnnn^nn)nncontract.storagennnnblock.number /nnnn]nnnnblock.prevhashnn# therwise, provide the block hash , block number]nnifnnmsg.datannnnnnand msg.valuennnnnn^nnreturnnn(nncontract.storagennnnmsg.datannnnnn]nn/nnnn]nn)nnn order to convert this into a suitable implementation of thennrandomnncontract, we just donn# f we get pinged for the first time in a new epoch, set the prevhashnnifnn!nncontract.storagennnnblock.number /nnnn]nnnnsendnn(nnmsg.sender,nnnn^nn)nncontract.storagennnnblock.number /nnnn]nnnnblock.prevhashnn# therwise, provide the hash of the block hash plus a nonce , block number, nonce]nnifnnmsg.datannnnnnand msg.valuennnnnn^nnreturnnn(nnshann(nnnncontract.storagennnnmsg.datannnnnn]nn/nnnn]nn, msg.datannnnnn]nn]nn,nnnn))nnote that for something like this to work efficiently, one "higher-level" piece of infrastructure that needs to eist is some kind of incentivized pinging. his job can be done cooperatively with a pub/sub contract a contract can be made which other contracts subscribe to, paying a very small fee, and when the contract gets pinged for the first time in  blocks it provides a single reward and immediately pings all of the contracts that subscribed to it. his strategy is still vulnerable to some abuse by miners, but the low-value nature of micropayments and the independence of each payment should limit the problem drastically.nnff-chain oraclesnnollowing the spirit of signature batching, an approach that goes even further is to take the entire computation off the blockchain. n order to do so securely, we use a clever economic hack the code still goes on the blockchain, and gets recorded there, but by default the computation is decided by oracles which run the code off-chain in a private  and supply the answer, also providing a security deposit. hen the answer is supplied, it takes  blocks until the answer is committed if everything goes well, the answer can be committed to the blockchain after  blocks, and the oracle recovers its deposit and a small bonus. owever, within that -block interval, any node can check the computation themselves, and if they see that the oracle is wrong they can pay for an auditing transaction - essentially, actually run the code on the blockchain, and see if the result turns out to be the same. f it does not, then the auditor gets % of the block reward and the other % is destroyed.nnssentially, this provides near-equivalent assurances to every node running the code, ecept that in practice only a few nodes do. articularly, if there is a financial contract, the parties to the financial contract have a strong incentive to carry out the audit, because they are the ones who would be screwed over by an invalid block. his scheme is elegant, but somewhat inconvenient it requires users to wait  blocks before the results of their code can be used.nno solve that problem, the protocol can be etended even further. ow, the idea is to create an entire "shadow chain", with computations happening off-chain but state transitions being committed back to the main chain after  blocks. racles can add new blocks to the "tail" of the chain, where a block consists of a list of transactions and annk, v], k, v] ... ]nnlist of state transitions caused by those transactions. f a block is unchallenged for  blocks, the state transitions are applied automatically to the main chain. f the block is successfully challenged before it is committed then that block and all children are reverted, and the block and all children lose their deposits with part going to the auditor and part to the void (note that this creates etra incentive to audit, since now the author of the child of a shadow block would prefer to audit that shadow block lest they be caught up in the author's potential malfeasance). he code for this is much more complicated than the other eamples a complete but untested version can be foundnnherenn.nnote that this protocol is still a limited one it solves the signature verification problem, and it solves the state transition computation problem, but it still does not solve the data problem. very transaction in this model must still be downloaded by every node. ow do we do even better s it turns out, we probably can however, to go further than this we have to solve a much larger problem the problem of data.