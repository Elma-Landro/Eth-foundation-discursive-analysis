Titre: The 1.x Files: a fast-sync\nAuteur: Griffin Ichiba Hotchkiss\nDate: December 10, 2019\nURL: https://blog.ethereum.org/2019/12/10/eth1x-files-fast-sync\nCatÃ©gorie: Non catÃ©gorisÃ©\n\n==================================================\n\n. a fast syncnnhennnew direction of  . researchnnhas begun proper, with a focus on moving the current thereum chain towards the 'stateless client' paradigm, with the eventual target being a smooth transition into an th . ecution nvironment.nnhe net call will be focused on collecting and organizing research topics and planning a more structured roadmap. he call is open for anyone to attend, and is scheduled for ecember th at   -- if you would like to join, please  iper erriam or ames ancock on thennethresear.ch forumnn.nnhis post is a re-cap of everything that's brought us to where we are now, and may be resource for anyone that may have recently joined the thereum community, missed the thereum . discussions as they happened, or is in need of a little memory refresh.nnn the spirit ofnn--sync-modefastnn, we'll be touching on most of the historical topics of research, and save the in-depth look into stateless clients and current research for a subsequent post.nnur story begins with a realization by core developers that the final phase of the thereum roadmap, "erenity", would not be ready as early as originally hoped. ith potentially many years before a full "thereum ." roll-out, the current chain would need changes to ensure that larger problems that wouldn't render thereum in-operable before a comprehensive protocol upgrade could be delivered. ence, "thereum .nnnn" -- research into smaller, incremental upgrades to current thereum (.) -- was born with the task of prolonging the life of the chain for at least another - years, before a more dramatic upgrade to erenity (th .) arrives.nnhat's the problemnnt's complicated. nlike a security vulnerability or major design flaw, there is no single pressing issue that we can identify with thereum . and put forward focused resources in order to correct. imilarly, if things are left entirely un-touched, there will likely be no one dramatic event that causes the network to halt and catch fire ðŸ”¥.nnather, the pocalypse scenario arose from small, subtle degradations of performance and diminishing network health as a result of natural chain growth. ithout . efforts, over time thereum runs the risk of becoming more centralized as it becomes harder to run full nodes, slower as network latency increases and block verification gets harder due to state bloat, and ultimately too frustrating for end users and core developers alike as transaction throughput hits an upper limit and client improvements become harder to implement. he goal then was to avoid a death by a thousand cuts scenario that would take years to play out and be recognized too late by beginning to plan immeditely, beginning at evcon in rague (ðŸ¦„  ðŸ’€).nnroadly speaking, the issues at hand are all aspects of one fundamental and unremarkable realitynnhe blockchain just keeps getting bigger,nnbut there's some nuance here, and when we talk about "the size of the blockchain", we are really talking about the size of a few different sub-components, and more importantly about how their size affects the performance of the network.nnet's cover them one by one!nnhain storagenn"f anyone so much as utters a word about "storage costs of blockchain," just send them to the mazon lack riday web page.  for $. here are real problems blockchains face. torage costs are not one of them.
--min Ã¼n irer (nnelthornn)nnefore a full node can become a first-class citizen of thereum, it must sync the entire history of the blockchain. he longer that history is, the more data there is to store. urrently, storage requirements are about   for a 'normal' full node in both parity and geth, and growing by -  every month.nnhis isn'tnntoo badnn, from an absolute cost-of-storage perspective. t has always been the vision of thereum to run entirely on consumer hardware, and ecluding archive nodes (which require ~. ), under  is well within a reasonable threshold, so running a full node won't be out-of-reach for another couple of years. he stronger argument to be made concerns thennmarginal costnnof spinning up new full nodes ncreasing storage requirements and sync times lead to fewer full nodes, which leads to even longer syncing times, and fewer nodes still.nnver time, developers will lean more and more on services like nfura, and the 'real' blockchain will be increasingly stuck up in the cloud, out of reach for average hobbyists, researchers, and casual developers.nnlock size and transaction throughputnn different aspect of growth is the size of individual blocks, and their relationship to total transaction throughput. nlike itcoin, thereum does not eplicitly limit the size of a block by memory, but enforces the block size through anngas limitnn. he gas limit in thereum effectively caps the number of transactions that can be included in a block, and is decided collectively by miners, with a vote to increase or decrease the gas limit dynamically. ecently, miners collectively agreed to increase the block gas limit to around  million gas units, making each block about % larger than it had been since an '' -- and, by etension, boosting theoretical transaction throughput.nnhere is a trade-off between the block gas limit and the ability of miners to reach consensus on new blocks. arger gas limits theoretically will increase the rate of block uncles (valid blocks that don't propagate to other miners quickly enough to be accepted by a majority). ore data needs to be collected on what a 'safe' upper bound is for block sizes, but it's generally accepted that throughput gains to be had from increasing the gas limit are not going to be sufficient for thereum's growth in the net  years. dditionally, bigger block sizes accelerate the chain storage requirement problem.nntate size and etwork erformancennthereum is annstate machine that moves forward one step with each blocknn. t any given moment, the complete 'state' of thereum comprises the collective memories of all smart contracts deployed and running in the , as well as the current status of all accounts and balances. hen transactions are added to a block, they modify the state by changing the balances of accounts, deploying new smart contract code, or by causing a smart contract to eecute some of its code.nnhe total size of state currently weighs in on the order of . t stands to reason that the state grows proportionally with the total transaction volume on the network, so if we epect thereum to continue to gain mainstream adoption, that number could grow by an order of magnitude in the years to come.nn larger state affects all clients along two major points of performancennlower transaction processing due to limits of clients reading from statenn. rocessing a transaction requires reading the relevant part of the state stored in the client's database. he larger the state, the longer it takes to lookup the transaction. mportantly, in clients that use a trie structure to represent state (parity, geth, trinity), this slowdown is compounded by the underlying database lookup (in which the trie is implemented).nnlower block verification due to constructing new state from modificationsnn. long the same lines of reasoning as above, when a new block is verified the changes to state must be re-computed by the client this involves building a new state trie and computing a new root hash. onstructing a new state trie is more computationally intensive than a simple lookup, so this operation is more dramatically affected by state growth than processing a single transaction.nntate-driven performance degradation is most worrying. thereum is a peer to peer network, which means that subtle changes can have cascading effects on network health. urthermore, state storage and modification is one of the more difficult things to implement for client developer teams. riting and maintaining clients is already hard enough, and state growth adds to that burden. s the state grows, the diversity and performance of clients will diminish, which is bad for everyone.nnhat are the potential solutionsnntarting with the initial meeting in rague, and continuing through , various core developers, contributors, and magicians have gathered both on-line and  to discuss the best ways of etending the life of the . chain. ere are the most important proposals discussed and what they entailnnodest optimizations and mitigationsnnore aggressive pruningnn. ne way to manage storage requirements is to actively delete pieces of the chain that are no longer needed, such as transaction receipts, logs, and older historical blocks. n agreed upon time period (- months) of historical data would be kept by full nodes, and then deleted after it epired, effectively capping the total storage needed to run a node. Ã©ter zilÃ¡gyi provided anncomprehensive overviewnnof chain pruning effects for long-term viability.  -- there are trade-offs, and one unsolved requirement is that historical data be available (somewhere),nnandnnin lieu of full chain history, nodes must maintain proofs for deleted chain segments.nnlock pre-announcement and state cachingnn. hese relate to mitigating the effects of network latency. n block pre-announcement, the idea is that a miner announces a new blocknnbefore it is validatednn, which gives listening clients a chance to guess at which parts of state will be affected and preemptively warn those caches for the net state. imilarly, clients could hold partial states in memory so that they don't have to start from scratch again if syncing the state fails. hese optimizations are within reach currently, and variations on this theme are already employed by turbo-geth to improve performance.nnig, hard-forking changesnnpcode re-pricing and  lockupsnn. enerally, this means simply tuning the costs of opcodes further discourage state growth. roadly, this means increasing the cost of operations that grow state, and/or increasing the rewards for operations that shrink state. efunds, however, are a bit tricky, because they must come from gas included with the transaction -- this means that transactions whichnnonlynnclear memory or destruct contracts can't actually receive proportional refunds. n order to have transactions that make more in gas than they spend, it would be possible to require contracts to lock up a bit of  when deployed, enough to cover those refunds.nntate rent and 'eviction'nn. ore dramatic than the above opcode price changes, state rent concerns directly reducing the size of state by requiring that contracts pay a recurring fee proportional to their share of the state size. he contract would be deleted or halted until the fee is paid. his would be a major, breaking change to smart contracts and dapp developers, and would require more than one hard-fork to implement. t remains to date the most etensively discussed proposal in the category of ., as well as the most controversial. onsequently, research into state rent on the . chain has been suspended.nnhe new direction âœ¨tateless lientsâœ¨nnf it's the size of state causing the biggest problems for network health, the ultimate solution would be to do away with the need for state altogether. n a nutshell, a stateless client makes use of annblock witnessnn, which proves the validity of a given state change against the previous state. hat is to say, rather than computing a complete state with each new block, clients simply compute thennchangesnnto state for a new block, and then prove that those changes are consistent with the previous block. iners and some full nodes will still need to keep a full copy of state for witnesses to be generated from, and the need for block witnesses to be gossiped around the network introduces some new challenges for clients, but the potential benefits of this change are vast.nnote his is still very early stage research and shouldn't be regarded as an accepted part of the thereum roadmap or in any way 'proven' as a concept. tateless clients have many major technical hurdles to overcome, all of which will be elucidated in subsequent updates as research continues.nnhe stateless client conceptnnfirst appeared in the thereum landscape in a post by italik in the contet of sharding, but was also discussed later during th . discussions at the time it was thought too comple to implement. ore recently, however, the stateless client concept has gained support asnnrinity's beam syncnndemonstrates the feasibility of semi-statelessness for light clients.nnmportantly, moving towards a stateless or semi-stateless paradigm is less disruptive to the eisting network than something like state rent because it does not inherently create breaking changes for eisting clients. tateful nodes and stateless light clients can eist side-by-side, and the introduction of semi-stateless thereum offers more opportunity for eperimentation with different client implementations. s icing on the layer-cake, shards on th . will almost certainly be stateless, which opens up a new path toward an eventual migration to erenity when it's ready for the prime-time.nne'll leave a deeper dive into stateless clients for another post. f you made it this far, you're now caught up with the current state of thereum . research, and should be able to follow along and join in on new developments as they happen! oin us at ethresear.ch, or stay tuned here for the net edition of 'the . files' )