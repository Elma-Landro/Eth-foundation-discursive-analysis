Titre: Serenity PoC2\nAuteur: Vitalik Buterin\nDate: March 5, 2016\nURL: https://blog.ethereum.org/2016/03/05/serenity-poc2\nCatégorie: Non catégorisé\n\n==================================================\n\nfter an additional two months of work after the release of the first python proof of concept release of erenity,  am pleased to announce that erenity onnis now availablenn. lthough the release continues to be far from a testnet-ready client, much less a production-ready one, o brings with it a number of important improvements. irst and foremost, the goal of o was to implement the complete protocol, including the basic corner cases (slashing bets and deposits), so as to make sure that we have a grasp of every detail of the protocol and see it in action even if in a highly restricted test environment. his goal has been achieved. hereas o included only the bare minimum functionality needed to make asper and   run, o includes essentially the full asper/erenity protocol,   and  included.nnhe specific features that can be found in o that were not available in o are as followsnn  implementationnn-   is the "sharding scaffolding" , which will allow processing thereum transactions to be somewhat parallelized, and will set the stage for a later sharding scheme (which is yet to be determined). t uses the binary tree sharding mechanism describednnherennto allow transactions to specify an "activity range" which restricts the addresses that transaction eecution can touch, guaranteeing that sets of transactions with disjoint activity ranges can be processed in parallel. t also introducesnnnnandnnnnopcodes to allow contracts to access storage of the same address in other shards (provided that the target shard is within the activity range) this mechanism essentially means that the binary shard tree serves as a super-contract sharding mechanism and a sub-contract sharding mechanism at the same time.nnas checkingnn- the algorithm that pattern-matches a transaction to make sure that it correctly pays gas. urrently, this is accomplished by only accepting transactions going to accounts that have a particular piece of "nnmandatory account codenn", which gives the account holder freedom to specify two pieces of code the checker code and the runner code. hecker code is meant to perform quick checks such as signature and nonce verification the pattern-matching algorithm gives a maimum of , gas for the checker code to run. unner code is meant to perform any epensive operations that the transaction needed to carry out (eg. calling another contract with more than , gas). he main practical consequence of this is that users will be able to pay for gas directly out of contracts (eg. multisig wallets, ring signature miers, etc) and will not need to separately always have a small amount of  in their primary account in order to pay for gas - as long as the gas payment from the contract is made within , gas all is good.nning signature miernn- part of the test.py script now includes creating an instance of annring signature verification contractnnwhich is designed as a mier five users send their public keys in alongside a deposit of . , and then withdraw the .  specifying the address with a linkable ring signature, simultaneously guaranteeing that (i) everyone who deposited .  will be able to withdraw .  eactly once, and (ii) it's impossible to tell which withdrawal corresponds to which deposit. his is implemented in a way that is compliant with the gas checker, providing the key advantage that the transaction withdrawing the .  does not need to be sent from an additional account that pays gas (something which a ring signature implementation on top of the current ethereum would need to do, and which causes a potential privacy leak at the time that you transfer the  to that account to pay for the gas) instead, the withdrawal transaction can simply be sent in by itself, and the gas checker algorithm can verify that the signature is correct and that the mier will pay the miner a fee if the withdrawal transaction gets included into a block.nnore precise numbers on interest rates and scoring rule parametersnn- the scoring rule (ie. the mechanism that determines how much validators get paid based on how they bet) is now a linear combination of a logarithmic scoring rule and a quadratic scoring rule, and the parameters are such that (i) betting absolutely correctly immediately and with maimal "bravery" (willingness to converge to % quickly) on both blocks and stateroots will get you an epected reward of ~. parts per billion per block, or .% base annual return, (ii) there is a penalty of  parts per billion per block, or ~.% annual, that everyone pays, hence the epected net return from betting perfectly is ~ parts per billion per block, or ~% annual. etting absolutely incorrectly (ie. betting with maimum certainty and being wrong) on any single block or state root will destroy % of your deposit, and betting somewhat incorrectly will cause a much less etreme but still negative return. hese parameters will continue to be adjusted so as to make sure that realistic validators will be able to be reasonably profitable.nnore precise validator induction rulesnn- maimum  validators, minimum ether amount starts off at   and goes up hyperbolically with the formulannmin   *  / ( - v)nnwherennvnnis the current active number of validators (ie. if there are  validators active, the minimum becomes  , if there are  validators active it becomes  , if there are  validators active it becomes  ). hen you are inducted, you can make bets and earn profits for up to  million seconds (~ year), and after that point a special penalty of  parts per billion per block starts getting tacked on, making further validation unprofitable this forces validator churn.nnew precompilesnnincluding  and  (critical for ring signatures), ,  decoding and the "gas deposit contract" (a mechanism used in the mandatory account code to pay for gas theoretically it could be written in  code if need be but there may be efficiency concerns with that)nnearchitecting of  and  as precompilesnn- the opcodes still eist for backwards compatibility purposes, but they simply call the precompile addresses. his is a further move in the direction of "abstraction".nnew mechanism for betting directly on state rootsnnogic for detecting and slashing double bets and double blocksnnogic for coming to consensus at a height even if a validator produced multiple blocks at that heightnnhe protocol decisions made here are by no means final many of them are still actively being debated within the research channels. he net few rounds of o releases will thus move toward creating something resembling a erenity node implementation, alongside a proper pp networking layer, with the eventual goal of running a erenity testnet between multiple computers at the same time, our research team will continue hammering away at the finer details of the protocol and make sure that every single protocol decision is made correctly and well justified.nndditionally, we will be coming out with more accessible materials on the asper protocol specification and design rationale in the net few weeks, covering both the broad consensus-by-bet concept as well as specific design decisions ranging from validator induction rules to betting mechanisms and block proposer selection.