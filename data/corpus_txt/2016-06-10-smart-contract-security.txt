Titre: Smart Contract Security\nAuteur: Christian Reitwiessner\nDate: June 10, 2016\nURL: https://blog.ethereum.org/2016/06/10/smart-contract-security\nCatégorie: Non catégorisé\n\n==================================================\n\nolidity was started in ctober  when neither the thereum network nor the virtual machine had any real-world testing, the gas costs at that time were even drastically different from what they are now. urthermore, some of the early design decisions were taken over from erpent. uring the last couple of months, eamples and patterns that were initially considered best-practice were eposed to reality and some of them actually turned out to be anti-patterns. ue to that, we recently updated some of thennolidity documentationnn, but as most people probably do not follow the stream of github commits to that repository,  would like to highlight some of the findings here.nn will not talk about the minor issues here, please read up on them in thenndocumentationnn.nnending thernnending ther is supposed to be one of the simplest things in olidity, but it turns out to have some subtleties most people do not realise.nnt is important that at best, the recipient of the ether initiates the payout. he following is annnneample of an auction contractnn//     nn!nn  nn!nncontract auctionnn{nnaddress highestiddernnnnuint highestidnnnnfunctionnnbidnn(nn)nn{nnifnn(nnmsg.valuennnnhighestidnn)nnthrownnnnifnn(nnhighestiddernn!nnnn)nnhighestidder.sendnn(nnhighestidnn)nnnn// refund previous biddernnhighestiddernnnnmsg.sendernnnnhighestidnnnnmsg.valuennnn}nn}nnecause of the maimal stack depth of  the new bidder can always increase the stack size to  and then callnnbid()nnwhich will cause thennsend(highestid)nncall to silently fail (i.e. the previous bidder will not receive the refund), but the new bidder will still be highest bidder. ne way to check whethernnsendnnwas successful is to check its return valuenn///      nn!nn  nn!nnifnn(nnhighestiddernn!nnnn)nnifnn(nn!nnhighestidder.sendnn(nnhighestidnn))nnthrownnnnhennthrownnstatement causes the current call to be reverted. his is a bad idea, because the recipient, e.g. by implementing the fallback function asnnfunctionnn(nn)nn{nnthrownnnn}nncan always force the ther transfer to fail and this would have the effect that nobody can overbid her.nnhe only way to prevent both situations is to convert the sending pattern into a withdrawing pattern by giving the recipient control over the transfernn///      nn!nn  nn!nncontract auctionnn{nnaddress highestiddernnnnuint highestidnnnnmappingnn(nnaddressnnnnnnuintnn)nnrefundsnnnnfunctionnnbidnn(nn)nn{nnifnn(nnmsg.valuennnnhighestidnn)nnthrownnnnifnn(nnhighestiddernn!nnnn)nnrefundsnnnnhighestiddernn]nn+nnhighestidnnnnhighestiddernnnnmsg.sendernnnnhighestidnnnnmsg.valuennnn}nnfunctionnnwithdrawefundnn(nn)nn{nnifnn(nnmsg.sender.sendnn(nnrefundsnnnnmsg.sendernn]nn))nnrefundsnnnnmsg.sendernn]nnnnnnnn}nn}nnhy does it still say "negative eample" above the contract ecause of gas mechanics, the contract is actually fine, but it is still not a good eample. he reason is that it is impossible to prevent code eecution at the recipient as part of a send. his means that while the send function is still in progress, the recipient can call back into withdrawefund. t that point, the refund amount is still the same and thus they would get the amount again and so on. n this specific eample, it does not work, because the recipient only gets the gas stipend ( gas) and it is impossible to perform another send with this amount of gas. he following code, though, is vulnerable to this attacknnmsg.sender.call.value(refundsmsg.sender])()nn.nnaving considered all this, the following code should be fine (of course it is still not a complete eample of an auction contract)nncontract auctionnn{nnaddress highestiddernnnnuint highestidnnnnmappingnn(nnaddressnnnnnnuintnn)nnrefundsnnnnfunctionnnbidnn(nn)nn{nnifnn(nnmsg.valuennnnhighestidnn)nnthrownnnnifnn(nnhighestiddernn!nnnn)nnrefundsnnnnhighestiddernn]nn+nnhighestidnnnnhighestiddernnnnmsg.sendernnnnhighestidnnnnmsg.valuennnn}nnfunctionnnwithdrawefundnn(nn)nn{nnuint refundnnnnrefundsnnnnmsg.sendernn]nnnnrefundsnnnnmsg.sendernn]nnnnnnnnifnn(nn!nnmsg.sender.sendnn(nnrefundnn))nnrefundsnnnnmsg.sendernn]nnnnrefundnnnn}nn}nnote that we did not use throw on a failed send because we are able to revert all state changes manually and not using throw has a lot less side-effects.nnsing hrownnhe throw statement is often quite convenient to revert any changes made to the state as part of the call (or whole transaction depending on how the function is called). ou have to be aware, though, that it also causes all gas to be spent and is thus epensive and will potentially stall calls into the current function. ecause of that,  would like to recommend to use itnnonlynnin the following situationsnn. evert ther transfer to the current functionnnf a function is not meant to receive ther or not in the current state or with the current arguments, you should use throw to reject the ther. sing throw is the only way to reliably send back ther because of gas and stack depth issues he recipient might have an error in the fallback function that takes too much gas and thus cannot receive the ther or the function might have been called in a malicious contet with too high stack depth (perhaps even preceding the calling function).nnote that accidentally sending ther to a contract is not always a  failure ou can never predict in which order or at which time transactions are added to a block. f the contract is written to only accept the first transaction, the ther included in the other transactions has to be rejected.nn. evert effects of called functionsnnf you call functions on other contracts, you can never know how they are implemented. his means that the effects of these calls are also not know and thus the only way to revert these effects is to use throw. f course you should always write your contract to not call these functions in the first place, if you know you will have to revert the effects, but there are some use-cases where you only know that after the fact.nnoops and the lock as imitnnhere is a limit of how much gas can be spent in a single block. his limit is fleible, but it is quite hard to increase it. his means that every single function in your contract should stay below a certain amount of gas in all (reasonable) situations. he following is a  eample of a voting contractnn///      nn!nn  nn!nncontract otingnn{nnmappingnn(nnaddressnnnnnnuintnn)nnvoteeightnnnnaddressnnnn]nnyesotesnnnnuint requiredeightnnnnaddress beneficiarynnnnuint amountnnnnfunctionnnvoteesnn(nn)nn{nnyesotes.pushnn(nnmsg.sendernn)nnnn}nnfunctionnntallyotesnn(nn)nn{nnuint yesotesnnnnfornn(nnuint innnnnnnninnnnyesotes.lengthnnnn++inn)nnyesotesnn+nnvoteeightnnnnyesotesnnnninn]nn]nnnnifnn(nnyesotesnnnnrequiredeightnn)nnbeneficiary.sendnn(nnamountnn)nnnn}nn}nnhe contract actually has several issues, but the one  would like to highlight here is the problem of the loop ssume that vote weights are transferrable and splittable like tokens (think of the  tokens as an eample). his means that you can create an arbitrary number of clones of yourself. reating such clones will increase the length of the loop in the tallyotes function until it takes more gas than is available inside a single block.nnhis applies to anything that uses loops, also where loops are not eplicitly visible in the contract, for eample when you copy arrays or strings inside storage. gain, it is fine to have arbitrary-length loops if the length of the loop is controlled by the caller, for eample if you iterate over an array that was passed as a function argument. utnnnevernncreate a situation where the loop length is controlled by a party that would not be the only one suffering from its failure.nns a side note, this was one reason why we now have the concept of blocked accounts inside the  contract ote weight is counted at the point where the vote is cast, to prevent the fact that the loop gets stuck, and if the vote weight would not be fied until the end of the voting period, you could cast a second vote by just transferring your tokens and then voting again.nneceiving ther / the fallback functionnnf you want your contract to receive ther via the regular send() call, you have to make its fallback function cheap. t can only use , gas which neither allows any storage write nor function calls that send along ther. asically the only thing you should do inside the fallback function is log an event so that eternal processes can react on the fact. f course any function of a contract can receive ether and is not tied to that gas restriction. unctions actually have to reject ther sent to them if they do not want to receive any, but we are thinking about potentially inverting this behaviour in some future release.