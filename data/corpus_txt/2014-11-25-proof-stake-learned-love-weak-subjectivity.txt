Titre: Proof of Stake: How I Learned to Love Weak Subjectivity\nAuteur: Vitalik Buterin\nDate: November 25, 2014\nURL: https://blog.ethereum.org/2014/11/25/proof-stake-learned-love-weak-subjectivity\nCatégorie: Non catégorisé\n\n==================================================\n\nroof of stake continues to be one of the most controversial discussions in the cryptocurrency space. lthough the idea has many undeniable benefits, including efficiency, a larger security margin and future-proof immunity to hardware centralization concerns, proof of stake algorithms tend to be substantially more comple than proof of work-based alternatives, and there is a large amount of skepticism that proof of stake can work at all, particularly with regard to the supposedly fundamental "nothing at stake" problem. s it turns out, however, the problems are solvable, and one can make a rigorous argument that proof of stake, with all its benefits, can be made to be successful - but at a moderate cost. he purpose of this post will be to eplain eactly what this cost is, and how its impact can be minimized.nnconomic ets and othing at takennirst, an introduction. he purpose of a consensus algorithm, in general, is to allow for the secure updating of a state according to some specific state transition rules, where the right to perform the state transitions is distributed among some economic set. n economic set is a set of users which can be given the right to collectively perform transitions via some algorithm, and the important property that the economic set used for consensus needs to have is that it must bennsecurely decentralizednn- meaning that no single actor, or colluding set of actors, can take up the majority of the set, even if the actor has a fairly large amount of capital and financial incentive. o far, we know of three securely decentralized economic sets, and each economic set corresponds to a set of consensus algorithmsnnwners of computing powernn standard proof of work, ornnaonn. ote that this comes in specialized hardware, and (hopefully) general-purpose hardware variants.nntakeholdersnn all of the many variants of proof of stakenn user's social networknn ipple/tellar-style consensusnnote that there have been some recent attempts to develop consensus algorithms based onnntraditional yzantine fault tolerancenntheory however, all such approaches are based on an -of- security model, and the concept of "yzantine fault tolerance" by itself still leaves open the question of which set the  should be sampled from. n most cases, the set used is stakeholders, so we will treat such neo- paradigms are simply being clever subcategories of "proof of stake".nnroof of work has a nice property that makes it much simpler to design effective algorithms for it participation in the economic set requires the consumption of a resource eternal to the system. his means that, when contributing one's work to the blockchain, a miner must make the choice of which of all possible forks to contribute to (or whether to try to start a new fork), and the different options are mutually eclusive. ouble-voting, including double-voting where the second vote is made many years after the first, is unprofitablem since it requires you to split your mining power among the different votes the dominant strategy is always to put your mining power eclusively on the fork that you think is most likely to win.nnith proof of stake, however, the situation is different. lthough inclusion into the economic set may be costly (although as we will see it not always is), voting is free. his means that "naive proof of stake" algorithms, which simply try to copy proof of work by making every coin a "simulated mining rig" with a certain chance per second of making the account that owns it usable for signing a block, have a fatal flaw if there are multiple forks, the optimal strategy is to vote on all forks at once. his is the core of "nothing at stake".nnote that there is one argument for why it might not make sense for a user to vote on one fork in a proof-of-stake environment "altruism-prime". ltruism-prime is essentially the combination of actual altruism (on the part of usersnnor software developersnn), epressed both as a direct concern for the welfare of others and the network and a psychological moral disincentive against doing something that is obviously evil (double-voting), as well as the "fake altruism" that occurs because holders of coins have a desire not to see the value of their coins go down.nnnfortunately, altruism-prime cannot be relied on eclusively, because the value of coins arising from protocol integrity is annpublic goodnnand will thus be undersupplied (eg. if there are  stakeholders, and each of their activity has a % chance of being "pivotal" in contributing to a successful attack that will knock coin value down to zero, then each stakeholder will accept a bribe equal to only % of their holdings). n the case of a distribution equivalent to the thereum genesis block, depending on how you estimate the probability of each user being pivotal, the required quantity of bribes would be equal to somewhere between .% and .% of total stake (or even less if an attack is nonfatal to the currency). owever, altruism-prime is still an important concept that algorithm designers should keep in mind, so as to take maimal advantage of in case it works well.nnhort and ong angennf we focus our attention specifically onnnshort-range forksnn- forks lasting less than some number of blocks, perhaps , then there actually is a solution to the nothing at stake problem security deposits. n order to be eligible to receive a reward for voting on a block, the user must put down a security deposit, and if the user is caught either voting on multiple forks then a proof of that transaction can be put into the original chain, taking the reward away. ence, voting for only a single fork once again becomes the dominant strategy.nnnother set of strategies, called "lasher ." (in contrast tonnlasher .nn, the original security deposit-based proof of stake algorithm), involves simply penalizing voters that vote on thennwrongnnfork, not voters that double-vote. his makes analysis substantially simpler, as it removes the need to pre-select voters many blocks in advance to prevent probabilistic double-voting strategies, although it does have the cost that users may be unwilling to sign anything if there are two alternatives of a block at a given height. f we want to give users the option to sign in such circumstances, a variant ofnnlogarithmic scoring rulesnncan be used (seennherennfor more detailed investigation). or the purposes of this discussion, lasher . and lasher . have identical properties.nnhe reason why this only works for short-range forks is simple the user has to have the right to withdraw the security deposit eventually, and once the deposit is withdrawn there is no longer any incentive not to vote on a long-range fork starting far back in time using those coins. ne class of strategies that attempt to deal with this is making the deposit permanent, but these approaches have a problem of their own unless the value of a coin constantly grows so as to continually admit new signers, the consensus set ends up ossifying into a sort of permanent nobility. iven that one of the main ideological grievances that has led to cryptocurrency's popularity is precisely the fact that centralization tends to ossify into nobilities that retain permanent power, copying such a property will likely be unacceptable to most users, at least for blockchains that are meant to be permanent.  nobility model may well be precisely the correct approach for special-purpose ephemeral blockchains that are meant to die quickly (eg. one might imagine such a blockchain eisting for a round of a blockchain-based game).nnne class of approaches at solving the problem is to combine the lasher mechanism described above for short-range forks with a backup, transactions-as-proof-of-stake, for long range forks. ao essentially works by counting transaction fees as part of a block's "score" (and requiring every transaction to include some bytes of a recent block hash to make transactions not trivially transferable), the theory being that a successful attack fork must spend a large quantity of fees catching up. owever, this hybrid approach has a fundamental flaw if we assume that the probability of an attack succeeding is near-zero, then every signer has an incentive to offer a service of re-signing all of their transactions onto a new blockchain in echange for a small fee hence, a zero probability of attacks succeeding is not game-theoretically stable. oes every user setting up their own node.js webapp to accept bribes sound unrealistic ell, if so, there's a much easier way of doing it sell old, no-longer-used, private keys on the black market. ven without black markets, a proof of stake system would forever be under the threat of the individuals that originally participated in the pre-sale and had a share of genesis block issuance eventually finding each other and coming together to launch a fork.nnecause of all the arguments above, we can safely conclude that this threat of an attacker building up a fork from arbitrarily long range is unfortunately fundamental, and in all non-degenerate implementations the issue is fatal to a proof of stake algorithm's success in the proof of work security model. owever, we can get around this fundamental barrier with a slight, but nevertheless fundamental, change in the security model.nneak ubjectivitynnlthough there are many ways to categorize consensus algorithms, the division that we will focus on for the rest of this discussion is the following. irst, we will provide the two most common paradigms todaynnbjectivenn a new node coming onto the network with no knowledge ecept (i) the protocol definition and (ii) the set of all blocks and other "important" messages that have been published can independently come to the eact same conclusion as the rest of the network on the current state.nnubjectivenn the system has stable states where different nodes come to different conclusions, and a large amount of social information (ie. reputation) is required in order to participate.nnystems that use social networks as their consensus set (eg. ipple) are all necessarily subjective a new node that knows nothing but the protocol and the data can be convinced by an attacker that their  nodes are trustworthy, and without reputation there is no way to deal with that attack. roof of work, on the other hand, is objective the current state is always the state that contains the highest epected amount of proof of work.nnow, for proof of stake, we will add a third paradigmnneakly subjectivenn a new node coming onto the network with no knowledge ecept (i) the protocol definition, (ii) the set of all blocks and other "important" messages that have been published and (iii) a state from less than  blocks ago that is known to be valid can independently come to the eact same conclusion as the rest of the network on the current state, unless there is an attacker that permanently has more than  percent control over the consensus set.nnnder this model, we can clearly see how proof of stake works perfectly fine we simply forbid nodes from reverting more than  blocks, and set  to be the security deposit length. hat is to say, if state  has been valid and has become an ancestor of at least  valid states, then from that point on no state ' which is not a descendant of  can be valid. ong-range attacks are no longer a problem, for the trivial reason that we have simply said that long-range forks are invalid as part of the protocol definition. his rule clearly is weakly subjective, with the added bonus that   % (ie. no attack can cause permanent disruption unless it lasts more than  blocks).nnnother weakly subjective scoring method isnneponential subjective scoringnn, defined as followsnnvery state  maintains a "score" and a "gravity"nnscore(genesis)  nn,nngravity(genesis)  nnscore(block)  score(block.parent) + weight(block) * gravity(block.parent)nn, wherennweight(block)nnis usually , though more advanced weight functions can also be used (eg. in itcoin,nnweight(block)  block.difficultynncan work well)nnf a node sees a new blocknn'nnwithnnnnas parent, then ifnnnnnis the length of the longest chain of descendants fromnnnnat that time,nngravity(')  gravity() * . ^ nnn(note that values other than . can also be used).nnssentially, we eplicitly penalize forks that come later.  has the property that, unlike more naive approaches at subjectivity, it mostly avoids permanent network splits if the time between the first node on the network hearing about block  and the last node on the network hearing about block  is an interval ofnnknnblocks, then a fork is unsustainable unless the lengths of the two forks remain forever within roughlynnknnpercent of each other (if that is the case, then the differing gravities of the forks will ensure that half of the network will forever see one fork as higher-scoring and the other half will support the other fork). ence,  is weakly subjective withnnnnroughly corresponding to how close to a / network split the attacker can create (eg. if the attacker can create a / split, thennn  .nn).nnn general, the "ma revert  blocks" rule is superior and less comple, but  may prove to make more sense in situations where users are fine with high degrees of subjectivity (ie.  being small) in echange for a rapid ascent to very high degrees of security (ie. immune to a % attack after  blocks).nnonsequencesnno what would a world powered by weakly subjective consensus look like irst of all, nodes that are always online would be fine in those cases weak subjectivity is by definition equivalent to objectivity. odes that pop online once in a while, or at least once every  blocks, would also be fine, because they would be able to constantly get an updated state of the network. owever, new nodes joining the network, and nodes that appear online after a very long time, would not have the consensus algorithm reliably protecting them. ortunately, for them, the solution is simple the first time they sign up, and every time they stay offline for a very very long time, they need only get a recent block hash from a friend, a blockchain eplorer, or simply their software provider, and paste it into their blockchain client as a "checkpoint". hey will then be able to securely update their view of the current state from there.nnhis security assumption, the idea of "getting a block hash from a friend", may seem unrigorous to many itcoin developers often make the point that if the solution to long-range attacks is some alternative deciding mechanism , then the security of the blockchain ultimately depends on , and so the algorithm is in reality no more secure than using  directly - implying that most , including our social-consensus-driven approach, are insecure.nnowever, this logic ignores why consensus algorithms eist in the first place. onsensus is a social process, and human beings are fairly good at engaging in consensus on our own without any help from algorithms perhaps the best eample is thennai stonesnn, where a tribe in ap essentially maintained a blockchain recording changes to the ownership of stones (used as a itcoin-likennzero-intrinsic-valuennasset) as part of its collective memory. he reason why consensusnnalgorithmsnnare needed is, quite simply, because humansnndo not have infinite computational powernn, and prefer to rely on software agents to maintain consensus for us.  oftware agents are very smart, in the sense that they can maintain consensus on etremely large states with etremely comple rulesets with perfect precision, but they are also very ignorant, in the sense that they have very little social information, and the challenge of consensus algorithms is that of creating an algorithm that requires as little input of social information as possible.nneak subjectivity is eactly the correct solution. t solves the long-range problems with proof of stake by relying on human-driven social information, but leaves to a consensus algorithm the role of increasing the speed of consensus from many weeks to twelve seconds and of allowing the use of highly comple rulesets and a large state. he role of human-driven consensus is relegated to maintaining consensus on block hashes over long periods of time, something which people are perfectly good at.  hypothetical oppressive government which is powerful enough to actually cause confusion over the true value of a block hash from one year ago would also be powerful enough to overpower any proof of work algorithm, or cause confusion about the rules of blockchain protocol.nnote that we do not need to fi  theoretically, we can come up with an algorithm that allows users to keep their deposits locked down for longer than  blocks, and users can then take advantage of those deposits to get a much more fine-grained reading of their security level. or eample, if a user has not logged in since  blocks ago, and % of deposits have term length greater than , then the user can come up with their own subjective scoring function that ignores signatures with newer deposits, and thereby be secure against attacks with up to .% of total stake. n increasing interest rate curve can be used to incentivize longer-term deposits over shorter ones, or for simplicity we can just rely on altruism-prime.nnarginal ost he ther bjectionnnne objection to long-term deposits is that it incentivizes users to keep their capital locked up, which is inefficient, the eact same problem as proof of work. owever, there are four counterpoints to this.nnirst, marginal cost is not total cost, and the ratio of total cost divided by marginal cost is much less for proof of stake than proof of work.  user will likely eperience close to no pain from locking up % of their capital for a few months, a slight amount of pain from locking up %, but would find locking up more than % intolerable without a large reward. dditionally, different users have very different preferences for how willing they are to lock up capital. ecause of these two factors put together, regardless of what the equilibrium interest rate ends up being, the vast majority of the capital will be locked up at far below marginal cost.nnecond, locking up capital is a private cost, but also a public good. he presence of locked up capital means that there is less money supply available for transactional purposes, and so the value of the currency will increase, redistributing the capital to everyone else, creating a social benefit. hird, security deposits are a very safe store of value, so (i) they substitute the use of money as a personal crisis insurance tool, and (ii) many users will be able to take out loans in the same currency collateralized by the security deposit. inally, because proof of stake can actually take away deposits for misbehaving, and not just rewards, it is capable of achieving a level of security much higher than the level of rewards, whereas in the case of proof of work the level of security can only equal the level of rewards. here is no way for a proof of work protocol tonndestroynnmisbehaving miners' s.nnortunately, there is a way to test those assumptions launch a proof of stake coin with a stake reward of %, %, %, etc per year, and see just how large a percentage of coins become deposits in each case. sers will not act against their own interests, so we can simply use the quantity of funds spent on consensus as a proy for how much inefficiency the consensus algorithm introduces if proof of stake has a reasonable level of security at a much lower reward level than proof of work, then we know that proof of stake is a more efficient consensus mechanism, and we can use the levels of participation at different reward levels to get an accurate idea of the ratio between total cost and marginal cost. ltimately, it may take years to get an eact idea of just how large the capital lockup costs are.nnltogether, we now know for certain that (i) proof of stake algorithms can be made secure, and weak subjectivity is both sufficient and necessary as a fundamental change in the security model to sidestep nothing-at-stake concerns to accomplish this goal, and (ii) there are substantial economic reasons to believe that proof of stake actually is much more economically efficient than proof of work. roof of stake is not an unknown the past si months of formalization and research have determined eactly where the strengths and weaknesses lie, at least to as large etent as with proof of work, where mining centralization uncertainties may well forever abound. ow, it's simply a matter of standardizing the algorithms, and giving blockchain developers the choice.