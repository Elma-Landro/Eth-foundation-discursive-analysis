Titre: Ethereum and Oracles\nAuteur: Vitalik Buterin\nDate: July 22, 2014\nURL: https://blog.ethereum.org/2014/07/22/ethereum-and-oracles\nCatégorie: Non catégorisé\n\n==================================================\n\nne of the more popular proposals for implementing smart contracts differently from the way they are typically presented in thereum is through the concept of oracles. ssentially, instead of a long-running contract being run directly on the blockchain, all funds that are intended to go into the contract would instead go into an -of- multisig address controlled by a set of specialized entities called "oracles", and the contract code would be simultaneously sent to all of these entities. very time someone wants to send a message to the contract, they would send the message to the oracles. he oracles would run the code, and if the code eecution leads to a withdrawal from the contract to some particular address then the oracles circulate a transaction sending the funds and sign it.nnhe approach is still low-trust, as no single oracle has the ability to unilaterally withdraw the funds, but it has a number of particular advantagesnnot every node in the blockchain needs to perform the computation - only a small number of oracles donnt theoretically does not require as a platform anything more complicated than itcoin or ipple as they currently standnnontracts have a somewhat higher degree of privacy - although eit transactions are still all visible, internal computations may not be. he scheme can also be augmented withnnsecure multiparty computationnnprotocols so the contract can even contain private information (something that would takennefficient and secure obfuscationnnto work directly on thereum)nnontracts can rely on eternal information (eg. currency prices, weather) since it is much easier for  nodes to come to consensus on the result of an  request than an entire blockchain. n fact, they can even rely on data from proprietary s, if the oracles subscribe to the s and pass along the costs to the contract users.nniven all of these advantages, it is undeniably clear that oracles have the potential to be a very useful paradigm for smart contracts going forward. owever, the key question is, how will oracle-based computation and blockchain-based computation, as in thereum, interact with each othernnracles re ot lways etternnirst of all, one important point to make is that it will not always be the case that the oracle-based method of contract eecution will be more efficient than the blockchain-based approach (not to mention non-currency/non-contract uses of the blockchain such as name registries and thenneople's epublic of nnwhere oracle systems do not even begin to apply).  common misconception is that the primary feature of thereum is that it is uring-complete, and so while itcoin only allows quick scripts for verification thereum contracts are means to do much harder and computationally intensive tasks. his is arguably a misconception.nnhe primary feature of thereum is not uring-completeness in fact, we have annsection in our whitepapernnwhich makes the argument that even if we eplicitly removed the ability of thereum contracts to be uring-complete it would actually change very little and there would still be a need for "gas". n order to make contracts truly statically analyzable, we would need to go so far as to remove the first-class-citizen property (namely, the fact that contracts can create and call other contracts), at which point thereum would have very limited utility.nnather, the primary feature of thereum is state - thereum accounts can contain not just a balance and code, but also arbitrary data, allowing for multi-step contracts, long-running contracts such asnns/s/snnand particularly non-financial blockchain-based applications to emerge. or eample, consider the following contractnninitnncontract.storagennnnnn]nnnnmsg.datannnnnn]nn# imited accountnncontract.storagennnnnn]nnnnmsg.datannnnnn]nn# nlimited accountnncontract.storagennnnnn]nnnnblock.timestampnn# ime last accessednncodennifnnmsg.sendernnnncontract.storagennnnnn]nnnnlast_accessednnnncontract.storagennnnnn]nnbalance_availnnnncontract.storagennnnnn]nn# ithdrawal limit is  finney per second, maimum  ethernnbalance_availnn+nnnn^ *nn(nnblock.timestamp - last_accessednn)nnifnnbalance_availnnnnnn^nnbalance_availnnnnnn^nnifnnmsg.datannnnnn]nnnnbalance_availnnsendnn(nnmsg.datannnnnn]nn, msg.datannnnnn]nn)nncontract.storagennnnnn]nnnnbalance_avail - msg.datannnnnn]nncontract.storagennnnnn]nnnnblock.timestampnn# nlimited account has no restrictionsnnelifnnmsg.sendernnnncontact.storagennnnnn]nnnnsendnn(nnmsg.datannnnnn]nn, msg.datannnnnn]nn)nnhis contract is pretty straightforward. t is an account with two access keys, where the first key has a withdrawal limit and the second key does not. ou can think of it as a cold/hot wallet setup, ecept that you do not need to periodically go to the cold wallet to refill unless you want to withdraw a large amount of ether all at once. f a message is sent with datann, ]nn, then if the sender is the first account it can send up to a certain limit of ether, and the limit refills at the rate of  finney per second (ie. . ether per day). f the sender is the second account, then the account contract sends the desired amount of ether to the desired destination with no restrictions. ow, let's see what epensive operations are required to eecute here, specifically for a withdrawal with the limited keynnn elliptic curve verification to verify the transactionnn storage database reads to get the last access time and last withdrawable balancenn storage database write to record the balance changes that result from the sending transactionnn storage database writes to write the new last access time and withdrawable balancennhere are also a couple dozen stack operations and memory reads/writes, but these are much faster than database and cryptography ops so we will not count them. he storage database reads can be made efficient with caching, although the writes will require a few hashes each to rewrite the atricia tree so they are not as easy that's whynnnnhas a gas cost of  butnnnnhas a cost of up to . dditionally, the entire transaction should take about  bytes, the erpent code takes up  bytes, and the four storage slots take up - bytes - hence,  bytes one-time cost and  bytes bandwitdh per transaction.nnow, consider this contract with a multisig oracle. he same operations will need to be done, but only on a few servers so the cost is negligible. owever, when the multisig transaction is sent to itcoin, if the multisig is a -of- then three elliptic curve verifications will be required, and the transaction will require  bytes per signature plus  bytes per public key so it will take about - bytes altogether (including also metadata and inputs). he blockchain storage cost will be around  bytes per  (as opposed to a static  in thereum). ence, assuming that an elliptic curve verification takes longer than a few hashes (it does), the blockchain-based approach is actually easier. he reason why this eample is so favorable is because it is a perfect eample of how thereum is about state and not uring-completeness no loops were used, but the magic of the contract came from the fact that a running record of the withdrawal limit could be maintained inside the contract.nn(ote advanced cryptographers may note that there is a specialized type of threshold signature that actually requires only one verification operation even if a large number of oracles are used to produce it. owever, if we use a currency with such a feature built-in, then we are already abandoning itcoin's eisting infrastructure and network effect in that case, why not just use the thereum contract)nnut ometimes hey rennt other times, however, oracles do make sense. he most common case that will appear in reality is the case of eternal data sometimes, you want a financial contract that uses the price of the  dollar, and you can't cryptographically determine that just by doing a few hashes and measuring ratios. n this case, oracles are absolutely necessary. nother important case is smart contracts that actually are very hard to evaluate. or eample, if you are purchasing computational resources from a decentralized cloud computing application, verifying that computations were done legitimately is not a task that the thereum blockchain can cheaply handle. or most classes of computation, verifying that they were done correctly takes eactly as long as doing them in the first place, so the only way to practically do such a thing is through occasional spot-checking using, well, oracles. nother cloud-computing use case for oracles, although in this contet we do not think of them as such, is file storage - you absolutely do not want to back up your  hard drive onto the blockchain.nnn additional use-case, already mentioned above, is privacy. ometimes, you may not want the details of your financial contracts public, so doing everything on-chain may not be the best idea. ure, you can use standard-form contracts, and people won't know that it'snnyounnwho is making a contract for difference between  and  at  leverage, but the information leakage is still high. n those cases, you may want to limit what is done on-chain and do most things off-chain.nno ow an hey ork ogethernno we have these two paradigms of total on-chain and partial on-chain, and they both have their relative strengths and weaknesses. owever, the question is, are the two really purely competitive he answer is, as it turns out, no. o further this point, here are a few particular eamplesnnchellingoinnn- incentivized decentralized oracles. hennchellingoin protocolnnis a proof-of-concept that shows how we can create a decentralized oracle protocol that is incentive-compatible have a two-step commitment protocol so that oracles do not initially know what each other's answers are, and then at the end have an thereum contract reward those oracles that are closest to the median. his incentivizes everyone to respond with the truth, since it is very difficult to coordinate on a lie. n independently conceived alternative,nnruthoinnn, does a similar thing for prediction markets with binary outcomes (eg. did the oronto aple eafs win the orld up).nnerifiable computation oraclesnn- when the oracles in question are eecuting moderately computationally intensive code, then we can actually go beyond the admittedly flaky and untested economics of the chellingoin/ruthoin protocols. he idea is as follows. y default, we have  of  oracles running the code and providing their votes on the answers. owever, when an oracle is perceived to vote incorrectly, that oracles can be "challenged". t that point, the oracle must provide the code to the blockchain, the blockchain checks the code against a pre-provided hash and runs the code itself, and sees if the result matches. f the result does not match, or if the oracle never replies to the challenge, then it loses its security deposit. he game-theoretic equilibrium here is for there to be no cheating at all, since any attempt at cheating necessarily harms some other party and so that party has the incentive to perform a check.nnignature batchingnn- one of the problems that  pointed out with the multisig oracle approach above is signature bloat if you have three oracles signing everything, then that's  etra bytes in the blockchain and three epensive verification operations per transaction. owever, with thereum we can be somewhat more clever - we can come up with a specialized "oracle contract", to which oracles can submit a single transaction with a single signature with a large number of votes batched togethernnaddr, vote, addr, vote ... ]nn. he oracle contract then processes the entire list of votes and updates all of the multisig voting pools contained inside it simultaneously. hus, one signature could be used to back an arbitrarily large number of votes, reducing the scalability concerns substantially.nnlockchain-based auditingnn- the concept of oracle-based computation can actually go much further than the "itcoin multisig oracle" (or, for that matter, thereum multisig oracle) idea. he etreme is an approach where oracles also decide the one thing that the itcoin-based schemes still leave the blockchain to decide the order of transactions. f we abandon this requirement, then it is possible to achieve much higher degrees of efficiency by having an oracle maintain a centralized database of transactions and state as they come, providing a signed record of each new balance sheet as a transaction is applied, allowing for applications like microtransactions and high-frequency trading. owever, this has obvious trust-problems particularly, what if the oracle double-spendsnnortunately, we can set up an thereum contract to solve the problem. uch like the verifiable computation eample above, the idea is that by default everything would run entirely on the oracle, but if the oracle chooses to sign two different balance sheets that are the result of incompatible transactions then those two signatures can be imported into thereum, and the contract will verify that those two signatures are valid, and if they are the contract will take away the oracle's security deposit. ore complicated schemes to deal with other attack vectors are also possible.nnerifiable secure multiparty computationnn- in the case where you are using oracles specifically for the purpose of maintaining private data, you can set up a protocol where the oracles securely choose a new secret key using multiparty random number generation every  hours, sign a message with the old key to prove to the world that the new key has authority, and then have to submit all of the computations that they made using the old key to the thereum blockchain for verification. he old key would be revealed, but it would be useless since a message transferring ownership rights to the new key is already in the blockchain several blocks before. ny malfeasance or nonfeasance revealed in the audit would lead to the loss of a security deposit.nnhe larger overarching point of all this is that the primary raison d'être of thereum is not just to serve as a smart contract engine it is more generally to serve as a world-wide trust-free decentralized computer, albeit with the disadvantages that it can hold no secrets and it is about ten thousand times slower than a traditional machine. he work in developing cryptoeconomic protocols to ensure that ordinary people have access to reliable, trustworthy and efficient markets and institutions is not nearly done, and the most eciting end-user-centric innovation is likely what will be built on top. t is entirely possible to have systems which use thereum for one thing, an -of- oracle setup for another thing, and some alternative network like aidsafe for something else base-level protocols are your servant, not your master.nnpecial thanks to lad amfir for some of the ideas behind combining oracles and thereum