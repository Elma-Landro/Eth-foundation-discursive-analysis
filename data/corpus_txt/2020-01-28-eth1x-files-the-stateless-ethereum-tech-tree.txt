Titre: The 1.x Files: The Stateless Ethereum Tech Tree\nAuteur: Griffin Ichiba Hotchkiss\nDate: January 28, 2020\nURL: https://blog.ethereum.org/2020/01/28/eth1x-files-the-stateless-ethereum-tech-tree\nCatégorie: Non catégorisé\n\n==================================================\n\nstarted to write a post that detailed a "roadmap" for thereum . research and the path to stateless thereum, and realized that it's not actually a roadmap at all —— at least not in the sense we're used to seeing from something like a product or company. he . team, although working toward a common goal, is an eclectic collection of developers and researchersnnindependentlynntackling intricately related topics. onsequently, there is no "official" roadmap to speak of. t's not complete chaos though! here is an understood "order of operations" some things must happen before others, certain solutions are mutually eclusive, and other work might be beneficial but non-essential.nno what's a better metaphor for the way we get to stateless thereum, if not a roadmap t took me a little bit, but  think  have a good one tateless thereum is the 'full spec' in anntech treenn.nnome readers might immediately understand this analogy. f you "get it", feel free to skip the net few paragraphs. ut if you're not like me and don't ordinarily think about the world in terms of video games  tech tree is a common mechanic in gaming that allows players to unlock and upgrade new spells, technologies, or skills that are sorted into a loose hierarchy or tree structure.nnsually there is some sort of  (eperience points) that can be "spent" to acquire elements in the tree ('spec'), which in turn unlock more advanced elements. ometimes you need to acquire two un-related basic elements to access a third more advanced one sometimes unlocking one basic skill opens up multiple new choices for the net upgrade. alf the fun as a player is choosing the right path in the tech trie that matches your ability, goals, and preferences (do you aim for full spec in arrior, hief, or age).nnhat's, in surprisingly accurate terms, what we have in the . research room  loose hierarchy of technical subjects to work on, with limited time/epertise to invest in researching, implementing, and testing. ust as in a good , eperience points are finite there's only so much that a handful of capable and motivated humans can accomplish in a year or two. epending on the requirements of delivery, it might be wise to hold off on more ambitious or abstract upgrades in favor of a more direct path to the final spec. veryone is aiming for the same end goal, but the path taken to get there will depend on which solutions end up being fully researched and employed.nnk, so 'll present my rough drawing of the tree, talk a little about how it's arranged, and then briefly go into an eplanation of each upgrade and how it relates to the whole. he final "full-spec" upgrade in the tech tree is "tateless thereum". hat is to say, a fully functioning thereum mainnet that supports full-state, partial-state, and zero-state nodes that efficiently and reliably passes around witnesses and state information and that is in principle ready to continue scaling until the bridge to th. is built and ready to onboard the legacy chain.nnote s  said just above, this isn't an 'official' scheme of work. t's my best effort at collating and organizing the key features, milestones, and decisions that the  working group must settle on in order to make tateless thereum a reality. eedback is welcome, and updated/revised versions of this plan will be inevitable as research continues.nnou should read the diagram from left to right purple elements presented on the left side are 'fundamental' and must be developed or decided upon before subsequent improvements further right. lements with a greenish hue are colored so to indicate that they are in some sense "bonus" items -- desirable though not strictly necessary for transition, and maybe less concretely understood in the scope of research. he larger pink shapes represent essential milestones for tateless thereum. ll  major milestones must be "unlocked" before a full-scale transition to tateless thereum can be enacted.nnhe itness ormatnnhere has been a lot of talk about witnesses in the contet of stateless thereum, so it should come as no surprise that the first major milestone that 'll bring up is a finalized witness format. his means deciding with some certainty the structure of the state trie and accompanying witnesses. he creation of a specification or reference implementation could be thought of as the point at which  . research "levels up" coalescing around a new representation of state will help to define and focus the work needed to be done to reach other milestones.nninary rie (or "trie, trie again")nnwitching thereum's state to a inary rie structure is key to getting witness sizes small enough to be gossiped around the network without running into bandwidth/latency issues. s outlined in thennlast research callnn, getting to a inary rie will require a commitment to one of two mutually eclusive strategiesnnrogressivenn. ikennthe hip of heseusnn, the current heary state trie woud be transformed piece-by-piece over a long period of time. ny transaction or  eecution touching parts of state would by this strategy automatically encode changes to state into the new binary form. his implies the adoption of a 'hybrid' trie structure that will leave dormant parts of state in their current heary representation. he process would effectively never complete, and would be comple for client developers to implement, but would for the most part insulate users and higher-layer developers from the changes happening under the hood in layer .nnlean-cutnn. erhaps more aligned with the significance of the underlying trie change, a clean-cut transition strategy would define an eplicit time-line of transition over multiple hard forks, compute a fresh binary trie representation of the state at that time, then carry on in binary form once the new state has been computed. lthough more straightforward from an implementation perspective, a clean-cut requires coordination from all node operators, and would almost certainly entail some (limited) disruption to the network, affecting developer and user eperience during the transition. n the other hand, the process might provide some valuable insights for planning the more distant transition to th.nnegardless of the transition strategy chosen, a binary trie is the basis for the witness structure, i.e. the order and hierarchy of hashes that make up the state trie. ithout further optimization, rough calculations (anuary ) put witness sizes in the ballpark of ~-, k, down from ~-, k in the heary trie structure.nnode hunking (merkleization)nnne major component of a witness is accompanying code. ithout code chunking,  transaction that contained a contract call would require the full bytecode of that contract in order to verify its codeash. hat could be a lot of data, depending on the contract. ode 'merkleization' is a method of splitting up contract bytecode so thatnnonly the portion of the code callednnis required to generate and verify a witness for the transaction. his is one technique of dramatically reducing the average size of witnesses. here are two ways to split up contract code, and for the moment it is not clear the two are mutually eclusive.nn"tatic" chunkingnn. reaking contract code up into fied sizes on the order of  bytes. or the merkleized code to run correctly, static chunks also would need to include some etra meta-data along with each chunk.nn"ynamic" chunkingnn. reaking contract code up into chunks based on the content of the code itself, cleaving at specific instructions () contained therein.nnt first blush, the "static" approach in code chunking seems preferable to avoid leaky abstractions, i.e. to prevent the content of the merkleized code from affecting the lower-level chunking, as might happen in the "dynamic" case. hat said, both options have yet to be thoroughly tested and therefore both remain in consideration.nn witness compressionnnbout % of a witness is hashes. t might be possible to use a - proofing technique to compress and verify those intermediate hashes. s with a lot of zero-knowledge stuff these days, eactlynnhownnthat would work, or evennnthat it would work at allnnis not well-defined or easily answered. o this is in some sense a side-quest, or non-essential upgrade to the main tech development tree.nn emanticsnne've touched briefly on "leaky abstraction" avoidance, and it is most relevant for this milestone, so 'm going to take a little detour here to eplain why the concept is important. he  is annnabstractednncomponent part of the bigger thereum protocol. n theory, details about what is going on inside the  should have no effectnnat allnnon how the larger system behaves, and changes to the system outside of the abstraction should have no effect at all on anything within it.nnn reality, however, there are certain aspects of the protocol that do directly affect things inside the . hese manifest plainly in gas costs.  smart contract (inside the  abstraction) has eposed to it, among other things, gas costs of various stack operations (outside the  abstraction) through thennnnopcode.  change in gas scheduling might directly affect the performance of certain contracts, but it depends on the contet and how the contract makes use of the information to which it has access.nnecause of the 'leaks', changes to gas scheduling and  eecution need to be made carefully, as they could have unintended effects on smart contracts. his is just a reality that must be dealt with it's very difficult to design systems with zero abstraction leakage, and in any event the . researchers don't have the luury of redesigning anything from the ground up -- hey need to work within today's thereum protocol, which is just a wee bit leaky in the ol' virtual state machine abstraction.nneturning to the main topic he introduction of witnessesnnwillnnrequire changes to gas scheduling. itnesses need to be generated and propagated across the network, and that activity needs to be accounted for in  operations. he topics tied to this milestone have to do with what those costs and incentives are, how they are estimated, and how they will be implemented with minimal impact on higher layers.nnitness ndeing / as accountingnnhere is likely much more nuance to this section than can reasonably fit in a few sentences 'm sure we'll dive a bit deeper at a later date. or now, understand that every transaction will be responsible for a small part of the full block's witness. enerating a block's witness involves some computation that will be performed by the block's miner, and therefore will need to have an associated gas cost, paid for by the transaction's sender.nnecause multiple transactions might touchnnthe same part of the statenn, it's not clear the best way to estimate the gas costs for witness production at the point of transaction broadcast. f transaction owners pay the full cost of witness production, we can imagine situations in which the same part of a block witness might be paid for many times over by 'overlapping' transactions. his isn't obviously a bad thing, mind you, but it introduces real changes to gas incentives that need to be better understood.nnhatever the associated gas costs are, the witnesses themselves will need to become a part of the thereum protocol, and likely will need to incorporated as a standard part of each block, perhaps with something as straightforward as annwitnessashnnincluded in each block header.nn / ersionless thereumnnhis is a class of upgrades mostly orthogonal to tateless thereum that have to do with gas costs in the , and patching up those abstraction leaks  mentioned.  is short for "unobservable gas", and it is a modification that would eplicitly disallow contracts from using thennnnopcode, to prohibit any assumptions about gas cost from being made by smart contract developers.  is part of a number of suggestions from thennthereum core papernnto patch up some of those leaks, makingnnall future changesnnto gas scheduling easier to implement, including and especially changes related to witnesses and tateless thereum.nntate vailabilitynntateless thereum is not going to do away with state entirely. ather, it will make state an optional thing, allowing clients some degree of freedom with regard to how much state they keep track of and compute themselves. he full state therefore must be made availablennsomewherenn, so that nodes looking to download part of all of the state may do so.nnn some sense, eisting paradigms like fast sync already provide for this functionality. ut the introduction of zero-state and partial-state nodes complicates things for new nodes getting up to speed. ight now, a new node can epect to download the state from any healthy peers it connects to, because all nodes keep a copy of the current state. ut that assumption goes out the window if some of peers are potentially zero-state or partial-state nodes.nnhe pre-requisites for this milestone have to do with the ways nodes signal to each other what pieces of state they have, and the methods of delivering those pieces reliably over a constantly changing peer-to-peer network.nnetwork ropagation ulesnnhis diagram below represents a hypothetical network topology that could eist in stateless thereum. n such a network, nodes will need to be able to position themselves according to what parts of state they want to keep, if any.nnmprovements such asnn #nnfall into the general category of network propagation rules ew message types in the network protocol that provide more information about what information nodes have, and define how that information is passed to other nodes in potentially awkward or limited network topologies.nnata elivery odel /  routingnnf improvements like the message types described above are accepted and implemented, nodes will be able to easily tell what parts of state are held by connected peers. hat if none of the connected peers have a needed piece of statennata delivery is a bit of an open-ended problem with many potential solutions. e could imagine turning to more 'mainstream' solutions, making some or all of the state available over  request from a cloud server.  more ambitious solution would be to adopt features from related peer-to-peer data delivery schemes, allowing requests for pieces of state to be proied through connected peers, finding their correct destinations through annistributed ash ablenn. he two etremes aren't inherently incompatible orque no los dosnntate tilingnnne approach to improving state distribution is to break the full state into more manageable pieces (tiles), stored in a networked cache that can provide state to nodes in the network, thus lightening the burden on the full nodes providing state. he idea is that even with relatively large tile sizes, it is likely that some of the tiles would remain un-changed from block to block.nnhe geth team has performed some eperiments which suggest state tiling is feasible for improving the availability of state snapshots.nnhain pruningnnuch has been writtennnon chain pruning already, so a more detailed eplanation is not necessary. t is worth eplicitly stating, however, that full nodes can safely prune historical data such as transaction receipts, logs, and historical blocksnnonly if historical state snapeshots can be made readily available to new full nodesnn, through something like state tiling and/or a  routing scheme.nnetwork rotocol pecnnt last, the complete picture of tateless thereum is coming into focus. he three milestones of itness ormat,  emantics, and tate vailability together enable a complete description of a etwork rotocol pecification he well-defined upgrades that should be coded into every client implementation, and deployed during the net hard fork to bring the network into a stateless paradigm.nne've covered a lot of ground in this article, but there are still a few odd and ends from the diagram that should be eplainednnormal tateless pecificationnnt the end of the day, it is not annrequirementnnthat the complete stateless protocol be formally defined. t is plausible that a reference implementation be coded out and used as the basis for all clients to re-implement. ut there are undeniable benefits to creating a "formalized" specification for witnesses and stateless clients. his would be essentially an etension or appendi that would fit in the thereum ellow aper, detailing in precise language the epected behavior of an thereum stateless client implementation.nneam ync, ed ueen's sync, and other state sync optimizationsnnync strategies are not primary to the network protocol, but instead are implementation details that affect how performant nodes are in enacting the protocol. eam sync and ed ueen's sync are related strategies for building up a local copy of state from witnesses. ome effort should be invested in improving these strategies and adapting them for the final 'version' of the network protocol, when that is decided and implemented.nnor now, they are being left as 'bonus' items in the tech tree, because they can be developed in isolation of other issues, and because details of their implementation depend on more fundamental choices like witness format. ts worth noting that these etra-protocol topics are, by virtue of their independence from 'core' changes, a good vehicle for implementing and testing the more fundamental improvements on the left side of the tree.nnrapping upnnell, that was quite a long journey!  hope that the topics and milestones, and general idea of the "tech tree" is helpful in organizing the scope of "tateless thereum" research.nnhe structure of this tree is something  hope to keep updated as things progress. s  said before, it's not an 'official' or 'final' scope of work, it's just the most accurate sketch we have at the moment. lease do reach out if you have suggestions on how to improve or amend it.nns always, if you have questions, requests for new topics, or want to participate in stateless thereum research, come introduce yourself on ethresear.ch, and/or reach out to gichiba or ancock on twitter.