Titre: Serpent upgrades: More Fun Stuff\nAuteur: Vitalik Buterin\nDate: May 2, 2014\nURL: https://blog.ethereum.org/2014/05/02/serpent-upgrades-more-fun-stuff\nCatégorie: Non catégorisé\n\n==================================================\n\nver the past two weeks our primary focus has been getting all of the clients updated to o compatibility, and it definitely has been a long road. mong the changes to the  includennhe new init/code mechanismnn basically, when you create a contract, the code provided will eecute immediately, and then the return value of that code will be what becomes the contract’s code. his allows us to have contract initialization code, but still keep to the same format of nonce, price, gas, to, value, data] for both transactions and contract creation, also making it easier to create new contracts via forwarding contractsnneordering transaction and contract datann the order is now nonce, price, gas, to, value, data] in transactions and gas, to, value, datain, datainsz, dataout, dataoutsz] in messages. ote that erpent retains the send(to, value, gas), o  msg(to, value, gas, datain, datainsz) and o  msg(to, value, gas, datain, datainsz, dataoutsz) parameters.nnee adjustmentsnn transaction creation now has a fee of  gas, and several other fees were updated.nnhe  and  opcodesnn  takes code_inde, mem_inde, len as arguments, and copies the code from code_inde ... code_inde+len- to memory mem_inde ... mem_inde+len-. hese are very useful when combined with init/code. here is also now .nnhe largest changes, however, have been to the architecture surrounding the protocol. n the  side, the ++ and o clients are evolving rapidly, and we will see more updates from that side coming very shortly. f you have been following thereum closely, you have likely seennnenny’s ottonn, a full implementation of a lottery, plus , written and eecuted inside the ++ client. rom here on, the ++ client will shift toward being a more developer-oriented tool, whereas the o client will start to focus on being a user-facing application (or rather, meta-application). n the compiler side, erpent has undergone a number of substantial improvements.nnirst, the code. ou can peek into the erpent compiler under the hood and you will be able to seennall of the functionsnnavailable, together with their precise translations into  code. or eample, we havenn     'access', , ,
         '', '', , '', '', '']],nnhis means that what access(,y) is actually doing under the hood is it’s recursively compiling whatever  and y actually are, and then loading the memory at inde  + y *  hence,  is the pointer to the start of the array and y is the inde. his code structure has been around since o, but now  have upgraded the meta-language used to describe translations even further, so as to include even if, while and init/code in this construction (before they were special cases) now, only set and seq remain as special cases, and if  wanted to  could even remove seq by reimplementing it as annrewrite rulenn.nnhe largest changes so far have been for o compatibility. or eample, if you run serpent compile_to_assembly 'return(msg.data]*)', you will seenn"nnbnnenngnninnnnncnnonndnnennnn.nnennnnndnncnnonndnnennnn"nn,nn"nnnnnnnn"nn,nn"nnnnnnnnnnnn"nn,nn"nnnnnnnnnn"nn,nn"nnnnnnnnnnnn"nn,nn"nnbegincode_.endcode_", "", "", "", "", "nnbnnenngnninnnconndnnennnn​nn.nnennnnndnnconndnnennnn​nn"nn,nn"nnnnnnnn"nn,nn"nnnnnnnn"nn,nn"nnnnnnnnnn"nn,nn"nnnnnnnn"nn,nn"nnbegincode_", "", "", "~begincode_", "#_", , , "", "", "", "", "", "", , "", "", "#_", "~endcode_"]nnhe actual code there is justnn, , "", "", "", "", "", "", , "", ""]nnf you want to see what’s going on here, suppose that a message is coming in with its first datum being . e thus havenn - tack ]
 - tack , ]
 - tack ,]
 - tack ]
 - tack , ]
 - tack , ]
 - tack , , ]
 - tack ], emory , ,  ... ]
 - tack , ], emory , ,  ... ]
 - tack , ], emory , ,  ... ]
nnhe last  returns the  memory bytes starting from , or , ,  ... ], or the number .nnow, let’s analyze the wrapper code.nn"nnbnnenngnninnnnncnnonndnnennnn.nnennnnndnncnnonndnnennnn"nn,nn"nnnnnnnn"nn,nn"nnnnnnnnnnnn"nn,nn"nnnnnnnnnn"nn,nn"nnnnnnnnnnnn"nn,nn"nnbegincode_.endcode_", "", "", "", "", "nnbnnenngnninnnconndnnennnn​nn.nnennnnndnnconndnnennnn​nn"nn,nn"nnnnnnnn"nn,nn"nnnnnnnn"nn,nn"nnnnnnnnnn"nn,nn"nnnnnnnn"nn,nn"nnbegincode_", "", "", "~begincode_", "#_", ..... , "#_", "~endcode_"]nn elided the inner code eplained above to make things clearer. he first thing we see are two labels,nnbegincode_ andnnendcode_, and the #_ and #_ guards. he labels mark the beginning and end of the inner code, and the guards are there for the later stages of the compiler, which understands that everything between the guards should be compiled as if it is a separate program. ow, let’s look at the first parts of the code. n this case, we have ~begincode_ at position  and ~endcode_ at position  in the final code.nnbnnenngnninnnnncnnonndnnennnnannnnndnnbegincode_ andnnbnnenngnninnnconndnnennnn​nnannndnnendcode_ are used to refer to these positions, and $begincode_.endcode_ refers to the length of the interval between them, . ow, remember that during contract initialization the call data is the code that you’re feeding in. hus, we havenn - tack ]
 - tack , ]
 - tack , , ]
 - tack , , ]
 - tack , , , ]
 - tack , , , , ]
 - tack , ] emory  ... ]
nnotice how the first half of the code cleverly set up the stack so that it would push the inner code into memory indices …, and then immediately return that chunk of memory. n the final compiled code,ebbafbbf, the inner code sits nicely to the right of the initializer code that simply returns it. n more comple contracts, initializers can also serve functions like setting certain storage slots to values, or even calling or creating other contracts.nnow, let us introduce the latest and most fun feature of erpent imports. ne common use case in contract land is that you want to give a contract the ability to spawn off new contracts. roblem is, how to you put the code for the spawned contracts into the spawner contracts efore, the only solution was the uncomfortable approach of compiling the newer contracts first, and then putting the compiled code into an array. ow, we have a better solution import.nnut the following into returnten.senn  create(t.gas - , , import(mul.se))
return(msg(,,t.gas-,],))nnow, put the following into mul.sennreturn(msg.data]*)nnow, if you serpent compile returnten.se andnnrun the contractnn, you notice that, voila, it returns ten. he reason why is obvious. he returnten.se contract creates an instance of the mul.se contract, and then calls it with the value . mul.se, as the name suggests, is a doubler, and so it returns *  . ote that import is not a function in the standard sense   import('.se') will fail, and import only works in the very specific contet of create.nnow, suppose you are creating a -line monster contract and want to split it up into files. o do that, we use inset. ntoouter.se, putnnif msg.data]  
inset(inner.se)nnnd into inner.se, putnnreturn()nnunning serpent compile outer.se gives you a nice piece of compiled code that returns  if the msg.data] argument is equal to one. nd that’s all there is to it.nnpcoming updates to erpent includennn improvement of this mechanism so it doesn’t load the inner code twice if you try to use import twice with the same filenamenntring literalsnnpace and code-efficiency improvements for array literalsnn debugging decorator (ie. a compiling function which tells you what lines of erpent correspond to what bytes of compiled code)nnn the short term, though, my own effort will focus on bugfies, a cross-client test suite, and continued work onnnethereumjs-libnn.