Titre: Thinking About Smart Contract Security\nAuteur: Vitalik Buterin\nDate: June 19, 2016\nURL: https://blog.ethereum.org/2016/06/19/thinking-smart-contract-security\nCatégorie: Non catégorisé\n\n==================================================\n\nver the last day with the community's help we have crowdsourced a list of all of the major bugs with smart contracts on thereum so far, including both the  as well as various smaller -  thefts and losses in games and token contracts.nnhis list (original sourcennherenn) is as followsnnhe  (obviously)nnhe "payout inde without the underscore"nnponzinn("ireonzi")nnhe casino with annpublic  seednnovernmentalnn(  stuck because payout eceeds gas limit)nn  swipednn(by whitehats) from an -backed  tokennnhenning of the ther gamennubii  ees stolen because thennconstructor functionnnhad an incorrect name, allowingnnanyone to become the ownernnock paper scissorsnntrivially cheatablennbecause the first to move shows their handnnarious instances of funds lost because a recipient contained a fallback function that consumed more than  gas, causing sends to them to fail.nnarious instances of call stack limit eceptions.nne can categorize the list by categories of bugsnnariable/function naming miups ireonzi, ubiinnublic data that should not have been public the public  seed casino, cheatable nne-entrancy ( calling  calling ) the , aker's -backed tokennnends failing due to  gas limit ing of the thernnrrays/loops and gas limits overnmentalnnuch more subtle game-theoretic weaknesses where at the limit people even debate whether or not they're bugs the nnhere have been many solutions proposed to smart contract safety, ranging from better development environments to better programming languages to formal verification and symbolic eecution, and researchers havennstarted developing such toolsnn. y personal opinion regarding the topic is that an important primary conclusion is the followingnnprogress in smart contract safety is necessarily going to be layered, incremental, and necessarily dependent on defense-in-depthnn. herennwillnnbe further bugs, and we will learn further lessons therennwill notnnbe a single magic technology that solves everything.nnhe reason for this fundamental conclusion is as follows. ll instances of smart contract theft or loss - in fact,nnthe very definitionnnof smart contract theft or loss, is fundamentally about differences between implementation and intent. f, in a given case, implementation and intent are the same thing, then any instance of "theft" is in fact a donation, and any instance of "loss" is voluntary money-burning, economically equivalent to a proportional donation to the  token holder community by means of deflation. his leads to the net challengennintent is fundamentally complenn.nnhe philosophy behind this fact has been best formalized by the friendly  research community, where is bears the names of "nncompleity of valuenn" and "nnfragility of valuenn". he thesis is simple we as human beings have very many values, and very comple values - so comple that we ourselves are not capable of fully epressing them, and any attempt to will inevitably contain some uncovered corner case. he utility of the concept to  research is important because a super-intelligent  would in fact search through every corner, including corners that we find so unintuitive that we do not even think of them, to maimize its objective. ell a superintelligent  to cure cancer, and it will get .% of the way there through some moderately comple tweaks in molecular biology, but it will soon realize that it can bump that up to % by triggering human etinction through a nuclear war and/or biological pandemic. ell it to cure cancer without killing humans, and it will simply force all humans to freeze themselves, reasoning that it's not technically killing because it could wake the humans up if it wanted to - it just won't. nd so forth.nnn smart contract land, the situation is similar. e believe that we value things like "fairness", but it's hard to define what fairness even means. ou may want to say things like "it should not be possible for someone to just steal   from a ", but what if, for a given withdrawal transaction, the  actually approved of the transfer because the recipient provided a valuable service ut then, if the transfer was approved, how do we know that the mechanism for deciding this wasn't fooled through a game-theoretic vulnerability hat is a game-theoretic vulnerability hat about "splitting" n the case of a blockchain-based market, what about front-running f a given contract specifies an "owner" who can collect fees, what if the ability for anyone to become the owner was actually part of the rules, to add to the funnnll of this is not a strike against eperts in formal verification, type theory, weird programming languages and the like the smart ones already know and appreciate these issues. owever, it does show that there is a fundamental barrier to what can be accomplished, and "fairness" is not something that can be mathematically proven in a theorem - in some cases, the set of fairness claims is so long and comple that you have to wonder if the set of claims itself might have a bug.nnoward a itigation athnnhat said, there are plenty of areas where divergence between intent and implementation can be greatly reduced. ne category is to try to take common patterns and hardcode them for eample, the ubii bug could have been avoided by makingnnownernna keyword that could only be initialized to equalnnmsg.sendernnin the constructor and possibly transferred in anntransferwnershipnnfunction. nother category is to try to create as many standardized mid-level components as possible for eample, we may want to discourage every casino from creating its own random number generator, and instead direct people tonnnn(or something likennmy ++ proposalnn, once implemented).nn more important category of solutions, however, involve mitigating the specific and unintuitive quirks of the  eecution environment. hese include the gas limit (responsible for the overnmental loss, as well as the losses due to recipients consuming too much gas when accepting a send), re-entrancy (responsible for the  and the aker  contract), and the call stack limit. he call stack limit, for eample, can be mitigated throughnnthis nn, which essentially removes it from consideration by substituting its purpose with a change to gas mechanics. e-entrancy could be banned outright (ie. only one eecution instance of each contract allowed at a time), but this would likely introduce new forms of unintuitiveness, so a better solution is likely required.nnhe gas limit, however, is not going away hence, the only solutions there are likely to be inside of the development environment itself. ompilers should throw a warning if a contract does not provably consume less than  gas if called with no data they should also throw a warning if a function does not provably terminate within a safe amount of gas. ariable names might be colored (eg.  based on the first three bytes of the hash of the name), or perhaps a heuristic warning might be given if two variable names are too close to each other.nndditionally, there are coding patterns that are more dangerous than others, and while they should not be banned, they should be clearly highlighted, requiring developers to justify their use of them.  particularly involved eample is as follows. here are two types of call operations that are clearly safe. he first is a send that contains  gas (provided we accept the norm that it is the recipient's responsibility not to consume more than  gas in the case of empty data). he second is a call to a contract that you trust and that is itself already determined to be safe (note that this definition bans re-entrancy as you would then have to prove  is safe before proving  is safe).nns it turns out, very many contracts can be covered by this definition. owever, not all of them can an eception is the idea of a "general purpose decentralized echange" contract where anyone can place orders offering to trade a given amount of asset  for a given amount of asset , where  and  are arbitrarynn-compatiblenntokens. ne could make a special-purpose contract just for a few assets, and thereby fall under the "trusted callee" eemption, but having a generic one seems like a very valuable idea. ut in that case, the echange would need to callnntransfernnandnntransferromnnof unknown contracts and, yes, give them enough gas to run and possibly make a re-entrant call to try to eploit the echange. n this case, the compiler may want to throw a clear warning unless a "mute lock" is used preventing the contract from being accessed again during those calls.nn third category of solutions is defense in depth. ne eample, to prevent losses (but not thefts) is to encourage all contracts that are not intended to be permanent to have an epiry date, after which the owner can take arbitrary actions on behalf of the contract this way, losses would be possible only if (i) the contract screws up, and simultaneously (ii) the owner is missing or dishonest. rusted multisig "owners" may emerge to mitigate (ii). hefts could be mitigated by adding waiting periods. he  issue was greatly mitigated in scope precisely because the child  was locked down for  days.  proposed feature in the aker is to create a delay before any governance change becomes active, allowing token holders unhappy with the change time to sell their tokens this is also a good approach.nnormal verification can be layered on top. ne simple use case is as a way of proving termination, greatly mitigating gas-related issues. nother use case is proving specific properties - for eample, "if all participants collude, they can get their money out in all cases", or "if you send your tokens  to this contract, you are guaranteed to either get the amount of token  that you want or be able to fully refund yourself". r "this contract fits into a restricted subset of olidity that makes re-entrancy, gas issues and call stack issues impossible".nn final note is that while all of the concerns so far have been about accidental bugs, malicious bugs are an additional concern. ow confident can we really be that the aker decentralized echange does not have a loophole that lets them take out all of the funds ome of us in the community may know the aker team and consider them to be nice people, but the entire purpose of the smart contract security model is to provide guarantees that are strong enough to survive even if that is not the case, so that entities that are not well-connected and established enough for people to trust them automatically and do not have the resources to establish their trustworthiness via a multimillion-dollar licensing process are free to innovate, and have consumers use their services feeling confident about their safety. ence, any checks or highlights should not just eist at the level of the development environment, they should also eist at the level of block eplorers and other tools where independent observers can verify the source code.nnarticular action steps that can be taken by the community arennaking on the project of making a superior development environment, as well as a superior block/source code eplorer, that includes some of these featuresnntandardization of as many components as possiblennaking on the project of eperimenting with different smart contract programming languages, as well as formal verification and symbolic eecution toolsnniscussing coding standards, s, changes to olidity, etc that can mitigate the risk of accidental or deliberate errorsnnf you are developing a multimillion-dollar smart contract application, consider reaching out to security researchers and work with them on using your project as a test case for various verification toolsnnote that, as stated in a previous blog post, rants and other grants are available for much of the above.