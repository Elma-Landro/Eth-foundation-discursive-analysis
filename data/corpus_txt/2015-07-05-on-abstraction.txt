Titre: On Abstraction\nAuteur: Vitalik Buterin\nDate: July 5, 2015\nURL: https://blog.ethereum.org/2015/07/05/on-abstraction\nCatégorie: Non catégorisé\n\n==================================================\n\npecial thanks to avin ood, lad amfir, our security auditors and others for some of the thoughts that led to the conclusions described in this postnnne of thereum's goals from the start, and arguably its entire raison d'être, is the high degree of abstraction that the platform offers. ather than limiting users to a specific set of transaction types and applications, the platform allows anyone to create any kind of blockchain application by writing a script and uploading it to the thereum blockchain. his gives an thereum a degree of future-proof-ness and neutrality much greater than that of other blockchain protocols even if society decides that blockchains aren't really all that useful for finance at all, and are only really interesting for supply chain tracking, self-owning cars and self-refilling dishwashers and playing chess for money in a trust-free form, thereum will still be useful. owever, there still are a substantial number of ways in which thereum is not nearly as abstract as it could be.nnryptographynnurrently, thereum transactions are all signed using thenn algorithmnn, and specifically itcoin's secpk curve. lliptic curve signatures are a popular kind of signature today, particularly because of the smaller signature and key sizes compared to  an elliptic curve signature takes only  bytes, compared to several hundred bytes for an  signature. owever, it is becoming increasingly understood that the specific kind of signature used by itcoin is far from optimalnnednnis increasingly recognized as a superior alternative particularly because of itsnnsimpler implementationnn, greater hardness against side-channel attacks and faster verification. nd if quantum computers come around, we will likely have tonnmove to amport signatures.nnne suggestion that some of our security auditors, and others, have given us is to allow ed signatures as an option in .. ut what if we can stay true to our spirit of abstraction and go a bit further let people usennwhatevernncryptographic verification algorithm that they want s that even possible to do securely ell, we have the ethereum virtual machine, so we have a way of letting people implement arbitrary cryptographic verification algorithms, but we still need to figure outnnhownnit can fit in.nnere is a possible approachnnvery accountnnthat is not a contractnnhas a piece of "verification code" attached to it.nnhen a transaction is sent, it must now eplicitly specify both sender and recipient.nnhe first step in processing a transaction is to call the verification code, using the transaction's signature (now a plain byte array) as input. f the verification code outputs anything nonempty within  gas, the transaction is valid. f it outputs an empty array (ie. eactly zero bytes a singlennnnbyte does not count) or eits with an eception condition, then it is not valid.nno allow people without  to create accounts, we implement a protocol such that one can generate verification code offline and use the hash of the verification code as an address. eople can send funds to that address. he first time you send a transaction from that account, you need to provide the verification code in a separate field (we can perhaps overload the nonce for this, since in all cases where this happens the nonce would be zero in any case) and the protocol (i) checks that the verification code is correct, and (ii) swaps it in (this is roughly equivalent to "nnpay-to-script-hashnn" in itcoin).nnhis approach has a few benefits. irst, it does not specifynnanythingnnabout the cryptographic algorithm used or the signature format, ecept that it must take up at most  gas (this value can be adjusted up or down over time). econd, it still keeps the property of the eisting system that no pre-registration is required. hird, and quite importantly, it allows people to add higher-level validity conditions that depend on state for eample, making transactions that spend more avoin than you currently have actually fail instead of just going into the blockchain and having no effect.nnowever, there are substantial changes to the virtual machine that would have to be made for this to work well. he current virtual machine is designed well for dealing with -bit numbers, capturing the hashes and elliptic curve signatures that are used right now, but is suboptimal for algorithms that have different sizes. dditionally, no matter how well-designed the  is right now, it fundamentally adds a layer of abstraction between the code and the machine. ence, if this will be one of the uses of the  going forward, an architecture that maps  code directly to machine code, applying transformations in the middle to translate specialized opcodes and ensure security, will likely be optimal - particularly for epensive and eotic cryptographic algorithms like zk-s. nd even then, one must take care to minimize any "startup costs" of the virtual machine in order to further increase efficiency as well as denial-of-service vulnerability together with this, a gas cost rule that encourages re-using eisting code and heavily penalizes using different code for every account, allowing just-in-time-compiling virtual machines to maintain a cache, may also be a further improvement.nnhe riennerhaps the most important data structure in thereum is thennatricia treenn. he atricia tree is a data structure that, like the standard binary erkle tree, allows any piece of data inside the trie to be securely authenticated against a root hash using a logarithmically sized (ie. relatively short) hash chain, but also has the important property that data can be added, removed or modified in the tree etremely quickly, only making a small number of changes to the entire structure. he trie is used in thereum to store transactions, receipts, accounts and particularly importantly the storage of each account.nnne of the often cited weaknesses of this approach is that the trie is one particular data structure, optimized for a particular set of use cases, but in many cases accounts will do better with a different model. he most common request is a heap a data structure to which elements can quickly be added with a priority value, and from which the lowest-priority element can always be quickly removed - particularly useful in implementations of markets with bid/ask offers.nnight now, the only way to do this is a rather inefficient workaround write an implementation of a heap in olidity or erpentnnon top of the trienn. his essentially means that every update to the heap requires a logarithmic number of updates (eg. at  elements, ten updates, at  elements, twenty updates) to the trie, and each update to the trie requires changes to a logarithmic number (once again ten at  elements and twenty at  elements) of items, and each one of those requires a change to the leveldb database which uses a logarithmic-time-updateable trie internally. f contracts had the option to have a heap instead, as a direct protocol feature, then this overhead could be cut down substantially.nnne option to solve this problem is the direct one just have an option for contracts to have either a regular trie or a heap, and be done with it.  seemingly nicer solution, however, is to generalize even further. he solution here is as follows. ather than having a trie or a treap, we simply have an abstract hash tree there is a root node, which may be empty or which may be the hash of one or more children, and each child in turn may either be a terminal value or the hash of some set of children of its own. n etension may be to allow nodes to have both a valuennandnnchildren. his would all be encoded in  for eample, we may stipulate that all nodes must be of the formnnnnval, child, child, childnn..nn..nn]nnherennvalnnmust be a string of bytes (we can restrict it to  if desired), and each child (of which there can be zero or more) must be the  byte  hash of some other node. ow, we have the virtual machine's eecution environment keep track of a "current node" pointer, and add a few opcodesnnnn pushes the value of the node at the current pointer onto the stacknnnn sets the value at the of the node at the current pointer to the value at the top of the stacknnnn gets the number of children of the nodennnn adds a new child node (starting with zero children of its own)nnnn pops off a child nodennnn descend to the kth child of the current node (takingnnknnas an argument from the stack)nnnn ascend to the parentnnnn ascend to the root nodennccessing a erkle tree with  elements would thus look like thisnndef accessnn(nninn)nnnn~ascendrootnn(nn)nnreturnnn_accessnn(nni,nnnn)nndef _accessnn(nni, depthnn)nnnnwhilenndepthnnnnnnnn~descendnn(nni %nnnn)nni /nnnnnndepth -nnnnnnreturnnn~getvalnn(nn)nnreating the tree would look like thisnndef createnn(nnvalsnn)nnnn~ascendrootnn(nn)nnwhilenn~getchildcountnn(nn)nnnnnnnn~removechildnn(nn)nn_createnn(nnvals,nnnn)nndef _createnn(nnvalsarr, depthnn)nnnnifnndepthnnnnnnnn# ecursively create left childnn~addchildnn(nn)nn~descendnn(nnnn)nn_createnn(nnslicenn(nnvals,nnnn,nnnn**nn(nndepth -nnnn))nn, depth -nnnn)nn~ascendnn(nn)nn# ecursively create right childnn~addchildnn(nn)nn~descendnn(nnnn)nn_createnn(nnslicenn(nnvals,nnnn**nn(nndepth -nnnn)nn,nnnn**depthnn)nn, depth -nnnn)nn~ascendnn(nn)nnelsenn~setvalnn(nnvalsnnnnnn]nn)nnlearly, the trie, the treap and in factnnanynnother tree-like data structure could thus be implemented as a library on top of these methods. hat is particularly interesting is that each individual opcode is constant-time theoretically, each node can keep track of the pointers to its children and parent on the database level, requiring only one level of overhead.nnowever, this approach also comes with flaws. articularly, note that if we lose control of the structure of the tree, then we lose the ability to make optimizations. ight now, most thereum clients, including ++, o and ython, have a higher-level cache that allows updates to and reads from storage to happen in constant time if there are multiple reads and writes within one transaction eecution. f tries become de-standardized, then optimizations like these become impossible. dditionally, each individual trie structure would need to come up with its own gas costs and its own mechanisms for ensuring that the tree cannot be eploited quite a hard problem, given that even our own trie had a medium level of vulnerability until recently when we replaced the trie keys with the  hash of the key rather than the actual key. ence, it's unclear whether going this far is worth it.nnurrencynnt's well-known and established that an open blockchain requires some kind of cryptocurrency in order to incentivize people to participate in the consensus process this is the kernel of truth behind this otherwise rather silly memennowever, can we create a blockchain that does not rely on anynnspecificnncurrency, instead allowing people to transact using whatever currency they wish n a proof of work contet, particularly a fees-only one, this is actually relatively easy to do for a simple currency blockchain just have a block size limit and leave it to miners and transaction senders themselves to come to some equilibrium over the transaction price (the transaction fees may well be done as a batch payment via credit card). or thereum, however, it is slightly more complicated. he reason is that thereum ., as it stands, comes with a built-in gas mechanism which allows miners to safely accept transactions without fear of being hit by denial-of-service attacks the mechanism works as followsnnvery transaction specifies a ma gas count and a fee to pay per unit gas.nnuppose that the transaction allows itself a gas limit of . f the transaction is valid, and takes less than  computational steps (say,  computational steps), then it pays  steps worth of the fee. f the transaction consumes all  computational steps before finishing, the eecution is reverted but it still pays  steps worth of the fee.nnhis mechanism relies on the eistence of a specific currency, , which is controlled by the protocol. an we replicate it without relying on any one particular currency s it turns out, the answer is yes, at least if we combine it with the "use any cryptography you want" scheme above. he approach is as follows. irst, we etend the above cryptography-neutrality scheme a bit further rather than having a separate concept of "verification code" to decide whether or not a particular transaction is valid, simply state that there is only one type of account - a contract, and a transaction is simply a message coming in from the zero address. f the transaction eits with an eceptional condition within  gas, the transaction is invalid otherwise it is valid and accepted. ithin this model, we then set up accounts to have the following codennheck if the transaction is correct. f not, eit. f it is, send some payment for gas to a master contract that will later pay the miner.nnend the actual message.nnend a message to ping the master contract. he master contract then checks how much gas is left, and refunds a fee corresponding to the remaining amount to the sender and sends the rest to the miner.nntep  can be crafted in a standardized form, so that it clearly consumes less than  gas. tep  can similarly be constructed. tep  can then have the message provide a gas limit equal to the transaction's specified gas limit minus . iners can then pattern-match to only accept transactions that are of this standard form (new standard forms can of course be introduced over time), and they can be sure that no single transaction will cheat them out of more than  steps of computational energy. ence, everything becomes enforced entirely by the gas limit, and miners and transaction senders can use whatever currency they want.nnne challenge that arises is how do you pay contracts urrently, contracts have the ability to "charge" for services, using code like this registry eamplenndef reservenn(nn_namebytesnn)nnnnifnnmsg.valuennnnnn*nnnn**nnifnnnot self.domainsnnnn_namenn]nn.ownernnself.domainsnnnn_namenn]nn.ownernnnnmsg.sendernnith a sub-currency, there is no such clear mechanism of tying together a message and a payment for that message. owever, there are two general patterns that can act as a substitute. he first is a kind of "receipt" interface when you send a currency payment to someone, you have the ability to ask the contract to store the sender and value of the transaction. omething likennregistrar.reserve("blahblahblah.eth")nnwould thus be replaced bynngavcoin.senditheceiptnn(nnregistrar,nnnn*nnnn**nn)nnregistrar.reservenn(nn"blahblahblah.eth"nn)nnhe currency would have code that looks something like thisnndef senditheceiptnn(nnto, valuenn)nnnnifnnself.balancesnnnnmsg.sendernn]nnnnvaluennself.balancesnnnnmsg.sendernn]nn-nnnnvaluennself.balancesnnnntonn]nn+nnvaluennself.last_sendernnnnmsg.sendernnself.last_recipientnnnntonnself.last_valuennnnvaluenndef getasteceiptnn(nn)nnnnreturnnn(nnnnself.last_sender, self.last_recipient, self.valuenn]nnarrnn)nnnd the registrar would work like thisnndef reservenn(nn_namebytesnn)nnnnrnnnngavcoin.getasteceiptnn(nnoutitemsnnnnnn)nnifnnrnnnnnn]nnnnmsg.sender and rnnnnnn]nnnnself and rnnnnnn]nnnnnn*nnnn**nnifnnnot self.domainsnnnn_namenn]nn.ownernnself.domainsnnnn_namenn]nn.ownernnnnmsg.sendernnssentially, the registrar would check the last payment made in that currency contract, and make sure that it is a payment to itself. n order to prevent double-use of a payment, it may make sense to have thennget_last_receiptnnmethod destroy the receipt in the process of reading it.nnhe other pattern is to have a currency have an interface for allowing another address to make withdrawals from your account. he code would then look as follows on the caller side first, approve a one-time withdrawal of some number of currency units, then reserve, and the reservation contract attempts to make the withdrawal and only goes forward if the withdrawal succeedsnngavcoin.approvencenn(nnregistrar,nnnn)nnregistrar.reservenn(nn"blahblahblah.eth"nn)nnnd the registrar would benndef reservenn(nn_namebytesnn)nnnnifnngavcoin.sendoinromnn(nnmsg.sender,nnnn, selfnn)nnnnnnifnnnot self.domainsnnnn_namenn]nn.ownernnself.domainsnnnn_namenn]nn.ownernnnnmsg.sendernnhe second pattern has been standardized at thenntandardized ontract s wiki pagenn.nnurrency-agnostic roof of takennhe above allows us to create a completely currency-agnostic proof-of-work blockchain. owever, to what etent can currency-agnosticism be added to proof of stake urrency-agnostic proof of stake is useful for two reasons. irst, it creates a stronger impression of economic neutrality, which makes it more likely to be accepted by eisting established groups as it would not be seen as favoring a particular specialized elite (bitcoin holders, ether holders, etc). econd, it increases the amount that will be deposited, as individuals holding digital assets other than ether would have a very low personal cost in putting some of those assets into a deposit contract. t first glance, it seems like a hard problem unlike proof of work, which is fundamentally based on an eternal and neutral resource, proof of stake is intrinsically based on some kind of currency. o how far can we gonnhe first step is to try to create a proof of stake system that works using any currency, using some kind of standardized currency interface. he idea is simple anyone would be able to participate in the system by putting up any currency as a security deposit. ome market mechanism would then be used in order to determine the value of each currency, so as to estimate the amount of each currency that would need to be put up in order to obtain a stake depositing slot.  simple first approimation would be to maintain an on-chain decentralized echange and read price feeds however, this ignores liquidity and sockpuppet issues (eg. it's easy to create a currency and spread it across a small group of accounts and pretend that it has a value of $ trillion per unit) hence, a more coarse-grained and direct mechanism is required.nno get an idea of what we are looking for, consider avid riedman'snndescription of one particular aspectnnof the ancient thenian legal systemnnhe thenians had a straightforward solution to the problem of producing public goods such as the maintainance of a warship or the organizing of a public festival. f you were one of the richest thenians, every two years you were obligated to produce a public good the relevant magistrate would tell you which one.
"s you doubtless know, we are sending a team to the lympics this year. ongratulations, you are the sponsor."
r
"ook at that lovely trireme down at the dock. his year guess who gets to be captain and paymaster."
uch an obligation was called a liturgy. here were two ways to get out of it. ne was to show that you were already doing another liturgy this year or had done one last year. he other was to prove that there was another thenian, richer than you, who had not done one last year and was not doing one this year.
his raises an obvious puzzle. ow, in a world without accountants, income ta, public records of what people owned and what it was worth, do  prove that you are richer than  am he answer is not an accountant’s answer but an economist’s—feel free to spend a few minutes trying to figure it out before you turn the page.
he solution was simple.  offer to echange everything  own for everything you own. f you refuse, you have admitted that you are richer than  am, and so you get to do the liturgy that was to be imposed on me.nnere, we have a rather nifty scheme for preventing people that are rich from pretending that they are poor. ow, however, what we are looking for is a scheme for preventing people that are poor from pretending that they are rich (or more precisely, preventing people that are releasing small amounts of value into the proof of stake security deposit scheme from pretending that they are staking a much larger amount).nn simple approach would be a swapping scheme like that, but done in reverse via a voting mechanic in order to join the stakeholder pool, you would need to be approved by % of the eisting stakeholders, but every stakeholder that approves you would have to face the condition that you can echange your stake for theirs a condition that they would not be willing to meet if they thought it likely that the value of your stake actually would drop. takeholders would then charge an insurance fee for signing stake that is likely to strongly drop against the eisting currencies that are used in the stake pool.nnhis scheme as described above has two substantial flaws. irst, it naturally leads to currency centralization, as if one currency is dominant it will be most convenient and safe to also stake in that currency. f there are two assets,  and , the process of joining using currency , in this scheme, implies receiving an option (in thennfinancial sensennof the term) to purchase  at the echange rate of  at the price at the time of joining, and this option would thus naturally have a cost (which can be estimated via thennlack-choles modelnn). ust joining with currency  would be simpler. owever, this can be remedied by asking stakeholders to continually vote on the price of all currencies and assets used in the stake pool - an incentivized vote, as the vote reflects both the weight of the asset from the point of view of the system and the echange rate at which the assets can be forcibly echanged.nn second, more serious flaw, however, is the possibility of pathological metacoins. or eample, one can imagine a currency which is backed by gold, but which has the additional rule, imposd by the institution backing it, that forcible transfers initiated by the protocol "do not count" that is, if such a transfer takes place, the allocationnnbeforennthe transfer is frozen and a new currency is created using that allocation as its starting point. he old currency is no longer backed by gold, and the new one is. thenian forcible-echange protocols can get you far when you can actually forcibly echange property, but when one can deliberately create pathological assets that arbitrarily circumvent specific transaction types it gets quite a bit harder.nnheoretically, the voting mechanism can of course get around this problem nodes can simply refuse to induct currencies that they know are suspicious, and the default strategy can tend toward conservatism, accepting a very small number of currencies and assets only. ltogether, we leave currency-agnostic proof of stake as an open problem it remains to be seen eactly how far it can go, and the end result may well be some quasi-subjective combination of rustavis and ipple consensus.nn and nnow, we get to the last few parts of the protocol that we have not yet taken apart the hash algorithm and the serialization algorithm. ere, unfortunately, abstracting things away is much harder, and it is also much harder to tell what the value is. irst of all, it is important to note that even though we have shows how we could conceivably abstract away the trees that are used for account storage, it is much harder to see how we could abstract away the trie on the top level that keeps track of the accounts themselves. his tree is necessarily system-wide, and so one can't simply say that different users will have different versions of it. he top-level trie relies on , so some kind of specific hashing algorithm there must stay. ven the bottom-level data structures will likely have to stay , since otherwise there would be a risk of a hash function being used that is not collision-resistant, making the whole thing no longer strongly cryptographically authenticated and perhaps leading to forks between full clients and light clients.nn is similarly unavoiable at the very least, each account needs to have code and storage, and the two need to be stored together some how, and that is already a serialization format. ortunately, however,  and  are perhaps the most well-tested, future-proof and robust parts of the protocol, so the benefit from switching to something else is quite small.