Titre: Understanding Serenity, Part I: Abstraction\nAuteur: Vitalik Buterin\nDate: December 24, 2015\nURL: https://blog.ethereum.org/2015/12/24/understanding-serenity-part-i-abstraction\nCatégorie: Non catégorisé\n\n==================================================\n\npecial thanks to avin ood for prompting my interest into abstraction improvements, and artin ecze, lad amfir and ominic illiams for ongoing discussions.nnor a long time we have been public about our plans to continue improving the thereum protocol over time and our long development roadmap, learning from our mistakes that we either did not have the opportunity to fi in time for . or only realized after the fact. owever, the thereum protocol development cycle has started up once again, with a omestead release coming very soon, and us quietly starting to develop proof-of-concepts for the largest milestone that we had placed for ourselves in ournndevelopment roadmapnn erenity.nnerenity is intended to have two major feature sets abstraction, a concept that  initially epanded on innnthis blog post herenn, and asper, our security-deposit-based proof of stake algorithm. dditionally, we are eploring the idea of adding at least the scaffolding that will allow for the smooth deployment over time ofnnour scalabilitynnproposalsnn, and at the same time completely resolve parallelizability concernsnnbrought up herenn- an instant very large gain for private blockchain instances of thereum with nodes being run in massively multi-core dedicated servers, and even the public chain may see a - improvement in scalability. ver the past few months, research on asper and formalization of scalability and abstraction (eg. withnn nn) have been progressing at a rapid pace between myself, lad amfir, ucius reg eredith and a few others, and now  am happy to announce that the first proof of concept release for erenity, albeit in a very limited form suitable only for testing,nnis now availablenn.nnhe o can be run by going into thennethereumnndirectory and runningnnpython test.pynn(nnmake sure to download and install the latest erpent fromnnhttps//github.com/ethereum/serpentnn, develop branchnn) if the output looks something like this then you are finennvubvub-hinkad-  serenity/ethereum python test.py
  gas from account  to account cbeddcdcdeefbeebf with data 
arning (file "casper.se.py", line , char ) arning function return type inconsistent!
unning with  maimum nodes
arning (file "casper.se.py", line , char ) arning function return type inconsistent!
arning (file "casper.se.py", line , char ) arning function return type inconsistent!
ength of validation code 
ength of account code 
oined with inde 
ength of validation code 
ength of account code 
oined with inde 
ength of validation code nnhis is a simulation of  nodes running the asper+erenity protocol at a -second block time this is fairly close to the upper limit of what the client can handle at the moment, though note that (i) this is python, and ++ and o will likely show much higher performance, and (ii) this is all nodes running on one computer at the same time, so in a more "normal" environment it means you can epect python asper to be able to handle at least ~ nodes (though, on the other hand, we want consensus overhead to be much less than % of  time, so these two caveats combined do  mean that you should epect to see asper running with thousands of nodes!). f your computer is too slow to handle the  nodes, trynnpython test.py nnto run the simulation with  nodes instead (ornnpython test.py nnfor  nodes, etc). f course, research on improving asper's efficiency, though likely at the cost of somewhat slower convergence to finality, is still continuing, and these problems should reduce over time. hennnetwork.pynnfile simulates a basic  network interface future work will involve swapping this out for actual computers running on a real network.nnhe code is split up into several main files as followsnnserenity_blocks.pynn- the code that describes the block class, the state class and the block and transaction-level transition functions (about  simpler than before)nnserenity_transactions.pynn- the code that describes transactions (about  simpler than before)nncasper.se.pynn- the serpent code for the asper contract, which incentivizes correct bettingnnbet.pynn- asper betting strategy and full client implementationnnecdsa_accounts.pynn- account code that allows you to replicate the account validation functionality available today in a erenity contetnntest.pynn- the testing scriptnnconfig.pynn- config parametersnnvm.pynn- the virtual machine (faster implementation atnnfastvm.pynn)nnnetwork.pynn- the network simulatornnor this article, we will focus on the abstraction features and sonnserenity_blocks.pynn,nnecdsa_accounts.pynnandnnserenity_transactions.pynnare most critical for the net article discussing asper in erenity,nncasper.se.pynnandnnbet.pynnwill be a primary focus.nnbstraction and ccountsnnurrently, there are two types of accounts in thereum eternally owned accounts, controlled by a private key, and contracts, controlled by code. or eternally owned accounts, we specify a particular digital signature algorithm (secpk ) and a particular sequence number (aka. nonce) scheme, where every transaction must include a sequence number one higher than the previous, in order to prevent replay attacks. he primary change that we will make in order to increase abstraction is this rather than having these two distinct types of accounts, we will now have only one - contracts. here is also a special "entry point" account,nnnn, thatnnanyone can send fromnnby sending a transaction. ence, instead of the signature+nonce verification logic of accounts being in the protocol, it is now up to the user to put this into a contract that will be securing their own account.nnhe simplest kind of contract that is useful is probably the  verification contract, which simply provides the eact same functionality that is available right now transactions pass through only if they have valid signatures and sequence numbers, and the sequence number is incremented by  if a transaction succeeds. he code for the contract looks as followsnn# e assume that data takes the following schema
# bytes - v ( sig)
# bytes - r ( sig)
# bytes - s ( sig)
# bytes - sequence number (formerly called "nonce")
# bytes - gasprice
# bytes - to
# bytes - value
# bytes + data

# et the hash for transaction signing
~mstore(, ~teecgas())
~calldatacopy(, , ~calldatasize() - )
~mstore(, ~sha(, ~calldatasize() - ))
~calldatacopy(, , )
# all  contract to get the sender
~call(, , , , , , )
# heck sender correctness eception if not
if ~mload() ! abfabdeeeefeebf
    ~invalid()
# equence number operations
with minusone  ~sub(, )
    with curseq  self.storageminusone]
        # heck sequence number correctness, eception if not
        if ~calldataload() ! curseq
            ~invalid()
        # ncrement sequence number
        self.storageminusone]  curseq + 
# ake the sub-call and discard output
with   ~msize()
    ~call(msg.gas - , ~calldataload(), ~calldataload(), , ~calldatasize() - , , )
    # ay for gas
    ~mstore(, ~calldataload())
    ~mstore(, (~teecgas() - msg.gas + ))
    ~call(, , , , , , )
    ~return(, ~msize() - )nnhis code would sit as the contract code of the user's account if the user wants to send a transaction, they would send a transaction (from the zero address) to this account, encoding the  signature, the sequence number, the gasprice, destination address, ether value and the actual transaction data using the encoding specified above in the code. he code checks the signature against the transaction gas limit and the data provided, and then checks the sequence number, and if both are correct it then increments the sequence number, sends the desired message, and then at the end sends a second message to pay for gas (note that miners can statically analyze accounts and refuse to process transactions sending to accounts that do not have gas payment code at the end).nnn important consequence of this is that erenity introduces a model wherennall transactions (that satisfy basic formatting checks) are validnn transactions that are currently "invalid" will in erenity simply have no effect (thenninvalidnnopcode in the code above simply points to an unused opcode, immediately triggering an eit from code eecution). his does mean that transaction inclusion in a block is no longer a guarantee that the transaction was actually eecuted to substitute for this, every transaction now gets a receipt entry that specifies whether or not it was successfully eecuted, providing one of three return codesnnnn(transaction not eecuted due to block gas limit),nnnn(transaction eecuted but led to error),nnnn(transaction eecuted successfully) more detailed information can be provided if the transaction returns data (which is now auto-logged) or creates its own logs.nnhe main very large benefit of this is that it gives users much more freedom to innovate in the area of account policy possible directions includennitcoin-style multisignn, where an account epects signatures from multiple public keys at the same time before sending a transaction, rather than accepting signatures one at a time and saving intermediate results in storagennther elliptic curvesnn, including ednnetter integration for more advanced cryptonn, eg. ring signatures, threshold signatures, snnore advanced sequence number schemesnnthat allow for higher degrees of parallelization, so that users can send many transactions from one account and have them included more quickly think a combination of a traditional sequence number and a bitmask. ne can also include timestamps or block hashes into the validity check in various clever ways.nn-based token managementnn- some people dislike the fact that thereum uses accounts instead of itcoin's "unspent transaction output" () model for managing token ownership, in part for privacy reasons. ow, you can create a system inside thereum that actually is -based, and erenity no longer eplicitly "privileges" one over the other.nnnnovation in payment schemesnn- for some dapps, "contract pays" is a better model than "sender pays" as senders may not have any ether now, individual dapps can implement such models, and if they are written in a way that miners can statically analyze and determine that they actually will get paid, then they can immediately accept them (essentially, this providesnnwhat ootstock is trying to donnwith optional author-pays, but in a much more abstract and fleible way).nntronger integration for "ethereum alarm clock"-style applicationsnn- the verification code for an account doesn't have to check for signatures, it could also check for erkle proofs of receipts, state of other accounts, etcnnn all of these cases, the primary point is that through abstraction all of these other mechanisms become much easier to code as there is no longer a need to create a "pass-through layer" to feed the information in through thereum's default signature scheme when no application is special, every application is.nnne particular interesting consequence is that with the current plan for erenity, thereum will be optionally quantum-safe if you are scared of the  having access to a quantum computer, and want to protect your account more securely, you can personallynnswitch to amport signaturesnnat any time. roof of stake further bolsters this, as even if the  had a quantum computer and no one else they would not be able to eploit that to implement a % attack. he only cryptographic security assumption that will eist at protocol level in thereum is collision-resistance of .nns a result of these changes, transactions are also going to become much simpler. nstead of having nine fields, as is the case right now, transactions will only have four fields destination address, data, start gas and init code. estination address, data and start gas are the same as they are now "init code" is a field that can optionally contain contract creation code for the address that you are sending to.nnhe reason for the latter mechanic is as follows. ne important property that thereum currently provides is the ability to send to an account before it eists you do not need to already have ether in order to create a contract on the blockchain before you can receive ether. o allow this in erenity, an account's address can be determined from the desired initialization code for the account in advance, by using the formulannsha(creator + initcode) % **nnwherenncreatornnis the account that created the contract (the zero account by default), andnninitcodennis the initialization code for the contract (the output of running the initcode will become the contract code, just as is the case for s right now). ou can thus generate the initialization code for your contract locally, compute the address, and let others send to that address. hen, once you want to send your first transaction, you include the init code in the transaction, and the init code will be eecuted automatically and the account created before proceeding to run the actual transaction (you can find this logic implementednnherenn).nnbstraction and locksnnnother clean separation that will be implemented in erenity is the complete separation of blocks (which are now simply packages of transactions), state (ie. current contract storage, code and account balances) and the consensus layer. onsensus incentivization is done inside a contract, and consensus-level objects (eg. o, bets) should be included as transactions sent to a "consensus incentive manager contract" if one wishes to incentivize them.nnhis should make it much easier to take the erenity codebase and swap out asper for any consensus algorithm - endermint,nnoneyadgernn,nnsubjective consensusnnor even plain old proof of work we welcome research in this direction and aim for maimum fleibility.nnbstraction and toragennurrently, the "state" of the thereum system is actually quite comple and includes many partsnnalance, code, nonce and storage of accountsnnas limit, difficulty, block number, timestampnnhe last  block hashesnnuring block eecution, the transaction inde, receipt tree and the current gas usednnhese data structures eist in various places, including the block state transition function, the state tree, the block header and previous block headers. n erenity, this will be simplified greatly although many of these variables will still eist, they will all be moved to specialized contracts in storage hence, the  concept of "state" that will continue to eist is a tree, which can mathematically be viewed as a mappingnn{address {key value} }nn. ccounts will simply be trees account code will be stored at keynn""nnfor each account (not mutable bynnnn), balances will be stored in a specialized "ether contract" and sequence numbers will be left up to each account to determine how to store. eceipts will also be moved to storage they will be stored in a "log contract" where the contents get overwritten every block.nnhis allows the tate object in implementations to be simplified greatly all that remains is a two-level map of tries. he scalability upgrade may increase this to three levels of tries (shard , address, key) but this is not yet determined, and even then the compleity will be substantially smaller than today.nnote that the move of ether into a contract does  constitute total ether abstraction in fact, it is arguably not that large a change from the status quo, as opcodes that deal with ether (thennvaluennparameter innnnn,nnnn, etc) still remain for backward-compatibility purposes. ather, this is simply a reorganization of how data is stored.nnuture lansnnor , the plan is to take abstraction even further. urrently, substantial compleity still remains in the block and transaction-level state transition function (eg. updating receipts, gas limits, the transaction inde, block number, stateroots) the goal will be to create an "entry point" object for transactions which handles all of this etra "boilerplate logic" that needs to be done per transaction, as well as a "block begins" and "block ends" entry point.  theoretical ultimate goal is to come up with a protocol where there is only one entry point, and the state transition function consists of simply sending a message from the zero address to the entry point containing the block contents as data. he objective here is to reduce the size of the actualnnconsensus-critical client implementationnnas much as possible, pushing a maimum possible amount of logic directly into thereum code itself this ensures that thereum's multi-client model can continue even with an aggressive development regime that is willing to accept hard forks and some degree of new compleity in order to achieve our goals of transaction speed and scalability without requiring an etremely large amount of ongoing development effort and security auditing.nnn the longer term,  intend to continue producing proof-of-concepts in python, while the asper team works together on improving the efficiency and proving the safety and correctness of the protocol at some point, the protocol will be mature enough to handle a public testnet of some form, possibly (but not certainly) with real value on-chain in order to provide stronger incentives for people to try to "hack" asper they way that we inevitably epect that they will once the main chain goes live. his is only an initial step, although a very important one as it marks the first time when the research behind proof of stake and abstraction is finally moving from words, math on whiteboards and blog posts into a working implementation written in code.nnhe net part of this series will discuss the other flagship feature of erenity, the asper consensus algorithm.