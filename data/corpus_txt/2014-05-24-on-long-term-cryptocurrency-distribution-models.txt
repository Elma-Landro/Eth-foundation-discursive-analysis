Titre: On Long-Term Cryptocurrency Distribution Models\nAuteur: Vitalik Buterin\nDate: May 24, 2014\nURL: https://blog.ethereum.org/2014/05/24/on-long-term-cryptocurrency-distribution-models\nCatégorie: Non catégorisé\n\n==================================================\n\nne of the challenges when creating a new cryptocurrency is figuring out what the distribution model is going to be. ho is going to receive the currency units, at what time, and what is the mechanism that decides espite the crucial importance of this question, there has actually been comparatively little thought into the issue compared with other aspects of currency, like consensus algorithms and feature sets. he question is particularly challenging because, just like many other problems in the cryptocurrency space that have parallels in the “real world” at large, cryptocurrencies also face the requirement of decentralization it is considered unacceptable to have a cryptographic platforms whose continued operation depends on the eistence of any specific party in the long term. iven this rather stringent requirement, how should a new currency distribute itselfnno far, the problem is still in its very early stages of discussion. hile the question of short-term distribution is a highly dynamic debate between different types of asset carryovers, one-way transfers, two-way pegs, pre-mines, pre-sales and other mechanisms coming out almost every month, long-term distribution in nearly every cryptocurrency now follows one of two strategies nothing at all, or mining. he reason why having a fied never-growing supply is undesirable is obvious it encourages wealth concentration and creates a static community of holders without an effective way for new people to get in, and it means that the coin has no way to incentive any specific kind of activity in the long term. he issue with mining, however, is more subtle. ryptocurrency mining generally serves two functions first, it provides a way of securing the network, and second, it serves as a distribution model, giving hundreds of thousands of people around the world a way of getting access to a few coins. o far, mining has been considered necessary for the former, and an effective way of doing the latter. ore recently, however, there has been a substantial amount of interest and research intonnproof of stakenn, including strategies such asnntransactions as proof-of-stakenn,nndelegated proof of stakennand a partial solution to nothing-at-stake,nnlashernn, suggesting that mining might not be necessary after all. econd, the rise of both s and professional  farms is turning mining itself into an increasingly concentrated and quasi-centralized community, so any new mining-distributed currency will quickly be dominated by professional companies and not “the people” at large. f both trends continue, and mining proves to be a bad model for distribution, it will therefore need to be replaced. ut then, the question is, by whatnno far, we know of several answersnnretend that the problem does not eistnn. his is the solution that has been taken by most proof-of-stake cryptocurrencies, and surprisingly enough even proof-of-work currencies, today.nnentralized distributionnn let some central authority hand out coins according to some formula.nnseful proof-of-worknn hand out coins to anyone who performs a particularnnsocially usefulnncomputation, eg. weather prediction. his algorithm need not be used for consensus it can eist simply to distribute coins while proof-of-stake does the hard work of maintaining consensus.nnlgorithmic consensus distributionnn. ssentially, some kind of dynamic, adaptive consensus-based process for determining who gets new coins.nnhe second is theoretically the most powerful currency units can be distributed either to everyone in the world for maimum fairness or to pay bounties for protocol development, eternal charitable causes or anything else. owever, at the same time actually using such a mechanism arguably kills the whole point of a cryptocurrency that it is decentralized and depends on no specific party for its continued eistence. hus, we can think of the centralized distributor as an ideal that we want to approach, sort of like thennideal of a bureaucrat godnnfound in economic efficiency theory, and see how close to that ideal we can approach while still maintaining a structure that is guaranteed, or at least highly likely, to remain stable in the long term.nnseful roof of ork s istribution  elaed lgorithmnnseful proof of work is likely the simpler idea. nitially, it was considered impossible to make a proof of work based on useful computation because of the verification problem a proof-of-work task cannot take longer than a few thousands steps because every node in the network also needs to verify it to accept the block.nnrimecoinnnwas the closest we got, and even there computing chains of prime numbers is not really all that useful. ow, thanks to the eistence of a programming environment with a built-in computational stack trace mechanism, there is actually an alternative approach that removes this particular obstacle, using spot-checking and deposit sacrifices to make sure that work is being done correctly. he approimate algorithm for doing so is as follows.nnuppose that (k) is a function that takes  bytes of random data as an input, carries out some computation taking n steps (where n is fairly large, say ten billion) and then returns a value  which is socially useful.nnn order to perform one round of mining, start off by choosing a random m, and let  be the block header. et k  sha( + m) as the seed.nnefine a function (, ) - ' where  is the program code,  is some tuple of data perhaps including stack, memory and program counter representing the state of the computation, and  carries out one computational step and returns the modified computational state '.nnet ]  { pc , stack ], memory k] } (or some other construction involving k in a different computational model). et i]  (, i-]) where  is the program corresponding to the evaluation of . n] should, in some appropriate fashion, contain the result of .nnefine  as a hash function of i] something like sha(pc + str(stack) + str(memory)) satisfies as a quick-and-dirty option. et i]  (i]). ompute all i] and all i] and let  be the root of a erkle tree of all i]. f   ^ /  then the work is valid and the miner is entitled to a reward.nnasically, we take the state of the program after each computational step (we can optionally make  process the eecution of a few thousand computational steps for greater efficiency this does not seriously compromise anything), and build a erkle tree out of the whole thing and look at the root. his is somewhat tricky to implement fortunately, however, the thereum virtual machine and block structure is already almost an eact replica of this algorithm, so one could take that code and use it almost verbatim.nnhe algorithm described above by itself has an obvious hole in it it is not easy-to-verify, so fraudulent miners can easily pollute the network with bad-seeming blocks. hus, as an anti-spam and anti-fraud mechanism, we require the followingnno be able to mine, nodes must purchase a “mining bond” of price  *  (say,   ^ and   ), which returns to the miner after  blocks. ach mining bond allows the miner to submit one work at a time.nnf a miner submits a seemingly-valid work, including the m and k values, the root, and the socially useful output, then the mining bond reward increases by nnnyone else with a mining bond can check the work themselves. f the erkle root at the end is inconsistent, then they can publish a “challenge” transaction consisting of some number (say, ) of sub-nodes. t that point, the original submitter has the choice of either giving up (as defined by not posting a response within  blocks), sacrificing their entire mining bond to the checker, or make a “response” transaction pointing out the first of those subnodes that they disagree with. f a response is submitted, the challenger must respond going down one level further, providing the siteen subnodes between the last agreed subnode and the first disagreed subnode, and so forth, until the process converges upon the interval between two adjacenti] and i+] values in the tree. t that point, the miner must submit the values of i] and i+] in a transaction, which is considered valid if and only if (i])  i+].nnhe problem is, however, that the process of checking takes as long as the original computation itself, so there does need to be an eplanation as to why anyone would do it. f all miners attempt to cheat frequently, then it makes sense to perform spot-checks in order to collect the deposit (which we assumed to be ), but if miners realize this and as a result don’t cheat then there is no longer an incentive to check, so no one would check and miners would have free rein to cheat. his is a classicnnhawk-dove equilibrium paradonn, and can be solved by game theory (here, we assume that mining has a cost of . and a reward of )nnheatsnnoes not cheatnnhecksnn(-, )nn(.,-.)nnoes not checknn(,)nn(.,)nnomputing a mied-strategy equilibrium in this simplified two-player model shows the miner cheating .% of the time and the checker checking .% of the time under those two conditions, each player is indifferent to the strategy of the other so there is no opportunity for either one to further optimize and cheat. f we push closer to the economic equilibrium of mining and we say that mining has a cost of ., then the equilibrium has a cheating rate of .% and a checking rate of .%. hus, economically driven spot-checking is a legitimate strategy for ratting out fraudulent mining attempts, and can keep cheating rates arbitrarily low if we are willing to push up collateral requirements.nno what kind of work can we do irst of all, it might be better not to include computation that is incapable of handling noise, ie. where a bad answer accepted as a good answer does more than  as much bad as an actual good answer. econd, the algorithm here allows for work that is not easy-to-verify, but it does nothing to allow work that is data-heavy. or eample,  is data-heavy – you need to have a picture of the sky in order to search it for aliens. hird, the algorithm must be parallelization-friendly. unning a machine learning algorithm on terabytes of data is not really something that can be split into discrete chunks, even large-sized ones. he second criterion can potentially be relaed because there isn’t really any benefit to mining with bad data versus good data, an  foundation can be set up which provides a stream of data for miners to work with, and adds a very small subsidy to encourage miners to use it. heoretically, the foundation can even be decentralized and run as a proof-of-stake-voting algorithm on a blockchain. he simplest kind of socially useful computation to use, however, might be genetic algorithms. enetic algorithms are often used to find solutions to problems that are intractable in closed-form, like finding optimal radio antenna shapes, spaceflight trajectories, aerodynamic shapes, and so forth the blockchain may provide an ideal environment for doing such computation on everyone’s nodes for free. ertain classes of data search and aggregation puzzles could also potentially be split up, though they are much more data-heavy whereas genetic algorithms are close to data-free once launched.nnarliaments nd etter lgorithmsnnlgorithmic consensus distribution is the more interesting possibility. hat if there can be a consensus algorithm to distribute tokens over time, where that algorithm can reward arbitrary good work or eample, one might want to pay bounties to people who contribute to the ecosystem, or even to the world in general. he simplest approach here seems to be to randomly select a “parliament” – every  blocks, stakeholders can vote on  nodes that will make the decision of where the newly generated funds will go.nnhe obvious question to ask is what are the economics of this n theory, the nodes will want to select the distribution that optimally benefits the community as a whole, so as to maimize their chance of getting re-elected. owever, are there opportunities for corruption e all know that traditional democracy is highly imperfect, so how do we know that our crypto-enabled wealth distribution scheme will be any better ortunately, there is one strong argument to be made that it actually will be. he reason is that traditional democracies have a number of very serious failure modes for eample, a parliament can seize people’s property, conscript people into armies for war, restrict free speech, etc. n this case, however, there is a very clear and obvious upper bound on how much damage a parliament could do it could redirect the money to split among itself. here is also the risk that the parliament will crowdfund something which is a public bad to society, but a public good among themselves (eg. a war), but they have no eisting military apparatus to latch onto and no eisting public consensus that they are supposed to be using coercive power for any reason at all so they are in no better a position to do such a thing than any other group commanding a similar level of economic resources. hus, if we suppose that parliaments fail, say, % of the time, then we can see how in a democracy this would be catastrophic but here it only means that the distribution mechanism becomes % as useful as it could be.nnnother criticism is that such a mechanism, no matter how it may be constructed, will invariably create some sort of political governance class, and thus will stabilize around a particular small set of political viewpoints, generate its own form of inequality, and eventually lead to a long-term hostile takeover. his would be limited in effect, but even still at its worst % of the new currency issuance will be siphoned off by a crypto-political elite. ne solution is to make parliaments randomly selected (ie. demarchy) rather than elected, reducing the chance of such conspiracies further but at the cost of weakening the parliament’s epected level of epertise on optimal distribution and its ability to form long-term consistent institutions however, if we want to create a system that has the political image of being neutral and decentralized that is perhaps something that we actually want.nnowever, we probably can, and certainly must at least try, to be more imaginative. arliaments and voting are only the simplest and crudest form of having a decentralized organization there are almost certainly better alternatives based on principles such as holarchy,nnliquid democracynn,nnfutarchynnand various combinations of these and other ideas that we have not thought of but that will become possible because of the much higher degree of both interconnectedness and information processing efficiency provided by modern technology. deally, as much of the process as possible would be in some fashion automated – the process should function as ann, not a nn, and the position of highest power, or the closest philosophical analog of such a thing, should be held by an algorithm and not a set of people – perhaps a sacrifice from the point of view of optimality at any particular time, but, one might argue, a boon for long-term stability, and an especially appropriate choice for a cryptographic platform that intends to claim some concept of neutrality.nn simple futarchy-based implementation might work as follows. uppose that there are  projects asking for a grant consisting of the entire currency supply to be distributed during some time period, and the desire is to select the one that will maimize the value of the coin after one year. e create  sub-tokens, ] ... -], where the value of i] is zero if project i does not get chosen but can be redeemed for one currency unit after one year if the project does get chosen. hen, we create subtokens ] ... -], where the value of i] is zero if the project does not get chosen or an amount of currency units equal to  computational steps in value (we include a small useful-o or useless-o market into the coin for this purpose) if the project does get chosen. ow, suppose that the probability of project i getting chosen is i] and the value of the token in the event that project i gets chosen after one year is i]. e note that the value of i] is i] _ i] and the value of i] is i] _  where  is the cost of computing  computational steps. ence, the project with maimumi] / i] also maimizes i] /  and hence i], so that project is assumed to maimize the value of the coin and hence chosen. he only challenge left is figuring out what the risks of market manipulation attacks are assuming there are individual parties with non-negligible market power. his strategy seems more mathematically clean and less vulnerable to turning into something centralized, but on the other hand there seem to be fewer safeguards to prevent it from becoming evil. he best response might simply be that a coin run by an evil  will lose public support, and hence will lose value, so the futarchy algorithm itself might select against such undesirable actions. econd, of course, the futarchy does not command a military and there is no pre-eisting public consensus that it is entitled to employ any kind of coercion.nnltimately, both of these approaches could be combined. ne can have a parliament, or a futarchy, select useful proof of work algorithms or even data for specific useful proof of work algorithms, or one can have a parliament or futarchy with useful proof of work as its voting mechanism. owever, one important conclusion here is that both of the algorithms described are complicatednnthere is no easy solutionnnto figuring out how to distribute coins in a good way. hich, given the state of the financial system at large, makes sense if it was easy to distribute coins fairly then the  dollar and other fiat currencies would have likely been overthrown in favor of such alternatives in at least some parts of the world a long time ago. ecause of the compleity involved, it is unlikely that either of these will be used for ether itself ether is intended to be boring crypto-gasoline with simple properties to target maimum stability and reliability, not a super-advanced economically innovative decentralized autonomous organization. o if you want to see eneticlgooin, utarchyoin and arliamentoin developed, feel free to run them on top of thereum as sub-currencies thennerpent compilernnis all yours to play with.nnredit to eal oblitz for suggesting the idea of spot-checking and convincing me of the importance of useful o, obin anson for inventing futarchy, and realistically probably at least several cryptographers who came up with the concept of multi-round challenge-response protocols before me