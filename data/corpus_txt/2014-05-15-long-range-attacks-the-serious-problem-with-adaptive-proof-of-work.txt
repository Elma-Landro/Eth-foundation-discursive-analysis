Titre: Long-Range Attacks: The Serious Problem With Adaptive Proof of Work\nAuteur: Vitalik Buterin\nDate: May 15, 2014\nURL: https://blog.ethereum.org/2014/05/15/long-range-attacks-the-serious-problem-with-adaptive-proof-of-work\nCatégorie: Non catégorisé\n\n==================================================\n\nur current proof of work design,nnblockchain-based proof of worknn, is the second iteration of our attempt to create a mining algorithm that is guaranteed to remain -friendly and resistant to optimization by specialized hardware (s) in the long term. ur first attempt, agger, tried to take the idea of memory-hard algorithms like crypt one step further by creating an algorithm which is memory-hard to compute, but memory-easy to verify, using directed acyclic graphs (basically, trees where each node has multiple parents). ur current strategy takes a much more rigorous track make the proof of work involve eecuting random contracts from the blockchain. ecause the thereum scripting language is uring-complete, an  that can eecute thereum scripts is by definition an  for general computation, ie. a  – a much more elegant argument than “this is memory-hard so you can’t parallelize as much”. f course, there are issues of “well, can you make specific optimizations and still get a large speedup”, but it can be argued that those are minor kinks to be worked out over time. he solution is also elegant because it is simultaneously an economic one if someone does create an , then others will have the incentive to look for types of computation that the  can’t do and “pollute” the blockchain with such contracts. nfortunately, however, there is one much larger obstacle to such schemes in general, and one which is unfortunately to some degree fundamental long-range attacks.nn long-range attack basically works as follows. n a traditional % attack,  put  bitcoins into a fresh new account, then send those  bitcoins to a merchant in echange for some instant-delivery digital good (say, litecoins).  wait for delivery (eg. after  confirmations), but then  immediately start working on a new blockchain starting from one block before the transaction sending the  bitcoins, and put in a transaction instead sending those bitcoins back to myself.  then put more mining power into my fork than the rest of the network combined is putting into the main chain, and eventually my fork overtakes the main chain and thereby becomes the main chain, so at the end  have both the bitcoins and the litecoins. n a long-range attack, instead of starting a fork  blocks back,  start the fork  blocks back, or even at the genesis block.nnn itcoin, such a fork is useless, since you’re just increasing the amount of time you would need to catch up. n blockchain-based proof of work, however, it is a serious problem. he reason is that if you start a fork straight from the genesis block, then while your mining will be slow at first, after a few hundred blocks you will be able to fill the blockchain up with contracts that are very easy for you to mine, but difficult for everyone else. ne eample of such a contract is simplynni  
while sha(i) ! ffbafeacbcdbdbbafaaeafecaffeef
i  i + nnou know that the contract will take eactly one million rounds before the hash matches up, so you can calculate eactly how many steps and how much gas it will take to run and what the state will be at the end immediately, but other people will have no choice but to actually run through the code. n important property of such a scheme, a necessary consequence of thennhalting problemnn, is that it is actually impossible (as in, mathematically provably impossible, not ollywood impossible) to construct a mechanism for detecting such clever contracts in the general case without actually running them. ence, the long-range-attacker could fill the blockchain with such contracts, “mine” them, and convince the network that it is doing a massive amount of work when it is actually just taking the shortcut. hus, after a few days, our attacker will be “mining” billions of times faster than the main chain, and thereby quickly overtake it.nnotice that the above attack assumes little about how the algorithm actually works all it assumes is that the condition for producing a valid block is dependent on the blockchain itself, and there is a wide range of variability in how much influence on the blockchain a single unit of computational power can have. ne solution involves artificially capping the variability this is done by requiring a tree-hashed computational stack trace alongside the contract algorithm, which is something that cannot be shortcut-generated because even if you know that the computation will terminate after  million steps and produce a certain output you still need to run those million steps yourself to produce all of the intermediate hashes. owever, although this solves the long-range-attack problem it also ensures that the primary computation is not general computation, but rather computing lots and lots of s – making the algorithm once again vulnerable to specialized hardware.nnroof of takenn version of this attack also eists for naively implemented proof of stake algorithms. n a naively implemented proof of stake, suppose that there is an attacker with % of all coins at or shortly after the genesis block. hat attacker then starts their own chain, and starts mining it. lthough the attacker will find themselves selected for producing a block only % of the time, they can easily produce  times as many blocks, and simply create a longer blockchain in that way. riginally,  thought that this problem was fundamental, but in reality it’s an issue that can be worked around. ne solution, for eample, is to note that every block must have a timestamp, and users reject chains with timestamps that are far ahead of their own.  long-range attack will thus have to fit into the same length of time, but because it involves a much smaller quantity of currency units its score will be much lower. nother alternative is tonnrequirennat least some percentage (say, %) of all coins to endorse either every block or every th block, thereby absolutely preventing all attacks with less than that percent of coins. ur own o algorithm,nnlashernn, can easily be retrofitted with either of these solutions.nnhus, in the long term, it seems like either pure proof of stake or hybrid o/o are the way that blockchains are going to go. n the case of a hybrid o/o, one can easily have a scheme where o is used to resolve the issue described above with o. hat we’ll go with for thereum . may be proof of stake, it might be a hybrid scheme, and it might be boring old , with the understanding that s will not be developed since manufacturers would see no benefit with the impending arrival of thereum .. owever, there is still one challenge that arguably remains unresolved the distribution model. or my own thoughts on that, stay tuned for the net part of this series.