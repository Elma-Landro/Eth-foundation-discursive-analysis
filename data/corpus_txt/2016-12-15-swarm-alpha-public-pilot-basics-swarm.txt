Titre: Swarm alpha public pilot and the basics of Swarm\nAuteur: Viktor Tron\nDate: on December 15, 2016\nURL: https://blog.ethereum.org/2016/12/15/swarm-alpha-public-pilot-basics-swarm\nCatégorie: Non catégorisé\n\n==================================================\n\nith the long awaitednngeth . ("let there bee light") releasenn, warm made it into the official go-ethereum release as an eperimental feature. henncurrent version of the codennis  .  -- "embrace your daemons" (nnroadmapnn), which is the refactored and cleaner version of the codebase that was running on the warm toynet in the past months.nnhe current release ships with thennswarmnncommand that launchesnna standalone warm daemonnnas separate process using your favourite -compliant ethereum client if needed. andwidth accounting (using the warm ccounting rotocol  ) is responsible for smooth operation and speedy content delivery by incentivising nodes to contribute their bandwidth and relay data. he  system is functional but it is switched off by default. torage incentives (punitive insurance) to protect availability of rarely-accessed content is planned to be operational innn .nn. o currently by default, the client uses the blockchain only for domain name resolution.nnith this blog post we are happy to announce the launch of our shiny new warm testnet connected to the opsten ethereum testchain. he thereum oundation is contributing a -strong (will be up to ) warm cluster running on the zure cloud. t is hostingnnthe warm homepagenn.nne consider this testnet as the first public pilot, and the community is welcome to join the network, contribute resources, and help us find issues, identify painpoints and give feedback on useability. nstructions can be found in thennwarm guidenn. e encourage those who can afford to run persistent nodes (nodes that stay online) tonnget in touchnn. e have already received promises for  deployments.nnote that the testnet offers no guarantees! ata may be lost or become unavailable. ndeed guarantees of persistence cannot be made at least until the storage insurance incentive layer is implemented (scheduled fornn .nn).nne envision shaping this project with more and more community involvement, so we are inviting those interested to join ournnpublic discussion rooms on gitternn. e would like to lay the groundwork for this dialogue with a series of blog posts about the technology and ideology behind warm in particular and about eb in general. he first post in this series will introduce the ingredients and operation of warm as currently functional.nnhat is warm after allnnwarm is a distributed storage platform and content distribution service a native base layer service of the ethereum eb stack. he objective is a peer-to-peer storage and serving solution that has zero downtime, is -resistant, fault-tolerant and censorship-resistant as well as self-sustaining due to a built-in incentive system. he incentive layer uses peer-to-peer accounting for bandwidth, deposit-based storage incentives and allows trading resources for payment. warm is designed to deeply integrate with the devpp multiprotocol network layer of thereum as well as with the thereum blockchain for domain name resolution, service payments and content availability insurance. odes on the current testnet use the opsten testchain for domain name resolution only, with incentivisation switched off. he primary objective of warm is to provide decentralised and redundant storage of thereum's public record, in particular storing and distributing dapp code and data as well as blockchain data.nnhere are two major features that set warm apart from other decentralised distributed storage solutions. hile eisting services (ittorrent, eronet, ) allow you to register and share the content you host on your server, warm provides the hosting itself as a decentralised cloud storage service. here is a genuine sense that you can just 'upload and disappear' you upload your content to the swarm and retrieve it later, all potentially without a hard disk. warm aspires to be the generic storage and delivery service that, when ready, caters to use-cases ranging from serving low-latency real-time interactive web applications to acting as guaranteed persistent storage for rarely used content.nnhe other major feature is the incentive system. he beauty of decentralised consensus of computation and state is that it allows programmable rulesets for communities, networks, and decentralised services that solve their coordination problems by implementing transparent self-enforcing incentives. uch incentive systems model individual participants as agents following their rational self-interest, yet the network's emergent behaviour is massively more beneficial to the participants than without coordination.nnot long after italik's whitepaper the thereum dev core realised that a generalised blockchain is a crucial missing piece of the puzzle needed, alongside eisting peer-to-peer technologies, to run a fully decentralised internet. he idea of having separate protocols (shh for hisper, bzz for warm, eth for the blockchain) was introduced in ay  by avin and italik who imagined the thereum ecosystem within the grand crypto . vision ofnnthe third webnn. he warm project is a prime eample of a system where incentivisation will allow participants to efficiently pool their storage and bandwidth resources in order to provide global content services to all participants. e could say that the smart contracts of the incentives implement thennhive mind of the swarmnn.nn thorough synthesis of our research into these issues led to the publication of the first twonnorange papersnn. ncentives are also eplained innnthe devcon talk about the warm incentive systemnn. ore details to come in future posts.nnow does warm worknnwarm is a network, a service and a protocol (rules).  warm network is a network of nodes running a wire protocol called bzz using the ethereum devpp/rlp network stack as the underlay transport. he warm protocol (bzz) defines a mode of interaction. t its core, warm implements anndistributed content-addressed chunk storenn. hunks are arbitrary data blobs with a fied maimum size (currently ). ontent addressing means that the address of any chunk is deterministically derived from its content. he addressing scheme falls back on a hash function which takes a chunk as input and returns a -byte long key as output.  hash function is irreversible, collision free and uniformly distributed (indeed this is what makes bitcoin, and in general proof-of-work, work).nnhis hash of a chunk is the address that clients can use to retrieve the chunk (the hash'snnpreimagenn). rreversible and collision-free addressing immediately provides integrity protection no matter the contet of how a client knows about an address,
it can tell if the chunk is damaged or has been tampered with just by hashing it.nnwarm's main offering as a distributed chunkstore is that you can upload content to it.
he nodes constituting the warm all dedicate resources (diskspace, memory, bandwidth and ) to store and serve chunks. ut what determines who is keeping a chunk
warm nodes have an address (the hash of the address of theirnnbzz-accountnn) in the same keyspace as the chunks themselves. ets call this address space thennoverlay networknn. f we upload a chunk to the warm, the protocol determines that it will eventually end up being stored at nodes that are closest to the chunk's address (according to a well-defined distance measure on the overlay address space). he process by which chunks get to their address is called syncing and is part of the protocol. odes that later want to retrieve the content can find it again by forwarding a query to nodes that are close the the content's address. ndeed, when a node needs a chunk, it simply posts a request to the warm with the address of the content, and the warm will forward the requests until the data is found (or the request times out). n this regard, warm is similar to a traditionalnndistributed hash table ()nnbut with two important (and under-researched) features.nnwarm uses a set of / connections in which each node has a set of (semi-)permanent peers. ll wire protocol messages between nodes are relayed from node to node hopping on active peer connections. warm nodes actively manage their peer connections to maintain a particular set of connections, which enables syncing and content-retrieval by key-based routing. hus, a chunk-to-be-stored or a content-retrieval-request message can always be efficiently routed along these peer connections to the nodes that are nearest to the content's address.nnhis flavour of the routing scheme is callednnforwarding ademliann.nnombined with the  incentive system, a node's rational self-interest dictates opportunistic caching behaviour he node caches all relayed chunks locally so they can be the ones to serve it net time it is requested. s a consequence of this behavior, popular content ends up being replicated more redundantly across the network, essentially decreasing the latency of retrievalsnn-nnwe say that call this phemon/outcome/] warm is 'auto-scaling' as a distribution network. urthermore, this caching behaviour unburdens the original custodians from potential  attacks.  incentivises nodes to cache all content they encounter, until their storage space has been filled up. n fact, caching incoming chunks of average epected utility is always a good strategy even if you need to epunge older chunks.
he best predictor of demand for a chunk is the rate of requests in the past. hus it is rational to remove chunks requested the longest time ago. o content that falls out of fashion, goes out of date, or never was popular to begin with, will be garbage collected and removed unless protected by insurance. he upshot is that nodes will end up fully utilizing their dedicated resources to the benefit of users. uch organic auto-scaling makes warm a kind of maimum-utilisation elastic cloud.nnocuments and the warm hashnnow we've eplained how warm functions as a distributed chunk store (fi-sized preimage archive), you may wonder, where do chunks come from and why do  carennn the  layer warm provides a chunker. he chunker takes any kind of readable source, such as a file or a video camera capture device, and chops it into fi-sized chunks. hese so-called data chunks or leaf chunks are hashed and then synced with peers. he hashes of the data chunks are then packaged into chunks themselves (called intermediate chunks) and the process is repeated. urrently  hashes make up a new chunk. s a result the data is represented by a merkle tree, and it is the root hash of the tree that acts as the address you use to retrieve the uploaded file.nnhen you retrieve this 'file', you look up the root hash and download its preimage. f the preimage is an intermediate chunk, it is interpreted as a series of hashes to address chunks on a lower level. ventually the process reaches the data level and the content can be served. n important property of a merklised chunk tree is that it provides integrity protection (what you seek is what you get) even on partial reads. or eample, this means that you can skip back and forth in a large movie file and still be certain that the data has not been tampered with. advantages of using smaller units (kb chunk size) include parallelisation of content fetching and less wasted traffic in case of network failures.nnanifests and snnn top of the chunk merkle trees, warm provides a crucial third layer of organising contentnnmanifestnnfiles. nnmanifestnnis a json array of manifest entries. n entry minimally specifies a path, a content type and a hash pointing to the actual content. anifests allow you to create a virtual site hosted on warm, which provides url-based addressing by always assuming that the host part of the url points to a manifest, and the path is matched against the paths of manifest entries. anifest entries can point to other manifests, so they can be recursively embedded, which allows manifests to be coded as a compacted trie efficiently scaling to huge datasets (i.e., ikipedia or ouube). anifests can also be thought of as sitemaps or routing tables that map url strings to content. ince each step of the way we either have merkelised structures or content addresses, manifests provide integrity protection for an entire site.nnanifests can be read and directly traversed using the bzzr url scheme. his use is demonstrated by thennwarm plorernn,nnan eample warm dappnnthat displays manifest entries as if they were files on a disk organised in directories. anifests can easily be interpreted as directory trees so a directory and a virtual host can be seen as the same.  simple decentralised dropbo implementation can be based on this feature. he warm plorer isnnup on swarmnn you can use it to browse any virtual site by putting a manifest's address hash in the urlnnthis link will show the eplorer browsing its own source codenn.nnash-based addressing isnnimmutablenn, which means there is no way you can overwrite or change the content of a document under a fied address. owever, since chunks are synced to other nodes, warm is immutable in the stronger sense that if something is uploaded to warm, it cannot be unseen, unpublished, revoked or removed. or this reason alone, be etra careful with what you share. owever you can change a site by creating a new manifest that contains new entries or drops old ones. his operation is cheap since it does not require moving any of the actual content referenced. hennphoto albumnnis another warm dapp that demonstrates how this is done.nnthe source on githubnn. f you want your updates to show continuity or need an anchor to display the latest version of your content, you need name based mutable addresses. his is where the blockchain, the thereum ame ervice and domain names come in.  more complete way to track changes is to use version control, like git ornnmango, a git using warm (or ) as its backendnn.nnthereum ame ervicennn order to authorise changes or publish updates, we need domain names. or a proper domain name service you need the blockchain and some governance. warm uses thennthereum ame ervice ()nntonnresolve domain namesnnto warm hashes. ools are provided to interact with the  to acquire and manage domains. he  is crucial as it is the bridge between the blockchain and warm.nnf you use thennwarm proynnfor browsing, the client assumes that the domain (the part after bzz/ up to the first slash) resolves to a content hash via . hanks to the proy and the standard url scheme handler interface,nnist integrationnnshould be blissfully easy for ist's official debut with etropolis.nnur roadmapnnis ambitious warm . comes with an etensive rewrite of the network layer and the syncing protocol, obfuscation and double masking for plausible deniability, kademlia routed pp messaging, improved bandwidth accounting and etended manifests with http header support and metadata. warm . is planned to ship client side redundancy with erasure coding, scan and repair with proof of custody, encryrption support, adaptive transmission channels for multicast streams and the long-awaited storage insurance and litigation.nnn future posts, we will discuss obfuscation and plausible deniability, proof of custody and storage insurance, internode messaging and the network testing and simulation framework, and more. atch this space, bzz...