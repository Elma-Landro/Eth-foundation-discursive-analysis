Titre: Geth v1.9.0\nAuteur: Péter Szilágyi\nDate: July 10, 2019\nURL: https://blog.ethereum.org/2019/07/10/geth-v1-9-0\nCatégorie: Non catégorisé\n\n==================================================\n\nfter many months of silence, we're proud to announce the v.. release of o thereum! lthough this release has been in the making for a lot longer than we anticipated, we're confident there will be some juicy feature for everyone to enjoy!nnarning e've tried our best to squash all the bugs, but as with all major releases, we advise everyone to take etra care when upgrading. he v.. release contains database schema changes, meaning it's not possible to downgrade once updated. e also recommend a fresh fast sync as it can drastically reduce the database size.nnome of the features mentioned here have been silently shipped over the course of the .. release family, but we've deemed them important enough to eplicitly highlight.nnerformancennt's interesting to realize that the "erformance" section was somewhere at the end of previous announcements, but over the years it became one of the most sought after improvement.nnver the past  months, we've tried to dissect the different components that are on the critical path of block processing, in an attempt to identify and optimize some of bottlenecks. mong the many improvements, the highest impact ones werennhe discovery and optimization of a quadratic  and disk  compleity, originating from the o implementation of evel. his caused eth to be starved and stalled, eponentially getting worse as the database grew. uge shoutout to ary ong for hisnnrelentless effortsnn, especially as his work is beneficial to the entire o community.nnhe analysis and optimization of the account and storage trie access patterns across blocks. his resulted in stabilizing eth's memory usage even during the import of the hanghai o blocks and speeding up overall block processing by concurrent heuristic state prefetching.nnhis worknnwas mostly done by éter zilágyi.nnhe analysis and optimization of various  opcodes, aiming to find outliers both in eth's  implementation as well as thereum's protocol design in general. his led to both fies in eth as well as infos funneled into the th . scaling discussions. houtout goes to artin olst wende fornnpioneeringnnthis effort.nnhe analysis and optimization of our database schemas, trying to both remove any redundant data as well as redesign indees for lower disk use (sometimes at the cost of a slight  hit). rops for these efforts (spanning - months) go to leey khunov, ary ong, éter zilágyi and atthew alpern.nnhe discovery of a evel compaction overhead during the state sync phase of fast sync. y temporarily allocating pruning caches to fast sync blooms, we've been able to short circuit most data accesses in-memory.nnhis worknnwas mostly done by éter zilágyi.nn] ast syncnne've run a fast sync benchmark on twonni.largenn  instances ( core,  i , . i e ) withnn--cache --mapeersnn(defaults on v..) on the th of pril.nnersionnnync timennisk sizennisk readsnnisk writesnneth v..nnh mnninn.inn.inneth v..nnh mnninn.inn.inn] ull syncnne've run a full sync benchmark on twonni.largenn  instances ( core,  i , . i e ) withnn--cache --mapeers --syncmodefullnn.nnersionnnync timennisk sizennisk readsnnisk writesnneth v..nnd h mnninn.inn.inneth v..nnd h m*nninn.i*nn.i*nn*hilst the performance is similar, we've achieved that while reducing the memory use by about /rd and completely removing spurious memory peaks (hanghai o). he reason for the higher disk  is due to using less memory for caching, having to push more aggressively to disk.nn] rchive syncnne've run an archive sync benchmark on twonnm.largenn  instances ( core,  i , i  ) withnn--cache --syncmodefull --gcmodearchivenn.nnersionnnync timennisk sizennisk readsnnisk writesnneth v..nnd hnn.inn.inn.inneth v..nnd h*nn.inn.inn.inn*  volumes are significantly slower than physical s attached to the . etter performance can be achieved on s with real s or actual physical hardware.nnreezernnouldn't it be amazing if we didn't have to waste so much precious space on our epensive and sensitive s to run an thereum node, and could rather move at least some of the data onto a cheap and durable nnith the v.. release, ethnnseparatednnits database into two parts (done by éter zilágyi, artin olst wende and ary ong)nnecent blocks, all state and accelerations structures are kept in a fast key-value store (evel) as until now. his is meant to be run on top of an  as both disk  performance is crucial.nnlocks and receipts that are older than a cutoff threshold ( epochs) are moved out of evel into a customnnfreezernndatabase, that is backed by a handful of append-only flat files. ince the node rarely needs to read these data, and only ever appends to them, an  should be more than suitable to cover it.nn fresh fast sync at block . placed  of data into the freezer and  of data into evel.nnreezer basicsnny default eth will place your freezer inside yournnchaindatannfolder, into thennancientnnsubfolder. he reason for using a sub-folder was to avoid breaking any automated tooling that might be moving the database around or across instances. ou can eplicitly place the freezer in a different location via thenn--datadir.ancientnn flag.nnhen you update to v.. from an older version, eth will automatically being migrating blocks and receipts from the evel database into the freezer. f you haven't specifiednn--datadir.ancientnnat that time, but would like to move it later, you will need to copy the eistingnnancientnnfolder manually and then start eth withnn--datadir.ancientnnset to the correct path.nnreezer tricksnnince the freezer (cold data) is stored separately from the state (hot data), an interesting question is what happens if one of the two databases goes missingnnf thennfreezernnis deleted (or a wrong path specified), you essentially pull the rug from underneath eth. he node would become unusable, so it eplicitly forbids doing this on startup.nnf, however, thennstate databasennis the one delete, eth willnnreconstructnnall its indices based on the frozen data and then do a fast sync on top tonnback-fillnnthe missing state.nnssentially, the freezer can be used as annguerrilla state prunernnto periodically get rid of accumulated junk. y removing the state database, but not the freezer, the node will do a fast sync to fetch the latest state, but will reuse all the eisting block and receipt data already downloaded previously.nnou can trigger this vianngeth removedbnn(plus thenn--datadirnnandnn--datadir.ancientnnflags if you used custom ones) asking it to only remove the state database, but not the ancient database.nne advised, that reindeing all the transactions from the ancient database can take over an hour, and fast sync will only commence afterwards. his will probably be changed into a background process in the near future.nnraphnnho doesn't just love -nne!nns its name suggests, - is a *emote rocedurennall*nnprotocol. ts design goal is to permitnncalling functionsnn, that do some arbitrary computation on the remote side, after which they return the result of said computation. f course - the protocol being generic - you can run data queries on top, but there's no standardized query semantic, so people tend to roll their own.nnithout support for fleible queries however, we end up wasting both computational and data transfer resourcesnn calls that return a lot of data (e.g.nneth_getlocknn) waste bandwidth if the user is only interested in a handful of fields (e.g. only the header, or even less, only the miner's address).nn calls that return only a bit of data (e.g.nneth_getransactioneceiptnn) waste  capacity if the user is forced to repeat the call multiple times (e.g. retrieving all receipts one-by-one results in loadingnnall of themnnfrom disk for each call).nnn the case of thereum's - , the above issues get eacerbated by the mini-reorg nature of the blockchain, as doing multiple queries (e.g.nneth_getalancenn) need to actually ensure that they eecute against the same state and even against the same node (e.g. load balanced backends might have slight sync delays, so can serve different content).nnes, we could invent a new, super optimal query mechanism that would permit us to retrieve only the data we need, whilst minimizing computational and data transfer overhead... or we could also not-reinvent the wheel (again) and rather use one that's been proven alreadynnraphnn.nnuerying with raphnnirst thing's first, a huge shoutout goes to aúl ripalani, ris hinn, ick ohnson, nfura and egasys, for pioneering both thennraph specnnand itsnnimplementationnn, as well as to uillaume allet for doing the final integrations!nneth v.. introduces native raph query capabilities via thenn--graphqlnn flag. raph itself being a protocol on top of , the same suite of sub-flags (restrictions,  and virtual hosts rules) are available as for  . ut enough of this yada-yada, let's see it!nnor a quick spin, lets try and find all the  domain registrations on the örli testnet! tart eth v.. on örli with raph enabled (nngeth --goerli --graphqlnn), wait until it syncs (should be - minutes tops) and point your browser to the... gasp... built in raph eplorer atnnhttp//localhostnn!nno keep things simple,nnhere's a quick sample querynnthat finds the nnashegisterednnevents and returns the address of the user doing the registration along with the block number and timestamp it was included innnlbeit the eample is a bit contrived and simplistic, it does highlight that raph allows us to answer comple "join queries" that previously required many  calls and returned a lot more data than actually needed.nns with all epic developer tools, eth v..'s raph eplorer has integrated code completion, field documentation and live query eecution! o and query something awesome!nnardware walletsnneth already supported certain hardware wallets in the past, but with the v.. release, we've upped our game and made that list a lot more etensive!nnedger walletsnne've already supported thennedger ano nnfor a couple years now, but eth v.. also introduces native support for thennedger ano nn(via )!nndditionally, v.. replaces the default  derivation path from the legacy one, that edger originally advertised, to the canonical one, used by all thereum wallets (and presently by edger too).nnon't worry, eth will find all your old accounts too, just will use the canonical path for new accounts!nnhis worknnwas done by éter zilágyi.nnf you haven't used a edger through eth until now, the workflow isnnlug in your edger ano  or edger ano  and unlock via your  code.nntart the thereum app on your edger (eth will lognnthereum app offlinenn).nnou can list all your accounts viannpersonal.listalletsnnfrom the eth console.nnhis will auto-derive any accounts that you've used before +  empty new one.nnlternatively you can do the same thing through  viannpersonal_listalletsnn.nnransact via your preferred means and eth will forward the signing request to the edger.nninu users be aware, you need tonneplicitly permitnnyour user to access your edger wallet viannudevnnrules!nnrezor walletsnnor almost two years now we've supported thennrezor nenn. nfortunately a firmware update (v..+) changed the  protocol in a backwards incompatible way. lthough we recommend everyone use the latest software when it comes to security, we also acknowledge the reluctance of regularly updating firmware on a cold storage device.nns such, eth v.. implements the new eb protocol supporting updated rezor ne models, but at the same time keeps support for the old   protocol too for non-updated devices.nnhis supportnnwas added by uillaume allet and éter zilágyi (we've even published a newnnusbnnlibrary for o to support it).nnhe rezor ne workflow is a bit more comple due to the unique  entrynnlug in your rezor ne, eth will detect it but will prompt you to open it.nnallnnpersonal.openallet('trezor//...')nnwith the  of the device.nnf you don't know the , you can check viannpersonal_listalletsnn.nnhe console will keep prompting for  entry and password as needed.nnalling via ,nnopenalletnnreturns a detailed error if it needs another call.nnou can list all your accounts via personal.listallets from the eth console.nnhis will auto-derive any accounts that you've used before +  empty new one.nnlternatively you can do the same thing through  viannpersonal_listalletsnn.nnransact via your preferred means and eth will forward the signing request to the rezor.nnn addition to etended support for the rezor ne, eth v.. also introduces native support for thennrezor odel nn. he odel 's workflow is a bit simpler as the  entry is done on devicennlug in your rezor odel  and unlock via your  code, eth should detect it.nnou can list all your accounts viannpersonal.listalletsnnfrom the eth console.nnhis will auto-derive any accounts that you've used before +  empty new one.nnlternatively you can do the same thing through  viannpersonal_listalletsnn.nnransact via your preferred means and eth will forward the signing request to the rezor.nninu users be aware, you need tonneplicitly permitnnyour user to access your rezor wallet viannudevnnrules!nntatus keycardsnnrototyped more than a year ago, eth v.. finally ships support for thenntatus keycardnn, a full  hardware wallet based on ava martards. he tatus keycard can be used via eth only through the / daemon for now (you need to install it) and via  (thenn+innis a good  smartcard reader).nnhis worknnwas heavy lifted by ick ohnson, initially integrated by éter zilágyi and finalized by uillaume allet (and of course ndrea ranz and the rest of the tatus team).nnf you already have an initialized tatus keycard, the eth workflow isnnlug in your tatus keycard via a  card reader.nnheck the status of your card viannpersonal_listalletsnn.nnermit eth to use the card viannpersonal.openallet('keycard//...')nn.nnhe very first time eth will ask you to pair your card via the passphrase.nnn normal operation, eth will ask you to unlock your card via your  code.nnn too many wrong s, eth will ask you to reset your card via your  code.nnn too many wrong s, your card will be bricked and you'll need to reinstall it.nnlternatively you can do the same thing through  via multiplennpersonal_openallet()nn.nnransact via your preferred means and eth will forward the signing request to the tatus keycard.nnf you don't have a pre-initialized tatus keycard are using a developer card or managed to brick your eisting card (hey, we're developers, wennmustnnknow what happens then), you can follow ournntechnical guidennon how to wipe your keycard and reinitialize it.nnote, you will lose your private key on a wipe.nnlefnnallets, wallets everywhere!nnhen thereum launched in , there was no third party tooling whatsoever, so client implementations needed to be these all-encompassing wiss army knives. anging from peer-to-peer networking, through account management, to contract and user interactions, everything was done by the client. his was necessary, but seriously sub-optimal accounts and networking don't go well together security wise, and everything done by a single binary doesn't permit a composable ecosystem.nne've been wanting to do this for at least  years now, and eth v.. finally ships thennworknnof artin olst wende (with the help of many others) a standalone signer for thennentirennthereum ecosystem callednnlefnn. s simple as a "standalone signer" might sound, lef is the result of an insane amount of architectural work to make it secure, fleible and composable.nn small release blog post simply cannot do this project justice, but we'll try nonetheless to at least mention the major features of lef, the design decisions behind them and how they can enable a whole set of new use cases.nncosystem composabilitynnhe main reason for creating lef was to remove account management from eth (don't worry, the old way will still work for the foreseeable future). his permits eth to be an "insecure" network gateway into thereum, which should solve many many issues with regard to accidentally eposing accounts via  (and unlocking them, the deadly combo).nnut hogging all this work for eth wouldn't be nice of us. nstead, we designed lef to be usable by arbitrary programs, so that you can have a single signernnsecurelynnmanaging your keys, to which arbitrary applications (e.g. eth, arity, rinity, etamask, yrypto, ugur) can send signing requests to!nno achieve this, lef eposes a tinynneternal nn(nnchangelognn) either via  (default) or . ny program that can access these endpoints (e.g. eth via , etamask via ) can sendnnsigning requestsnnto lef, which will prompt the user for manual confirmation. he  is deliberately tiny and uses -, so it should be trivial to support in any project.nnur goal with lef is not to benn"he eth igner"nn, rather we'd like it to become a standalone entity that can be used by any other project, be it different client implementations (rinity), browser integrations (etamask), service components (aiden) or decentralized applications (ugur).nnf you'd like to integrate lef, reach out and we'll !nnluggable interfacennhat is the perfect user interfacennf you ask me, 'd saynncommand linenn simple, works over , and  can code it . ut 'm a minority here and even  often prefer a proper . o,nnlectronnn ome think it's the best thing since sliced bread and many developers can code it but it's large and slow and avacript . ow aboutnntnn t's cross platform, tiny and fast, but not many developers are familiar with it and it has a funky license. ndroid, , ihingy... in 😂nnhe answer isnnall of themnn! he perfect  depends on what you want to use it for, and we don't want to make that choice for you, rather allow you to run lef the way it fits best into your lifennf you are on the move all the time, you may prefer an ndroid or i interface.nnf you have a locked down remote server, you may prefer  on top of .nnf you have a powerful laptop, the beauty of lectron might be just the thing.nnf you have an offline signer machine, a t  might be simple, but enough.nnf you are a bank, you might want a custom integration into your own infra.nne can't implement all this. ut you can! e've designed lef with enough fleibility to allow anyone to implement a custom  on top, without needing to touch lef itself, or know any o at all. he goal is to provide a building block to the community so that designers and  developers can do what they're good at, without having to worry about cryptography and stuff.nno achieve this, lef eposes an etendednninternal nn(nnchangelognn),nnsolelynnvia standard input/output. ny user interface is meant to start itself up and internally start an instance of lef, binding to it's  streams. he  streams speak -, so the  can send arbitrarynntrustednnrequests to lef, and lef will send notifications and confirmation prompts to the .nnlef itself ships with a built in  interface (otherwise it's not much useful) and we've prepared an entirennuickstart uidennto familiarize yourself with the general features and concepts. here are also variousnnproof-of-concept snnthat we've used to validate architectural decisions, but to get a solid , we need the community, as we don't have the knowledge ourselves!nnntegrated bytesnnou probably figured out the general direction by now. e want lef to be a reusable piece of puzzle. he trick is to make it the right size! oo much functionality baked in (e.g. fied ), and possible uses get limited. oo few (e.g. no hardware wallet) and  builders reinvent the wheel. t's a delicate balance of maimizing utility and security without compromising fleibility.nno, we agree that "fied  bad, pluggable  good", "no hardware wallet bad, edger + rezor + eycard good". hat else do wallet implementations reinvent all the timennbytesnn!nnn thereum, whenever a user interacts with a contract, they send a giant blob of binary data, encoded in a very specificnn formatnn. his is needed so that the  can make heads or tails of it, and of course this is generated by some program (e.g. ugur). roblem is, the user is then prompted to confirm a transaction that looks like thisnnhe solution of the thereum community was to assemble annbytenndatabase, so that by looking at the first  bytes of the above data, you can guess what the rest of the data is meant to represent, and can thus show the user a meaningful dump of what they are about to confirm (images above and below courtesy of therscan).nnurrently all thereum wallet s reinvent the wheel when it comes to integrating bytes! he database is public, but the integrations are custom. lef ships the entire byte database embedded in itself, and whenever a transaction is made, it decodes the calldata internally. ot only does lef send the decoded call to the , but also adds warning messages if the data does not match the method signature! lef will handle thereum, you can focus on the !nnrogrammatic rulesnnlef seems awesome, what more could we ask for ell... based on the above sections, we can build the perfect signer to confirm any and all of our transactions... manually. hat happens, however, if we want to automate some of that (e.g. lique signer, aiden relay, warm echange, etc). enncouldnnjust not care and let the  sort it out... but then we're back in square one, as all wrapping s need to reinvent the same mechanisms, and most will probably do it insecurely.nnlef solves this via an encrypted key-value store and an ingenious rule engine! nstead of prompting the user to confirm each and every request via a passphrase entry, we can permit lef to sign on our behalf by storing our passphrase in its encrypted database. his will only allow passwordless signing, but still needs manual confirmation!nns a second step, however, we can also provide lef with a avacriptnnrule filenn, that will run whenever a request arrives and can decide to auto-confirm, auto-reject, or forward the request for manual confirmation. he avacript rules have access to the entire request and can also store arbitrary data in a key-value store for persistence. .g. n academic demo rule filennfunctionnnpproveignatann(nnreqnn)nn{nnifnn(nnreqnn.nnaddressnn.nntoowerasenn(nn)nnnn'dccdfbeedeacfbefaf'nn)nn{nnifnn(nnreqnn.nnmessagesnnnnnn]nn.nnvaluenn.nnindefnn(nn'bazonk'nn)nnnnnn)nn{nnreturnnn'pprove'nnnn}nnreturnnn'eject'nnnn}nn// therwise goes to manual processingnn}nnhe goal of these rules is to allow you to configure arbitrary approval logic for whatever your use case might be, whether that's automatic server-side transactions (lique, aiden, warm, aucet) or low-value client-side automation (approve  ei / h to ugur). he programmable rules ensure that lef remains true to its composability promise, permitting anyone to build their dream integration on top.nnor a full demo on how to set up automatic rules, please check the lefnnuickstart uidenn.nnight clientsnnight clients are tricky and they make everything more complicated than it should be. he root cause is more philosophical than technical the best things in life are free, and the second best are cheap. n thereum client terms, thenn"best"nnclients are those that work with  overhead (think etamask, nfura), the second best are the light clients.nnroblem is, trusted servers go against the ethos of the project, but light clients are often too heavy for resource constrained devices (ethash murders your phone battery). eth v.. ships a new mode for light clients, called annnultra light clientnn. his mode aims to position itself midway on the security spectrum between a trusted server and a light server, replacing o verification with digital signatures from a majority of trusted servers.nnith enough signatures from independent entities, you could achieve more than enough security for non-critical pps. hat said, ultra light client mode is not really meant for your average node, rather for projects wishing to ship eth embedded into their own process. hisnnworknnwas spearheaded by oris etrov and tatus.nnheckpoint oraclennight clients are dirty little cheats! nstead of downloading and verifying each header from the genesis to chain head, they use a hard coded checkpoint (shipped within eth) as a starting point. f course, this checkpoint contains all the necessary infos to cryptographically verify even past headers, so security wise nothing is lost.nntill, as useful as the embedded checkpoints are, they do have their shortcomingsnns the checkpoints are hard coded into our release binaries, older releases will always start syncing from an older block. his is fine for a few months, but eventually it gets annoying. ou can, of course, update eth to fetch a new checkpoint, but that also pulls in all our behavioral changes, which you may not want to do for whatever reason.nnince these checkpoints are embedded into the code, you're out of luck if you want to support them in your own private network. ou'd need to either ship a modified eth, or configure the checkpoints via a config file, distributing annnewnnone whenever you update the checkpoint. oable, but not really practical long term.nnhis is where ary ong's and solt elföldi'snnworknncomes in to play. eth v.. ships support for an on-chain checkpoint oracle. nstead of relying on hard-coded checkpoints, light clients can reach out tonnuntrustednnremote light servers (peer-to-peer, no centralized bs) and ask them to return an updated checkpoint stored within an on-chain smart contract. he best part, light clients can cryptographically prove that the returned data was signed by a required number of approved signers!nnait, how does a light client know who's authorized to sign an on-chain checkpoint or networks supported out of the bo, eth ships with hard coded checkpoint oracle addresses and lists of authorized signers (so you're trusting the same devs who ship eth itself). or private networks, the oracle details can be specified via a config file.nnlthough the old and new checkpoint mechanisms look similar (both require hard-coded data in eth or a config file), the new checkpoint oracle needs to be configurednnonly oncennand afterwards can be used arbitrarily long to publish new checkpoints.nncheckpoint-adminnnthereum contracts are powerful, but interacting with them is not for the faint of heart. ur checkpoint oracle contract is an especially nasty beast, because a) it goes out of its way to retain security even in the face of chain reorgs and b) it needs to support sharing and proving checkpoints to not-yet-synced clients.nns we don't epect anyone (not even ourselves) to manually interact with the checkpoint oracle, eth v.. also ships an admin tool specifically for this contract,nncheckpoint-adminnn.nnote, you'll only ever need to care about this if you want to run your own checkpoint oracle for your own private network.nnhenncheckpoint-adminnncan be used to query the status of an already deployed contract (nn--rpcnnneeds to point to either a light node, or a full node withnn--lightservnnenabled, both with thennlesnn  namespace eposed)nn$ checkpoint-admin --rpc ~/.ethereum/rinkeby/geth.ipc statusnnraclennnnnnebeedeaccdnndminnnnnnnnndfbeeecfbfnndminnnnnnnnndafbenndminnnnnnnnnffbabnndminnnnnnnnnbebeccaffnnheckpointnn(nnpublished atnn#)   cebadbaeccfbfadcadfbbcfbdbefnnhe admin command can also be used tonndeploynna new oracle,nnsignnnan updated checkpoint andnnpublishnnit into the network. urthermore,nncheckpoint-adminnnalso works in offline mode (without a live chain to provide data) and can also be backed bynnclefnnfor signing instead of using key files, but describing all these is for another day.nnonitoringnnhis is perhaps something that not many knew about, but since pretty much forever, eth had built in support for monitoring different subsystems and events. aturally, thennoriginal versionnnwas quite crude 🤣 (tet ,  reporting), but it provided the ground work. e can do better than this!nnetrics collectionnnirst thing's first, metrics need to be gathered before they can be eported and visualized. eth can be instructed to collect all its known metrics via thenn--metricsnn flag. o epose these measurements to the outside world, eth v.. features  independent mechanismsnnparsnn,nnnflunnandnnrometheusnn.nnparsnnare a somewhat custom means in the o ecosystem to epose public variables on an  interface. eth uses its debugnnpprofnnendpoint to epose these on. unning eth withnn--metrics --pprofnnwill epose the metrics innnepvarnnformat atnnhttp//.../debug/metricsnn.nnlease note, you should never epose thennpprofnn endpoint to the public internet as it can be used to trigger resource intensive operations!nnpars are well-ish supported within the o ecosystem, but are not the industry standard.  similar mechanism, but with a more standardized format, is thennrometheusnnendpoint. unning eth withnn--metrics --pprofnnwill also epose this format atnnhttp//.../debug/metrics/prometheusnn.nngain, please never epose thennpprofnn endpoint to the public internet!nnhoutout to aim rasilnikov fornncontributingnnthis feature.nnhereas pars and rometheus arennpullnnbased monitoring mechanisms (remote servers pull the data from eth), we also supportnnpushnnbased monitoring viannnflunn(eth pushes the data to remote servers). his feature requires a number of  flags to be set to configure the database connection (server, database, username, password and eth instance tag). lease see thenn   nnsection ofnngeth helpnnfor details (nn--metrics.infludbnnand subflags).nnhis worknnwas done by nton vangelatov.nnetrics visualizationnnisualizing metrics can be a little daunting since you need to pick a charting program/service and put a whole lot of work into it to configure all the hosts, charts and dashboards.nne ourselves are usingnnatadognninternally and have been contiguously tweaking our monitoring dashboards ever since we created them . years ago. f you are already using atadog or are considering to do so, here's a teaser of what you can assemble based on the metrics eposed by eth (this is the dashboard through which we compare s against master)nnnfortunately atadog does not support sharing dashboards with eternal entities (since they depend on how the monitored machines have been configured). s such, we can't easily share the above work with you, but we did eport ann dumpnnof it in case anyone's willing to follow in our footsteps!nnf course, we also understand that a paid service such as atadog is not always ideal, especially if you are just starting out and don't have money to burn on monitoring.  brilliant free monitoring tool isnnrafanann!nnaim rasilnikov made a rafana dashboardnna while agonnagainst an older development version of eth. e took his awesome work and merged into it the stats that we ourselves grew fond of in atadog, resulting in quite a bit ofnnetra worknnon eth. he end result, however, is stunning (epect further updates over the net releases)nnou can quickly reproduce the above charts viannmy clonennof aim rasilnikov's project by runningnndocker-compose upnnin the repo root and accessingnnhttp//localhostnnwith thennadmin/adminnncredentials. lternatively, you can viewnnmy testing snapshotnnon aintank, or importnnthis dashboardnninto your own rafana instancennuppeth eplorernn long time ago in a far away land, uppeth saw the first light of day (specifically, in eico, just shy of two years ago). f you haven't head about it, "uppeth is a tool to aid you in creating a new thereum network down to the genesis block, bootnodes, signers, ethstats, faucet, wallet, eplorer and dashboard". riginally it was created to support deploying and maintaining the inkeby testnet, but has since been used by various groups for other private networks too.nnuppeth is not a tool for maintaining a high value production network, but it has, nonetheless, proven itself robust enough to keep inkeby relevant for over two years now! f you'd like a deeper dive into uppeth,nnhere's my reveal talknnfrom way back. n this post however lets focus on what's new!nnuppeth is awesome! t allowed you since day  to deploy a full, operational thereum network across multiple machines, etended with a stats page to aid maintenance, along with a faucet and a dashboard to help onboard users easily. uppeth, however, lacked a robust block eplorer, since the only contenders back then werenntherscannnandnntherchainnn, both closed source. e did hack something in, but it was kind ofnnmehnn...nnith the announcement ofnnlockscoutnnlate last year, everything changed! he thereum community finally got a real, open source block eplorer, courtesy of thenn etworknnteam. ompared to the established players, lockscout of course has some catching up to do, but that does not stop us from realizing that it is already an insanely valuable asset. s such, eth v.. ships a preliminary integration of lockscout into uppeth, filling a huge hole in our private network deployment tool!nnhisnneffortnnwas pioneered by ary ong, but a huge shoutout goes to yrat adykov too for his help in sorting out issues, questions and whatnot.nnlease note, that we epect the initial integration to be rough (e.g. due to ann"bug"nnin lockscout, the uppeth eplorer will need to fully sync a eth archive node before it can boot up the eplorer web interface). y all means test it, run it, report any issues, but don't be surprised if it goes down at !nniscovery protocolnnow here's another piece of legacy infrastructure! part from a teeny-tiny modification, thereum'snndiscovery protocolnnhas been specced, implemented and set in stone since pretty much forever. or those wondering what the discovery protocol is all about, it's the mechanism through which a new node can find other thereum nodes on the internet and join them into a global peer-to-peer network.nno... what's wrong with it then idn't it work well enough until now f it ain't broken, don't fi it and all thatnnell, thereum's original discovery protocol was made for a different time, a time when there was only one chain, when there weren't private networks, when all nodes in the network were archive nodes. e outgrew these simplistic assumptions, which although is a success story, it also brings new challengesnnhe thereum ecosystem nowadays has many public, private and test networks. lthough thereum mainnet consists of a large number of machines, other networks are generally a lot smaller (e.g. örli testnet). he discovery protocol doesn't differentiate between these networks, so connecting to a smaller one is a never ending trial and error of finding unknown peers, connecting to them, then realizing they are on a different network.nnhe same original thereum network can end up partitioning itself into multiple disjoint pieces, where participants might want to join one piece or the other. thereum lassic is one of the main eamples here, but a similar issue arises every time a network upgrade (hard fork) passes and some nodes upgrade late. ithout information concerning the rules of the network, we again fall back to trial and error connectivity, which is computationally etremely epensive.nnven if all nodes belong to the same network and all nodes adhere to the same fork rules, there still eists a possibility that peering is hard if there is connectivity asymmetry, where some nodes depend on services offered by a limited subset of machines (i.e. light clients vs. light servers).nnong term we're working towards annbrand new versionnnof the discovery protocol. eth's light clients have been since forever using a o version of this, but rolling out such a major change for the entire thereum network requires a lot of time and a lot of care. his effort it being piloted primarily by eli ange and rank zendzielarz in collaboration with ndrei aiboroda from leth/++, ntoine oulme with ava, ge anning from ighthouse/ust and omasz tańczak from ethermind/#.nnthereum ode ecordsnnhe above was a whole lot of tet about something we didn't ship! hat we did ship however, is thennthereum ode ecord ()nnetension of the new discovery protocol, which can actuallynnrun on top of the old protocolnntoo! n  is a tiny,  byte, arbitrary key-value data set, that nodes can advertise and query via discovery. lthough the new discovery protocol will provide fancy ways of sharing these in the network, the old protocol too is capable of directly querying them.nnhe immediate benefit is that nodes can advertise a lot of metadata about themselves without an epensive  + crypto handshake, thus allowing potential peers to filter out unwanted connections without ever making them in the first place! ll credits go to eli ange for his unwavering efforts on this front!nnk, ok, we get it, it's fancy. ut what is it actually, you know, useful for, in human-speaknneth v.. ships two etensions to the discovery protocol via snnhe current discovery protocol is only capable of handling one type of  address (v or v). ince most of the internet still operates on v, that's what peers advertise and share with each other. ven though v is workable, in practice younncannotnnfind such peers. eli ange'snnworknnon advertisingnnbothnnv and v addresses via s allows peers to discover and maintain ademlia routing tables for both  types. here's still integration work to be done, but we're hoping to elevate v to a first class citizen of thereum.nninding a inkeby node nowadays works analogously to connecting to random websites and checking if they are oogle or not. he discovery protocol maintains a soup of internet addresses that speak the thereum protocol, but otherwise has no idea which chain or which forks they are on. he only way to figure out, is to connect and see, which is a very epensive shooting-in-the-dark. éter zilágyinnproposednnan etension to  which permits nodes to advertise their chain configuration via the discovery protocol, resulting in a - mechanism for rejecting surely bad peers.nnhe most amazing thing however with  - and its already implemented etras - is that anyone can write a  crawler to inde thereum nodes, without having to connect to them (most nodes won't have free slots and crawlers that do connect via  waste costly resources). aving simple access to all the nodes, their s/ports, capabilities and chain configurations permits the creation of a brand newnndiscovery protocol based on nn, allowing nodes with blocked  ports (e.g. via or) to join the network too!nnootnodesnne've had a varying number of bootnodes of varying quality, managed by varying people since the rontier launch. lthough it worked well-ish, from a devops perspective it left a lot to desire, especially when it came to monitoring and maintenance. o go along our eth v.. release, we've decided to launch a new set of bootnodes that is managed via erraform and nsible and monitored via atadog and apertrail. e've also enabled them to serve light clients, hopefully bumping the reliability of the light protocol along the way. uge shoutout to afael atias for his work on this!nnur new list of bootnodes isnnenode//dafddeabaffffdbbaaaffbbbbbdbdfefabfdaddeeceeedbf...nn(ingapore, )nnenode//acabcaaedcbffefbcaaaebbabfddddcedacdfadde...nn(irginia, )nnenode//cadefcefaeaecadaadbecbeeadefbcaefcdbbaeceadfab...nn(reland, )nnenode//ddcddffaafcacaaeebcfafbdfdeacefbccececeabbbfccebd...nn(rankfurt, )nnenode//dacdbeeeeecccaedfecacabeccebdedecbbbdeefddbfaa...nnustralia, zure)nnenode//bdbcfebebdcbefaddbbfbeccddffbcbfffdadfcfebdabcbcafc...nn(razil, zure)nnenode//fabaaecdafaaafdbcbcaaacbebbbbfbcfacccbdee...nn(outh orea, zure)nnenode//ddcdddabbadcadbdbedfcdfcaeccaabdcbaeffdfcbacbbabf...nn(est , zure)nnur legacy bootnodes will continue to function for the time being, but will be gradually sunset in the following months.nnther changesnneside all the awesome features enumerated above, there are a few other notable changes that are not large enough to warrant their own section, but nonetheless important enough to eplicitly mention.nn snnhe origin check on ebocket connections (nn--wsoriginsnn) is enforced only when thennriginnnheader is present. his makes it easier to connect to eth from non-browser environments such as ode.js, while preventing use of the  endpoint from arbitrary websites.nnou can set the maimum gas fornneth_callnnusing thenn--rpc.gascapnncommand line option. his is useful if eposing the - endpoint to the nternet.nnll  method invocations are now logged atnndebugnnlevel. ailing methods log asnnwarningnnso you can always see when something isn't right.nneth v.. supports thenneth_chaindnn method defined innn nn.nnetworkingnnhe default peer count is now  instead of . his change improves sync performance.nn new  tool (nncmd/devppnn) was added to the source tree for for debugging  networking issues. hile we don't distribute this tool in thennalltoolsnnarchive yet, it's already very useful to check issues with peer discovery.nnhe  server now rejects connections from s that attempt to connect too frequently.nniscellaneousnn lot of work has gone into improving thennabigennntool. o bindings now support oliditynnstructnnand function pointer arguments. he ava generator is improved as well. he mobile framework can create deploy transactions.nnignificant parts of thenngo-ethereumnnrepo now build without . ig thanks to eremy chlatter for this work.nnompatibilitynnlthough o thereum v.. brings an impressive number of improvements, there are a few backwards incompatible changes too. his section is a rundown of all the things that got changed or sunset in the releasennccount unlocking with open , ebocket or raph ports have beennndisallowednndue to security reasons. ower users can restore the old behavior with thenn--allow-insecure-unlocknn flag at their own risk.nnhe old buntu docker images and thennold (monolithic)nnlpine docker images have beennnremovednnas deprecated over a year ago. nless you configured your cluster in , you most probably used the slim lpine images and are safe.nnhe originalnngeth monitornn command wasnnremovednnalong with its supportingnndebug_metricsnn  endpoint. nyone relying on monitoring should use the par, nfu or rometheus metrics reporting along with atadog or rafana.nnhenngeth bugnn command has beennnremovednn, being an unnecessary nicety. f you encounter a bug, you can simply open an issue on ournnitub trackernnand fill out the template manually.nnhennles/nnandnneth/nnprotocols were removed.nnles/nnwas only supported by eth and everyone on onstantinople runsnnles/nnalready.nneth/nnwas deprecated even before rontier, but was left in fornncpp-ethereumnn.nnoogle+ authentication has beennnremovednnfrom the uppeth faucet since oogle sunset its social network in the beginning of pril, .nnhe edger  wallet derivation path wasnnupdatednnfrom the orignal legacy path to the canonical ecosystem one.nnccounts from old paths will still be discovered.nnhe default cache allowance isnnchosen dynamicallynnbased on the network and sync modes. ainnet full nodes default to , testnet and private networks to . ight clients default to . plicitnn--cachennis of course honored.nnhe o calculation in hisper v was incompatible with arity due to not fully adhering to the spec. his wasnnfiednn, but it also means that hisped v shipped with eth v.. is incompatible with previous versions.nnhenn--lightservnnandnn--lightpeersnnflags werennrenamednntonn--light.servennandnn--light.mapeersnnrespectively. he old versions are deprecated, but will continue to work for the net year or so.nnhe default datadir on indows is now derived from thennocalppatannenvironment variable. he old location innn$/ppata/oamingnnis still recognized. he location change works better with ygwin and setups using remote user accounts.nnhe - server has been rewritten and now supports bi-directional communication. ou can epose method handlers on the client side using thennrpc.lient.egisteramennmethod. hile we did test this etensively, there may be compatibility issues with the new server. lease report any  issues you find.nnpiloguenne're really proud of this release! t took a lot longer than epected, but we wanted to ship all the breaking changes in one go to minimize potential surprises (upgrade issues) and to finalize the s of new features, to avoid breaking them later. ope you too will find a gem for yourself among our shippednn~ changesnn.nns with all our previous releases, you can find thennource code, git tags and whatnot on ournnitub release pagenn.nnre-built binaries for all platforms on ournndownloads pagenn.nnocker images published undernnethereum/client-gonn.nnbuntu packages in ournnaunchpad  repositorynn.nn packages in ournnomebrew ap repositorynn.nnnd as a last word before signing off (better twice than none)nnarning e've tried our best to squash all the bugs, but as with all major releases, we advise everyone to take etra care when upgrading. he v.. release contains database schema changes, meaning it's not possible to downgrade once updated. e also recommend a fresh fast sync as it can drastically reduce the database size.