Titre: Privacy on the Blockchain\nAuteur: Vitalik Buterin\nDate: January 15, 2016\nURL: https://blog.ethereum.org/2016/01/15/privacy-on-the-blockchain\nCatégorie: Non catégorisé\n\n==================================================\n\nlockchains are a powerful technology, as regular readers of the blog already likely agree. hey allow for a large number of interactions to be codified and carried out in a way that greatly increases reliability, removes business and political risks associated with the process being managed by a central entity, and reduces the need for trust. hey create a platform on which applications from different companies and even of different types can run together, allowing for etremely efficient and seamless interaction, and leave an audit trail that anyone can check to make sure that everything is being processed correctly.nnowever, when  and others talk to companies about building their applications on a blockchain, two primary issues always come up scalability and privacy. calability is a serious problem current blockchains, processing - transactions per second, are several orders of mangitude away from the amount of processing power needed to run mainstream payment systems or financial markets, much less decentralized forums or global micropayment platforms for o. ortunately,nntherennarennsolutionsnn, and we are actively working onnnimplementingnna roadmap to making them happen. he other major problem that blockchains have is privacy. s seductive as a blockchain's other advantages are, neither companies or individuals are particularly keen on publishing all of their information onto a public database that can be arbitrarily read without any restrictions by one's own government, foreign governments, family members, coworkers and business competitors.nnnlike with scalability, the solutions for privacy are in some cases easier to implement (though in other cases much much harder), many of them compatible with currently eisting blockchains, but they are also much less satisfying. t's much harder to create a "holy grail" technology which allows users to do absolutely everything that they can do right now on a blockchain, but with privacy instead, developers will in many cases be forced to contend with partial solutions, heuristics and mechanisms that are designed to bring privacy to specific classes of applications.nnhe oly railnnirst, let us start off with the technologies thatnnarennholy grails, in that they actually do offer the promise of converting arbitrary applications into fully privacy-preserving applications, allowing users to benefit from the security of a blockchain, using a decentralized network to process the transactions, but "encrypting" the data in such a way that even though everything is being computed in plain sight, the underlying "meaning" of the informationnnis completely obfuscatednn.nnhe most powerful technology that holds promise in direction is, of course, cryptographically secure obfuscation. n general, obfuscation is a way of turning any program into a "black bo" equivalent of the program, in such a way that the program still has the same "internal logic", and still gives the same outputs for the same inputs, but it's impossible to determine any other details about how the program works.nnhink of it as "encrypting" the wires inside of the bo in such a way that the encryption cancels itself out and ultimately has no effect on the output, but does have the effect of making it absolutely impossible to see what is going on inside.nnnfortunately, absolutely perfect black-bo obfuscation is mathematicallynnknown to be impossiblenn it turns out that there is always at leastnnsomethingnnthat you can get etract out of a program by looking at it beyond just the outputs that it gives on a specific set of inputs. owever, there is a weaker standard callednnindistinguishability obfuscationnnthat we can satisfy essentially, given twonnequivalentnnprograms that have been obfuscated using the algorithm (eg.nn  (a + b) * cnnandnn  (a * c) + (b * c)nn), one cannot determine which of the two outputs came from which original source. o see how this is still powerful enough for our applications, consider the following two programsnny  nny  sign(privkey, ) - sign(privkey, )nnne just returns zero, and the other uses an internally contained private key to cryptographically sign a message, does that same operation another time, subtracts the (obviously identical) results from each other and returns the result, which is guaranteed to be zero. ven though one program just returns zero, and the othernncontains and uses a cryptographic private keynn, if indistinguishability is satisfied then we know that the two obfuscated programs cannot be distinguished from each other, and so someone in possession of the obfuscated program definitely has no way of etracting the private key - otherwise, that would be a way of distinguishing the two programs. hat's some pretty powerful obfuscation right there - and for about two years we've known how to do it!nno, how do we use this on a blockchain ere's one simple approach for a digital token. e create an obfuscated smart contract which contains a private key, and accepts instructions encrypted with the correponding public key. he contract stores account balances in storage encrypted, and if the contract wants to read the storage it decrypts it internally, and if the contract wants to write to storage it encrypts the desired result before writing it. f someone wants to read a balance of their account, then they encode that request as a transaction, and simulate it on their own machine the obfuscated smart contract code will check the signature on the transaction to see if that user is entitled to read the balance, and if they are entitled to read the balance it will return the decrypted balance otherwise the code will return an error, and the user has no way of etracting the information.nnowever, as with several other technologies of this type, there is one problem the mechanism for doing this kind of obfuscation is horrendously inefficient. illion-factor overhead is the norm, and often even highly optimistic annrecent papernnestimates that "eecuting a -bit multiplication] circuit on the same  would take . * nnnnyears". dditionally, if you want to prevent reads and writes to storage from being a data leak vector, you must also set up the contract so that read and write operations always modify large portions of a contract's entire state - another source of overhead. hen, on top of that, you have the overhead of hundreds of nodes running the code on a blockchain, one can quickly see how this technology is, unfortunately, not going to change anything any time soon.nnaking  tep ownnnowever, there are two branches of technology that can get younnalmostnnas far as obfuscation, though with important compromises to the security model. he first is secure multi-party computation. ecure multi-party computation allows for a program (and its state) to be split among  parties in such a way that you need  of them (eg.   ,   ) to cooperate in order to either complete the computation or reveal any internal data in the program or the state. hus, if you can trust the majority of the participants to be honest, the scheme is as good as obfuscation. f you can't, then it's worthless.nnhe math behind secure multi-party computation is comple, but much simpler than obfuscation if you are interested in the technical details, then you can read morennherenn(and also the paper of nigma, a project that seeks to actually implement the secret sharing  concept,nnherenn).  is also much more efficient than obfuscation, the point that you can carry out practical computations with it, but even still the inefficiencies are very large. ddition operations can be processed fairly quickly, but every time an  instance performs some very small fied number of multiplication operations it needs to perform a "degree reduction" step involving messages being sent from every node to every node in the network. ecent work reduces the communication overhead from quadratic to linear, but even still every multiplication operation brings a certain unavoidable level of network latency.nnhe requirement of trust on the participants is also an onerous one note that, as is the case with many other applications, the participants have the ability to save the data and then collude to uncover at any future point in history. dditionally, it is impossible to tell that they have done this, and so it is impossible to incentivize the participants to maintain the system's privacy for this reason, secure multi-party computation is arguably much more suited to private blockchains, where incentives can come from outside the protocol, than public chains.nnnother kind of technology that has very powerful properties is zero-knowledge proofs, and specifically the recent developments in "nnsuccinct arguments of knowledgenn" (s). ero-knowledge proofs allow a user to construct a mathematical proof that a given program, when eecuted on some (possibly hidden) input known by the user, has a particular (publicly known) output,nnwithout revealing any other informationnn. here are manynnspecializednntypes of zero-knowledge proofs that are fairly easy to implement for eample, you can think of a digital signature as a kind of zero-knowledge proof showing that you know the value of a private key which, when processed using a standard algorithm, can be converted into a particular public key. -s, on the other hand, allow you to make such a proof fornnanynnfunction.nnirst, let us go through some specific eamples. ne natural use case for the technology is in identity systems. or eample, suppose that you want to prove to a system that you are (i) a citizen of a given country, and (ii) over  years old. uppose that your government is technologically progressive, and issues cryptographically signed digital passports, which include a person's name and date of birth as well as a private and public key. ou would construct a function which takes a digital passport and a signature signed by the private key in the passport as input, and outputs  if both (i) the date of birth is before , (ii) the passport was signed with the government's public key, and (iii) the signature is correct, and outputs  otherwise. ou would then make a zero-knowledge proof showing that you have an input that, when passed through this function, returns , and sign the proof with another private key that you want to use for your future interactions with this service. he service would verify the proof, and if the proof is correct it would accept messages signed with your private key as valid.nnou could also use the same scheme to verify more comple claims, like " am a citizen of this country, and my  number is not in this set of  numbers that have already been used", or " have had favorable reviews from some merchants after purchasing at least $, worth of products from them", or " hold assets worth at least $,".nnnother category of use cases for the technology is digital token ownership. n order to have a functioning digital token system, you do not strictly need to have visible accounts and balances in fact, all that you need is a way to solve the "double spending" problem - if you have  units of an asset, you should be able to spend those  units once, but not twice. ith zero-knowledge proofs, we can of course do this the claim that you would zero-knowledge-prove is something like " know a secret number behind one of the accounts in this set of accounts that have been created, and it does not match any of the secret numbers that have already been revealed". ccounts in this scheme become one-time-use an "account" is created every time assets are sent, and the sender account is completely consumed. f you do not want to completely consume a given account, then you must simply create two accounts, one controlled by the recipient and the other with the remaining "change" controlled by the sender themselves. his is essentially the scheme used bynncashnn(see more about how it worksnnherenn).nnor two-party smart contracts (eg. think of something like a financial derivative contract negotiated between two parties), the application of zero-knowledge-proofs is fairly easy to understand. hen the contract is first negotiated, instead of creating a smart contract containing the actual formula by which the funds will eventually be released (eg. in a binary option, the formula would be "if inde  as released by some data source is greater than , send everything to , otherwise send everything to "), create a contract containing thennhash of the formulann. hen the contract is to be closed, either party can themselves compute the amount that  and  should receive, and provide the result alongside a zero-knowledge-proof that a formula with the correct hash provides that result. he blockchain finds out how much  and  each put in, and how much they get out, but notnnwhynnthey put in or get out that amount.nnhis model can be generalized to -party smart contracts, and thennawknnproject is seeking to do eactly that.nntarting from the ther nd ow-ech pproachesnnhe other path to take when trying to increase privacy on the blockchain is to start with very low-tech approaches, using no crypto beyond simple hashing, encryption and public key cryptography. his is the path that itcoin started from in  though the level of privacy that it provides in practice is quite difficult to quantify and limited, it still clearly provided some value.nnhe simplest step that itcoin took to somewhat increase privacy is its use of one-time accounts, similar to cash, in order to store funds. ust like with cash, every transaction mustnncompletely emptynnone or more accounts, andnncreatennone or more new accounts, and it is recommended for users to generate a new private key for every new account that they intend to receive funds into (though it is possible to have multiple accounts with the same private key). he main benefit that this brings is that a user's funds are not linked to each other by default if you receive  coins from source  and  coins from source , there is no way for other users to tell that those funds belong to the same person. dditionally, if you spend  coins to someone else's account , and thereby create a fourth account  where you send the remaining  coins from one of these accounts as "change", the other users cannot even tell which of the two outputs of the transaction is the "payment" and which is the "change".nnowever, there is a problem. f, at any point in the future, you make a transaction consuming from two accounts at the same time, then you irrevertibly "link" those accounts, making it obvious to the world that they come from one user. nd, what's more, these linkages are transitive if, at any point, you link together  and , and then at any other point link together  and , and so forth, then you've created a large amount of evidence by which statistical analysis can link up your entire set of assets.nnitcoin developer ike earn came up with a mitigation strategy that reduces the likelihood of this happening callednnmerge avoidancenn essentially, a fancy term for trying really really hard to minimize the number of times that you link accounts together by spending from them at the same time. his definitely helps, but even still, privacy inside of the itcoin system has proven to be highly porous and heuristic, with nothing even close to approaching high guarantees.nn somewhat more advanced technique is callednnoinoinnn. ssentially, the oinoin protocol works as followsnn parties come together over some anonymous channel, eg. or. hey each provide a destination addressnn] ... ]nn.nnne of the parties creates a transaction which sends one coin to each destination address.nnhe  parties log out and then separately log in to the channel, and each contribute one coin to the account that the funds will be paid out from.nnf  coins are paid into the account, they are distributed to the destination addresses, otherwise they are refunded.nnf all participants are honest and provide one coin, then everyone will put one coin in and get one coin out, butnnno one will know which input maps to which outputnn. f at least one participant does not put one coin in, then the process will fail, the coins will get refunded, and all of the participants can try again. n algorithm similar to this was implementednnby mir aaki and ablo artin for itcoinnn, and bynnavin ood and lad luhovsky for thereumnn.nno far, we have only discussed token anonymization. hat about two-party smart contracts ere, we use the same mechanism as awk, ecept we substitute the cryptography with simpler cryptoeconomics - namely, the "auditable computation" trick. he participants send their funds into a contract which stores the hash of the code. hen it comes time to send out funds, either party can submit the result. he other party can either send a transaction to agree on the result, allowing the funds to be sent, or it can publish the actual code to the contract, at which point the code will run and distribute the funds correctly.  security deposit can be used to incentivize the parties to participate honestly. ence, the system is private by default, and only if there is a dispute does any information get leaked to the outside world.nn generalization of this technique is callednnstatennchannelsnn, and also has scalability benefits alongside its improvements in privacy.nning ignaturesnn technology which is moderately technically complicated, but etremely promising for both token anonymization and identity applications, is ring signatures.  ring signature is essentially a signature that proves that the signer has a private key corresponding to one of a specific set of public keys,nnwithout revealing which onenn. he two-sentence eplanation for how this works mathematically is that a ring signature algorithm includes a mathematical function which can be computed normally with just a public key, but where knowing the private key allows you to add a seed to the input to make the output be whatever specific value you want. he signature itself consists of a list of values, where each value is set to the function applied to the previous value (plus some seed) producing a valid signature requires using knowledge of a private key to "close the loop", forcing the last value that you compute to equal the first. iven a valid "ring" produced in this way, anyone can verify that it is indeed a "ring", so each value is equal to the function computed on the previous value plus the given seed, but there is no way to tell at which "link" in the ring a private key was used.nnhere is also an upgraded version of a ring signature called annlinkable ring signaturenn, which adds an etra property if you sign twice with the same private key, that fact can be detected - but no other information is revealed. n the case of token anonymization, the application is fairly simple when a user wants to spend a coin, instead of having them provide a regular signature to prove ownership of their public key directly, we combine public keys together into groups, and ask the user to simply prove membership in the group. ecause of the linkability property, a user that has one public key in a group can only spend from that group once conflicting signatures are rejected.nning signatures can also be used for voting applications instead of using ring signatures to validate spending from a set of coins, we use them to validate votes. hey can also be used for identity applications if you want to prove that you belong to a set of authorized users, without revealing which one, ring signatures are well-suited for just that. ing signatures are more mathematically involved than simple signatures, but they are quite practical to implement some sample code for ring signatures on top of thereumnncan be found herenn.nnecret haring and ncryptionnnometimes, blockchain applications are not trying to mediate the transfer of digital assets, or record identity information, or process smart contracts, and are instead being used on more data-centric applications timestamping, high-value data storage, proof of eistence (ornnproof of ineistencenn, as in the case of certificate revocations), etc.  common refrain is the idea of using blockchains to build systems where "users are in control of their own data".nnn these cases, it is once again important to note that blockchains do  solve privacy issues, and are an authenticity solution only. ence, putting medical records in plaintet onto a blockchain is a ery ad dea. owever, they can be combined with other technologies thatnndonnoffer privacy in order to create a holistic solution for many industries that does accomplish the desired goals, with blockchains being a vendor-neutral platform where some data can be stored in order to provide authenticity guarantees.nno what are these privacy-preserving technologies ell, in the case of simple data storage (eg. medical records), we can just use the simplest and oldest one of all encryption! ocuments that are hashed on the blockchain can first be encrypted, so even if the data is stored on something likennnnonly the user with their own private key can see the documents. f a user wants to grant someone else the right to view some specific records in decrypted form, but not all of them, one can use something like anndeterministic walletnnto derive a different key for each document.nnnother useful technology is secret sharing (described in more detailnnherenn), allowing a user to encrypt a piece of data in such a way that  of a given  users (eg.   ,   ) can cooperate to decrypt the data, but no fewer.nnhe uture of rivacynnhere are two major challenges with privacy preserving protocols in blockchains. ne of the challenges is statistical in order for any privacy-preserving scheme to be computationally practical, the scheme must only alter a small part of the blockchain state with every transaction. owever, even if thenncontentsnnof the alteration are privacy, there will inevitably be some amount ofnnmetadatannthat is not. ence, statistical analyses will always be able to figure outnnsomethingnn at the least, they will be able to fish for patterns ofnnwhennntransactions take place, and in many cases they will be able to narrow down identities and figure out who interacts with whom.nnhe second challenge is the developer eperience challenge. uring-complete blockchains work very well for developers because they are very friendly to developers that are completely clueless about the underlying mechanics of decentralization they create a decentralized "world computer" which looks just like a centralized computer, in effect saying "look, developers, you can code what you were planning to code already, ecept that this new layer at the bottom will now make everything magically decentralized for you". f course, the abstraction is not perfect high transaction fees, high latency, gas and block reorganizations are something new for programmers to contend with, but the barriers are notnnthatnnlarge.nnith privacy, as we see, there is no such magic bullet. hile there arennpartial solutionsnnfor specific use cases, and often these partial solutions offer a high degree of fleibility, the abstractions that they present are quite different from what developers are used to. t's not trivial to go from "-line python script that has some code for subtracting  coins from the sender's balance and adding  coins to the recipient's balance" to "highly anonymized digital token using linkable ring signatures".nnrojects like awk are very welcome steps in the right direction they offer the promise of converting an arbitrary -party protocol into a zero-knowledge-ified protocol that trusts only the blockchain for authenticity, and one specific party for privacy essentially, combining the best of both worlds of a centralized and decentralized approach. an we go further, and create a protocol that trusts zero parties for privacy his is still an active research direction, and we'll just have to wait and see how far we can get.