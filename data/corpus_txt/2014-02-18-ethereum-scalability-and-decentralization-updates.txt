Titre: Ethereum Scalability and Decentralization Updates\nAuteur: Vitalik Buterin\nDate: February 18, 2014\nURL: https://blog.ethereum.org/2014/02/18/ethereum-scalability-and-decentralization-updates\nCatégorie: Non catégorisé\n\n==================================================\n\ncalability is now at the forefront of the technical discussion in the cryptocurrency scene. he itcoin blockchain is currently over   in size, requiring a period of several days for a new bitcoind node to fully synchronize, the  set that must be stored in  is approaching  , and continued software improvements in the source code are simply not enough to alleviate the trend. ith every passing year, it becomes more and more difficult for an ordinary user to locally run a fully functional itcoin node on their own desktop, and even as the price, merchant acceptance and popularity of itcoin has skyrocketed the number of full nodes in the network has essentially stayed the same since . he   block size limit currently puts a theoretical cap on this growth, but at a high cost the itcoin network cannot process more than  transactions per second. f the popularity of itcoin jumps up tenfold yet again, then the limit will force the transaction fee up to nearly a dollar, making itcoin less useful than aypal. f there is one problem that an effective implementation of cryptocurrency . needs to solve, it is this.nnhe reason why we in the cryptocurrency spaceare having these problems, and are making so little headway toward coming up with a solution, is that there one fundamental issue with all cryptocurrency designs that needs to be addressed. ut of all of the various proof of work, proof of stake and reputational consensus-based blockchain designs that have been proposed, not a single one has managed to overcome the same core problem that every single full node must process every single transaction. aving nodes that can process every transaction, even up to a level of thousands of transactions per second, is possible centralized systems like aypal, astercard and banking servers do it just fine. owever, the problem is that it takes a large quantity of resources to set up such a server, and so there is no incentive for anyone ecept a few large businesses to do it. nce that happens, then those few nodes are potentially vulnerable to profit motive and regulatory pressure, and may start making theoretically unauthorized changes to the state, like giving themselves free money, and all other users, which are dependent on those centralized nodes for security, would have no way of proving that the block is invalid since they do not have the resources to process the entire block.nnn thereum, as of this point, we have no fundamental improvements over the principle that every full node must process every transaction. here have been ingenious ideas proposed by various itcoin developers involving multiple merge-mined chains with a protocol for moving funds from one chain to another, and these will be a large part of our cryptocurrency research effort, but at this point research into how to implement this optimally is not yet mature. owever, with the introduction ofnnlock rotocol .nn(), we have a protocol that, while not getting past the fundamental blockchain scalability flaw, does get us partway there as long as at least one honest full node eists (and, for anti-spam reasons, has at least .% mining power or ether ownership), “light clients” that only download a small amount of data from the blockchain can retain the same level of security as full nodes.nnhat s  ight lientnnhe basic idea behind a light client is that, thanks to a data structure present in itcoin (and, in annmodified formnn, thereum) called a erkle tree, it is possible to construct a proof that a certain transaction is in a block, such that the proof is much smaller than the block itself. ight now, a itcoin block is about   in size a erkle proof of a transaction is about half a kilobyte. f itcoin blocks become   in size, the proofs might epand to a whole kilobyte. o construct a proof, one simply needs to follow the “branch” of the tree all the way up from the transaction to the root, and provide the nodes on the side every step of the way. sing this mechanism, light clients can be assured that transactions sent to them (or from them) actually made it into a block.nnhis makes it substantially harder for malicious miners to trick light clients. f, in a hypothetical world where running a full node was completely impractical for ordinary users, a user wanted to claim that they sent   to a merchant with not enough resources to download the entire block, the merchant would not be helpless they would ask for a proof that a transaction sending   to them is actually in the block. f the attacker is a miner, they can potentially be more sophisticated and actually put such a transaction into a block, but have it spend funds (ie. ) that do not actually eist. owever, even here there is a defense the light client can ask for a second erkle tree proof showing that the funds that the   transaction is spending also eist, and so on down to some safe block depth. rom the point of view of a miner using a light client, this morphs into a challenge-response protocol full nodes verifying transactions, upon detecting that a transaction spent an output that does not eist, can publish a “challenge” to the network, and other nodes (likely the miner of that block) would need to publish a “response” consisting of a erkle tree proof showing that the outputs in question do actually eist in some previous block. owever, there is one weakness in this protocol in itcoin transaction fees.  malicious miner can publish a block giving themselves a   reward, and other miners running light clients would have no way of knowing that this block is invalid without adding up all of the fees from all of the transactions themselves for all they know, someone else could have been crazy enough to actually add   worth of fees.nnnnith the previous lock rotocol ., thereum was even worse there was no way for a light client to even verify that the state tree of a block was a valid consequence of the parent state and the transaction list. n fact, the only way to get any assurances at all was for a node to run through every transaction and sequentially apply them to the parent state themselves. , however, adds some stronger assurances. ithnnnn, every block now has three trees a state tree, a transaction tree, and a stack trace tree providing the intermediate root of the state tree and the transaction tree after each step. his allows for a challenge-response protocol that, in simplified form, works as followsnniner  publishes block . erhaps the miner is malicious, in which case the block updates the state incorrectly at some point.nnight node  receives block , and does basic proof of work and structural validity checks on the header. f these checks pass, then  starts off treating the block as legitimate, though unconfirmed.nnull node  receives block , and starts doing a full verification process, applying each transaction to the parent state, and making sure that each intermediate state matches the intermediate state provided by the miner. uppose that  finds an inconsistency at point k. hen,  broadcasts a “challenge” to the network consisting of the hash of  and the value k.nn receives the challenge, and temporarily flags  as untrustworthy.nnf ’s claim is false, and the block is valid at that point, then  can produce a proof of localized consistency by showing a erkle tree proof of point k in the stack trace, point k+ in the stack trace, and the subset of erkle tree nodes in the state and transaction tree that were modified during the process of updating from k to k+.  can then verify the proof by taking ’s word on the validity of the block up to point k, manually running the update from k to k+ (this consists of processing a single transaction), and making sure the root hashes match what  provided at the end.  would, of course, also check that the erkle tree proof for the values at state k and k+ is valid.nnf ’s claim is true, then  would not be able to come up with a response, and after some period of time  would discard  outright.nnote that currently the model is for transaction fees to be burned, not distributed to miners, so the weakness in itcoin’s light client protocol does not apply. owever, even if we decided to change this, the protocol can easily be adapted to handle it the stack trace would simply also keep a running counter of transaction fees alongside the state and transaction list. s an anti-spam measure, in order for ’s challenge to be valid,  needs to have either mined one of the last  blocks or have held .% of the total supply of ether for at least some period of time. f a full node sends a false challenge, meaning that a miner successfully responds to it, light nodes can blacklist the node’s public key.nnltogether, what this means is that, unlike itcoin, thereum will likely still be fully secure, including against fraudulent issuance attacks, even if only a small number of full nodes eist as long as at least one full node is honest, verifying blocks and publishing challenges where appropriate, light clients can rely on it to point out which blocks are flawed. ote that there is one weakness in this protocol you now need to know all transactions ahead of time before processing a block, and adding new transactions requires substantial effort to recalculate intermediate stack trace values, so the process of producing a block will be more inefficient. owever, it is likely possible to patch the protocol to get around this, and if it is possible then . will have such a fi.nnlockchain-based iningnne have not finalized the details of this, but thereum will likely use something similar to the following for its mining algorithmnnet i]  sha(sha(block header without nonce) ++ nonce ++ i) for i in  ...]nnet  be the number of transactions in the block.nnet i] be the (i] mod )th transaction in the block.nnet  be the parent block state.nnpply ] ... ] to , and let the resulting state be '.nnet   sha('.root)nnhe block is valid if  * difficulty  ^nnhis has the following propertiesnnhis is etremely memory-hard, even more so thannnaggernn, since mining effectively requires access to the entire blockchain. owever it is parallelizable with shared disk space, so it will likely be -dominated, not -dominated as agger originally hoped to be.nnt is memory-easy to verify, since a proof of validity consists of only the relatively small subset of atricia nodes that are used while processing ] ... ]nnll miners essentially have to be full nodes asking the network for block data for every nonce is prohibitively slow. hus there will be a larger number of full nodes in thereum than in itcoin.nns a result of (), one of the major motivations to use centralized mining pools, the fact that they allow miners to operate without downloading the entire blockchain, is nullified. he other main reason to use mining pools, the fact that they even out the payout rate, can be assomplished just as easily with the decentralized ppool (which we will likely end up supporting with development resources)nns for this mining algorithm are simultaneously s for transaction processing, so thereum s will help solve the scalability problem.nnrom here, there is only really one optimization that can be made figuring out some way to get past the obstacle that every full node must process every transaction. his is a hard problem a truly scalable and effective solution will take a while to develop. owever, this is a strong start, and may even end up as one of the key ingredients to a final solution.