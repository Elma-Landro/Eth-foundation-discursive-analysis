Titre: Scalability, Part 2: Hypercubes\nAuteur: Vitalik Buterin\nDate: October 21, 2014\nURL: https://blog.ethereum.org/2014/10/21/scalability-part-2-hypercubes\nCatégorie: Non catégorisé\n\n==================================================\n\npecial thanks to lad amfir, hris arnett and ominic illiams for ideas and inspirationnnn annrecent blog postnn outlined some partial solutions to scalability, all of which fit into the umbrella of thereum . as it stands. pecialized micropayment protocols such as channels and probabilistic payment systems could be used to make small payments, using the blockchain either only for eventual settlement, or only probabilistically. or some computation-heavy applications, computation can be done by one party by default, but in a way that can be "pulled down" to be audited by the entire chain if someone suspects malfeasance. owever, these approaches are all necessarily application-specific, and far from ideal. n this post,  describe a more comprehensive approach, which, while coming at the cost of some "fragility" concerns, does provide a solution which is much closer to being universal.nnnderstanding the bjectivennirst of all, before we get into the details, we need to get a much deeper understanding of what we actually want. hat do we mean by scalability, particularly in an thereum contet n the contet of a itcoin-like currency, the answer is relatively simple we want to be able tonnrocess tens of thousands of transactions per secondnnrovide a transaction fee of less than $.nno it all while maintaining security against at least % attacks and without highly centralized full nodesnnhe first goal alone is easy we just remove the block size limit and let the blockchain naturally grow until it becomes that large, and the economy takes care of itself to force smaller full nodes to continue to drop out until the only three full nodes left are run by ash.io, oinbase and ircle. t that point, some balance will emerge between fees and size, as ecessize size leads to more centralization which leads to more fees due to monopoly pricing. n order to achieve the second, we can simply have many altcoins. o achieve all three combined, however, we need to break through a fundamental barrier posed by itcoin and all other eisting cryptocurrencies, and create a system that works without the eistence of any "full nodes" that need to process every transaction.nnn an thereum contet, the definition of scalability gets a little more complicated. thereum is, fundamentally, a platform for "dapps", and within that mandate there are two kinds of scalability that are relevantnnllow lots and lots of people to build dapps, and keep the transaction fees lownnllow each individual dapp to be scalable according to a definition similar to that for itcoinnnhe first is inherently easier than the second. he only property that the "build lots and lots of alt-therea" approach does not have is that each individual alt-thereum has relatively weak security at a size of  alt-therea, each one would be vulnerable to a .% attack from the point of view of the whole system (that .% is for eternally-sourced attacks internally-sourced attacks, the equivalent of ash.io and iscus ish colluding, would take only .%). f we can find some way for all alt-therea to share consensus strength, eg. some version of merged mining that makes each chain receive the strength of the entire pack without requiring the eistence of miners that know about all chains simultaneously, then we would be done.nnhe second is more problematic, because it leads to the same fragility property that arises from scaling itcoin the currency if every node sees only a small part of the state, and arbitrary amounts of  can legitimately appear in any part of the state originating from any part of the state (such fungibility is part of the definition of a currency), then one can intuitively see how forgery attacks might spread through the blockchain undetected until it is too late to revert everything without substantial system-wide disruption via a global revert.nneinventing the heelnne'll start off by describing a relatively simple model that does provide both kinds of scalability, but provides the second only in a very weak and costly way essentially, we have just enough intra-dapp scalability to ensure asset fungibility, but not much more. he model works as followsnnuppose that the global thereum state (ie. all accounts, contracts and balances) is split up into  parts ("substates") (think     ). nyone can set up an account on any substate, and one can send a transaction to any substate by adding a substate number flag to it, but ordinary transactions can only send a message to an account in the same substate as the sender. owever, to ensure security and cross-transmissibility, we add some more features. irst, there is also a special "hub substate", which contains only a list of messages, of the formnndest_substate, address, value, data]nn. econd, there is an opcodenn_nn, which takes those four parameters as arguments, and sends such a one-way message enroute to the destination substate.nniners mine blocks on some substatennsj]nn, and each block onnnsj]nnis simultaneously a block in the hub chain. ach block onnnsj]nnhas as dependencies the previous block onnnsj]nnand the previous block on the hub chain. or eample, withnn  nn, the chain would look something like thisnnhe block-level state transition function, if mining on substatennsj]nn, does three thingsnnrocesses state transitions inside ofnnsj]nnf any of those state transitions creates ann_nn, adds that message to the hub chainnnf any messages are on the hub chain withnndest_substate  jnn, removes the messages from the hub chain, sends the messages to their destination addresses onnnsj]nn, and processes all resulting state transitionsnnrom a scalability perspective, this gives us a substantial improvement. ll miners only need to be aware of two out of the totalnn + nnsubstates their own substate, and the hub substate. apps that are small and self-contained will eist on one substate, and dapps that want to eist across multiple substates will need to send messages through the hub. or eample a cross-substate currency dapp would maintain a contract on all substates, and each contract would have an  that allows a user to destroy currency units inside of one substate in echange for the contract sending a message that would lead to the user being credited the same amount on another substate.nnessages going through the hub do need to be seen by every node, so these will be epensive however, in the case of ether or sub-currencies we only need the transfer mechanism to be used occasionally for settlement, doing off-chain inter-substate echange for most transfers.nnttacks, hallenges and esponsesnnow, let us take this simple scheme and analyze its security properties (for illustrative purposes, we'll use   ). irst of all, the scheme is secure against double-spend attacks up to % of the total hashpower the reason is that every sub-chain is essentially merge-mined with every other sub-chain, with each block reinforcing the security of all sub-chains simultaneously.nnowever, there are more dangerous classes of attacks as well. uppose that a hostile attacker with % hashpower jumps onto one of the substates, thereby now comprising % of the mining power on it. ow, that attacker mines blocks that are invalid - for eample, the attacker includes a state transition that creates messages sending   to every other substate out of nowhere. ther miners on the same substate will recognize the hostile miner's blocks as invalid, but this is irrelevant they are only a very small part of the total network, and only % of that substate. he miners on other substates don't know that the attacker's blocks are invalid, because they have no knowledge of the state of the "captured substate", so at first glance it seems as though they might blindly accept them.nnortunately, here the solution here is more comple, but still well within the reach of what we currently know works as soon as one of the few legitimate miners on the captured substate processes the invalid block, they will see that it's invalid, and therefore that it's invalid in some particular place. rom there, they will be able to create a light-client erkle tree proof showing that that particular part of the state transition was invalid. o eplain how this works in some detail, a light client proof consists of three thingsnnhe intermediate state root that the state transition started fromnnhe intermediate state root that the state transition ended atnnhe subset of atricia tree nodes that are accessed or modified in the process of eecuting the state transitionnnhe first two "intermediate state roots" are the roots of the thereumnnatricia state treennbefore and after eecuting the transaction the thereum protocol requires both of these to be in every block. he atricia state tree nodes provided are needed in order to the verifier to follow along the computation themselves, and see that the same result is arrived at the end. or eample, if a transaction ends up modifying the state of three accounts, the set of tree nodes that will need to be provided might look something like thisnnechnically, the proof should include the set of atricia tree nodes that are needed to access the intermediate state roots and the transaction as well, but that's a relatively minor detail. ltogether, one can think of the proof as consisting of the minimal amount of information from the blockchain needed to process that particular transaction, plus some etra nodes to prove that those bits of the blockchain are actually in the current state. nce the whistleblower creates this proof, they will then be broadcasted to the network, and all other miners will see the proof and discard the defective block.nnhe hardest class of attack of all, however, is what is called a "data unavailability attack". ere, imagine that the miner sends out only the block header to the network, as well as the list of messages to add to the hub, but does not provide any of the transactions, intermediate state roots or anything else. ow, we have a problem. heoretically, it is entirely possible that the block is completely legitimate the blocknncouldnnhave been properly constructed by gathering some transactions from a few millionaires who happened to be really generous. n reality, of course, this is not the case, and the block is a fraud, but the fact that the data is not available at all makes it impossible to construct an affirmative proof of the fraud. he % honest miners on the captured substate may yell and squeal, but they have no proof at all, and any protocol that did heed their words would necessarily fall to a .% denial-of-service attack where the miner captures % of a substate and pretends that the other % of miners on that substate are conspiring against him.nno solve this problem, we need something called annchallenge-response protocolnn. ssentially, the mechanism works as followsnnonest miners on the captured substate see the header-only block.nnn honest miner sends out a "challenge" in the form of an inde (ie. a number).nnf the producer of the block can submit a "response" to the challenge, consisting of a light-client proof that the transaction eecution at the given inde was eecuted legitimately (or a proof that the given inde is greater than the number of transactions in the block), then the challenge is deemed answered.nnf a challenge goes unanswered for a few seconds, miners on other substates consider the block suspicious and refuse to mine on it (the game-theoretic justification for why is the same as always because they suspect that others will use the same strategy, and there is no point mining on a substate that will soon be orphaned)nnote that the mechanism requires a few added compleities on order to work. f a block is published alongside all of its transactions ecept for a few, then the challenge-response protocol could quickly go through them all and discard the block. owever, if a block was published truly headers-only, then if the block contained hundreds of transactions, hundreds of challenges would be required. ne heuristic approach to solving the problem is that miners receiving a block should privately pick some random nonces, send out a few challenges for those nonces to some known miners on the potentially captured substate, and if responses to all challenges do not come back immediately treat the block as suspect. ote that the miner does  broadcast the challenge publicly - that would give an opportunity for an attacker to quickly fill in the missing data.nnhe second problem is that the protocol is vulnerable to a denial-of-service attack consisting of attackers publishing very very many challenges to legitimate blocks. o solve this, making a challenge should have some cost - however, if this cost is too high then the act of making a challenge will require a very high "altruism delta", perhaps so high that an attack will eventually come and no one will challenge it. lthough some may be inclined to solve this with a market-based approach that places responsibility for making the challenge on whatever parties end up robbed by the invalid state transition, it is worth noting that it's possible to come up with a state transition that generates new funds out of nowhere, stealing from everyone very slightly via inflation, and also compensates wealthy coin holders, creating a theft where there is no concentrated incentive to challenge it.nnor a currency, one "easy solution" is capping the value of a transaction, making the entire problem have only very limited consequence. or a uring-complete protocol the solution is more comple the best approaches likely involve both making challenges epensive and adding a mining reward to them. here will be a specialized group of "challenge miners", and the theory is that they will be indifferent as to which challenges to make, so even the tiniest altruism delta, enforced by software defaults, will drive them to make correct challenges. ne may even try to measure how long challenges take to get responded, and more highly reward the ones that take longer.nnhe welve-imensional ypercubennote this is  the same as the erasure-coding org cube. or more info on that, see herennhttps//blog.ethereum.org////secret-sharing-erasure-coding-guide-aspiring-dropbo-decentralizer/nne can see two flaws in the above scheme. irst, the justification that the challenge-response protocol will work is rather iffy at best, and has poor degenerate-case behavior a substate takeover attack combined with a denial of service attack preventing challenges could potentially force an invalid block into a chain, requiring an eventual day-long revert of the entire chain when (if) the smoke clears. here is also a fragility component here an invalid block in any substate will invalidate all subsequent blocks in all substates. econd, cross-substate messages must still be seen by all nodes. e start off by solving the second problem, then proceed to show a possible defense to make the first problem slightly less bad, and then finally get around to solving it completely, and at the same time getting rid of proof of work.nnhe second flaw, the epensiveness of cross-substate messages, we solve by converting the blockchain model from thisnno thisnncept the cube should have twelve dimensions instead of three. ow, the protocol looks as followsnnhere eist nnnnsubstates, each of which is identified by a binary string of length  (eg.nnnn). e define the amming distancenn(, )nnas the number of digits that are different between the s of substatesnnnnandnnnn(eg.nn(, )  nn,nn(, )  nn, etc).nnhe state of each substate stores the ordinary state tree as before, but also an outbo.nnhere eists an opcode,nn_nn, which takes  argumentsnndest_substate, to_address, value, data]nn, and registers a message with those arguments in the outbo ofnn_fromnnwherenn_fromnnis the substate from which the opcode was callednnll miners must "mine an edge" that is, valid blocks are blocks which modify two adjacent substatesnn_annandnn_bnn, and can include transactions for either substate. he block-level state transition function is as followsnnrocess all transactions in order, applying the state transitions tonn_annornn_bnnas needed.nnrocess all messages in the outboes ofnn_annandnn_bnnin order. f the message is in the outbo ofnn_annand has final destinationnn_bnn, process the state transitions, and likewise for messages fromnn_bnntonn_ann. therwise, if a message is innn_annandnn(_b, msg.dest)  (_a, msg.dest)nn, move the message from the outbo ofnn_annto the outbo ofnn_bnn, and likewise vice versa.nnhere eists a header chain keeping track of all headers, allowing all of these blocks to be merge-mined, and keeping one centralized location where the roots of each state are stored.nnssentially, instead of travelling through the hub, messages make their way around the substates along edges, and the constantly reducing amming distance ensures that each message always eventually gets to its destination.nnhe key design decision here is the arrangement of all substates into a hypercube. hy was the cube chosen he best way to think of the cube is as a compromise between two etreme options on the one hand the circle, and on the other hand the simple (basically, nnnn-dimensional version of a tetrahedron). n a circle, a message would need to travel on average a quarter of the way across the circle before it gets to its destination, meaning that we make no efficiency gains over the plain old hub-and-spoke model.nnn a simple, every pair of substates has an edge, so a cross-substate message would get across as soon as a block between those two substates is produced. owever, with miners picking random edges it would take a long time for a block on the right edge to appear, and more importantly users watching a particular substate would need to be at least light clients on every other substate in order to validate blocks that are relevant to them. he hypercube is a perfect balance - each substate has a logarithmically growing number of neighbors, the length of the longest path grows logarithmically, and block time of any particular edge grows logarithmically.nnote that this algorithm has essentially the same flaws as the hub-and-spoke approach - namely, that it has bad degenerate-case behavior and the economics of challenge-response protocols are very unclear. o add stability, one approach is to modify the header chain somewhat.nnight now, the header chain is very strict in its validity requirements - if any block anywhere down the header chain turns out to be invalid, all blocks in all substates on top of that are invalid and must be redone. o mitigate this, we can require the header chain to simply keep track of headers, so it can contain both invalid headers and even multiple forks of the same substate chain. o add a merge-mining protocol, we implementnneponential subjective scoringnnbut using the header chain as an absolute common timekeeper. e use a low base (eg. . instead of .) and have a maimum penalty factor of  / nnnnto remove the benefit from forking the header chain for those not well versed in the mechanics of , this basically means "allow the header chain to contain all headers, but use the ordering of the header chain to penalize blocks that come later without making this penalty too strict". hen, we add a delay on cross-substate messages, so a message in an outbo only becomes "eligible" if the originating block is at least a few dozen blocks deep.nnroof of takennow, let us work on porting the protocol to nearly-pure proof of stake. e'll ignore nothing-at-stake issues for now lasher-like protocols plus eponential subjective scoring can solve those concerns, and we will discuss adding them in later. nitially, our objective is to show how to make the hypercube work without mining, and at the same time partially solve the fragility problem. e will start off with annproof of activitynnimplementation for multichain. he protocol works as followsnnhere eist nnnnsubstates indentified by binary string, as before, as well as a header chain (which also keeps track of the latest state root of each substate).nnnyone can mine an edge, as before, but with a lower difficulty. owever, when a block is mined, it must be published alongside the complete set of erkle tree proofs so that a node with no prior information can fully validate all state transitions in the block.nnhere eists a bonding protocol where an address can specify itself as a potential signer by submitting a bond of sizennnn(richer addresses will need to create multiple sub-accounts). otential signers are stored in a specialized contractnns]nnon each substatennsnn.nnased on the block hash, a random  substatesnnsi]nnare chosen, and a search indenn  indi]  ^nnis chosen for each substate. efinennsigneri]nnas the owner of the first address innnsi]]nnafter indennindi]nn. or the block to be valid, it must be signed by at least  of the setnnsigner] ... signer]nn.nno actually check the validity of a block, the consensus group members would do two things. irst, they would check that the initial state roots provided in the block match the corresponding state roots in the header chain. econd, they would process the transactions, and make sure that the final state roots match the final state roots provided in the header chain and that all trie nodes needed to calculate the update are available somewhere in the network. f both checks pass, they sign the block, and if the block is signed by sufficiently many consensus group members it gets added to the header chain, and the state roots for the two affected blocks in the header chain are updated.nnnd that's all there is to it. he key property here is that every block has a randomly chosen consensus group, and that group is chosennnfrom the global state of all account holdersnn. ence, unless an attacker has at least % of the stake in the entire system, it will be virtually impossible (specifically, nn-nnprobability, which with nnnnproof of work falls well into the realm of cryptographic impossiblity) for the attacker to get a block signed. nd without % of the stake, an attacker will not be able to prevent legitimate miners from creating blocks and getting them signed.nnhis approach has the benefit that it has nice degenerate-case behavior if a denial-of-service attack happens, then chances are that almost no blocks will be produced, or at least blocks will be produced very slowly, but no damage will be done.nnow, the challenge is, how do we further reduce proof of work dependence, and add in blockmaker and lasher-based protocols  simple approach is to have a separate blockmaker protocol for every edge, just as in the single-chain approach. o incentivize blockmakers to act honestly and not double-sign, lasher can also be used here if a signer signs a block that ends up not being in the main chain, they get punished. chelling point effects ensure that everyone has the incentive to follow the protocol, as they guess that everyone else will (with the additional minor pseudo-incentive ofnnsoftware defaultsnnto make the equilibrium stronger).nn full nnhese protocols allow us to send one-way messages from one substate to another. owever, one way messages are limited in functionality (or rather, they have as much functionality as we want them to have because everything is uring-complete, but they are not always the nicest to work with). hat if we can make the hypercube simulate a full cross-substate , so you can even call functions that are on other substatesnns it turns out, you can. he key is to add to messages a data structure called anncontinuationnn. or eample, suppose that we are in the middle of a computation where a contract calls a contract which creates a contract, and we are currently eecuting the code that is creating the inner contract. hus, the place we are in the computation looks something like thisnnow, what is the current "state" of this computation hat is, what is the set of all the data that we need to be able to pause the computation, and then using the data resume it later on n a single instance of the , that's just the program counter (ie. where we are in the code), the memory and the stack. n a situation with contracts calling each other, we need that data for the entire "computational tree", including where we are in the current scope, the parent scope, the parent of that, and so forth back to the original transactionnnhis is called a "continuation". o resume an eecution from this continuation, we simply resume each computation and run it to completion in reverse order (ie. finish the innermost first, then put its output into the appropriate space in its parent, then finish the parent, and so forth). ow, to make a fully scalable , we simply replace the concept of a one-way message with a continuation, and there we go.nnf course, the question is, do we even want to go this far irst of all, going between substates, such a virtual machine would be incredibly inefficient if a transaction eecution needs to access a total of ten contracts, and each contract is in some random substate, then the process of running through that entire eecution will take an average of si blocks per transmission, times two transmissions per sub-call, times ten sub-calls - a total of  blocks. dditionally, we lose synchronicity if  calls  once and then again, but between the two calls  calls , then  will have found  in a partially processed state, potentially opening up security holes. inally, it's difficult to combine this mechanism with the concept of reverting transaction eecution if transactions run out of gas. hus, it may be easier to not bother with continuations, and rather opt for simple one-way messages because the language is uring-complete continuations can always be built on top.nns a result of the inefficiency and instability of cross-chain messages no matter how they are done, most dapps will want to live entirely inside of a single sub-state, and dapps or contracts that frequently talk to each other will want to live in the same sub-state as well. o prevent absolutelynneveryonennfrom living on the same sub-state, we can have the gas limits for each substate "spill over" into each other and try to remain similar across substates then, market forces will naturally ensure that popular substates become more epensive, encouraging marginally indifferent users and dapps to populate fresh new lands.nnot o astnno, what problems remain irst, there is the data availability problem what happens when all of the full nodes on a given sub-state disappear f such a situation happens, the sub-state data disappears forever, and the blockchain will essentially need to be forked from the last block where all of the sub-state data actually is known. his will lead to double-spends, some broken dapps from duplicate messages, etc. ence, we need to essentially be sure that such a thing will never happen. his is a -of- trust model as long as one honest node stores the data we are fine. ingle-chain architectures also have this trust model, but the concern increases when the number of nodes epected to store each piece of data decreases - as it does here by a factor of . he concern is mitigated by the eistence of altruistic nodes including blockchain eplorers, but even that will become an issue if the network scales up so much that no single data center will be able to store the entire state.nnecond, there is a fragility problem if any block anywhere in the system is mis-processed, then that could lead to ripple effects throughout the entire system.  cross-substate message might not be sent, or might be re-sent coins might be double-spent, and so forth. f course, once a problem is detected it would inevitably be detected, and it could be solved by reverting the whole chain from that point, but it's entirely unclear how often such situations will arise. ne fragility solution is to have a separate version of ether in each substate, allowing ethers in different substates to float against each other, and then add message redundancy features to high-level languages, accepting that messages are going to be probabilistic this would allow the number of nodes verifying each header to shrink to something like , allowing even more scalability, though much of that would be absorbed by an increased number of cross-substate messages doing error-correction.nn third issue is that the scalability is limited every transaction needs to be in a substate, and every substate needs to be in a header that every node keeps track of, so if the maimum processing power of a node is  transactions, then the network can process up to nnnntransactions. n approach to add further scalability is to make the hypercube structure hierarchical in some fashion - imagine the block headers in the header chain as being transactions, and imagine the header chain itself being upgraded from a single-chain model to the eact same hypercube model as described here - that would give nnnnscalability, and applying it recursively would give something very much likenntree chainsnn, with eponential scalability - at the cost of increased compleity, and making transactions that go all the way across the state space much more inefficient.nninally, fiing the number of substates at  is suboptimal ideally, the number would grow over time as the state grew. ne option is to keep track of the number of transactions per substate, and once the number of transactions per substate eceeds the number of substates we can simply add a dimension to the cube (ie. double the number of substates). ore advanced approaches involve usingnnminimal cut algorithmsnnsuch as the relatively simplennarger's algorithmnnto try to split each substate in half when a dimension is added. owever, such approaches are problematic, both because they are comple and because they involve unepectedly massively increasing the cost and latency of dapps that end up accidentally getting cut across the middle.nnlternative pproachesnnf course, hypercubing the blockchain is not the only approach to making the blockchain scale. ne very promising alternative is to have an ecosystem of multiple blockchains, some application-specific and some thereum-like generalized scripting environments, and have them "talk to" each other in some fashion - in practice, this generally means having all (or at least some) of the blockchains maintain "light clients" of each other inside of their own states. he challenge there is figuring out how to have all of these chains share consensus, particularly in a proof-of-stake contet. deally, all of the chains involved in such a system would reinforce each other, but how would one do that when one can't determine how valuable each coin is f an attacker has % of all -coins, % of all -coins and % of all -coins, how does -coin know whether it's -coin or -coin that should have the greater weightnnne approach is to use what is essentially ipple consensus between chains - have each chain decide, either initially on launch or over time via stakeholder consensus, how much it values the consensus input of each other chain, and then allow transitivity effects to ensure that each chain protects every other chain over time. uch a system works very well, as it's open to innovation - anyone can create new chains at any point with arbitrarily rules, and all the chains can still fit together to reinforce each other quite likely, in the future we may see such an inter-chain mechanism eisting between most chains, and some large chains, perhaps including older ones like itcoin and architectures like a hypercube-based thereum ., resting on their own simply for historical reasons. he idea here is for a truly decentralized design everyone reinforces each other, rather than simply hugging the strongest chain and hoping that that does not fall prey to a black swan attack.