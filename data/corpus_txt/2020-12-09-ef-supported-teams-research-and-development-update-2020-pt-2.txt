Titre: EF-Supported Teams: Research & Development Update\nAuteur: Ethereum Foundation Team\nDate: Team on December 9, 2020\nURL: https://blog.ethereum.org/2020/12/09/ef-supported-teams-research-and-development-update-2020-pt-2\nCatégorie: Non catégorisé\n\n==================================================\n\nriends,nneaves have fallen for those in the global north, ummer is on the way in the south, and  is staked across the globe. he jolliest of holidays has arrived, the birth of the beacon chain. oreover, incredible progress has been made in recent months bynnallnn supported teams. ut without the ability to interact in person recently, we might’ve missed quite a bit from one another. o as this unique year draws to a close, we’re ecited to bring a whole host of detailed updates to you from some of the teams that help to move thereum forward in so many ways. t's a long read, but there is a lot of progress to work through (or feel free to navigate around using the table of contents).nns always, this series of updates focuses on -supported teams whose members are working to grow and improve thereum as a whole. ncluded in this edition are updates from many teams highlighted innnthe previous reportnn, and other new and rotating groups.nnnjoy!nnpplied nnuthored by hore ildebrandtnnhe pplied  team works to bridge the gap between cutting-edge research in zero-knowledge proofs, and application development on thereum.nnerpetual owers of aunnn eptember , we launched thennerpetual owers of aunnceremony ().  aims to benefit the zero-knowledge ecosystem, particularly zk- projects built on thereum, by partially easing the burden of trusted setup ceremonies. any zk- projects require two phases of parameter generation, and  replaces the first phase, which can be shared by all circuits. ndividual teams can choose any contribution from the ceremony to branch out and perform their own phase  setup.nnhis ceremony supports circuits up to  ^  constraints, which means that each contribution requires a  download, a -day computation, and a  upload. t the time of writing, we collected  contributions and all contribution files can be downloaded and independently verified against a public ceremonynntranscriptnn.nnrojects that are planning to use or have used the ceremony includenntornado.cashnn,nnemaphorenn,nnermeznn,nnnnandnnzkoprunn. he easiest way to contribute is to reach out to ei ie via elegram weijiek. isten tonnthis podcastnnto hear ei ie speak about the ceremony.nnemaphorennemaphorennis a generic privacy gadget which enables use cases such as miers, anonymous login, and anonymous voting as well as reputation systems.nnemaphore went through an audit and is currently conducting a phase  ceremony based on erpetual owers of au. here are  participants so far, pleasennparticipatennto help make emaphore secure. oin the conversation on the emaphore ocietynnelegram chat groupnn.nnnnriginally proposed by italik uterin, systems built withnnnnmake collusion among participants difficult, while retaining the censorship resistance and correct-eecution benefits of smart contracts. lthough  can provide collusion resistance only if the coordinator is honest, a dishonest coordinator can neither censor nor tamper with its eecution. ee ei ie eplaining how  worksnnon outubenn. ou can use the nncommand-line interfacennto run a demo.nnecently, clr.fundnnconductednna quadratic funding round in which results were computed using . ribery could become a major problem for itcoin when it reaches scale but  can help as it makes it impossible to prove who one voted for.  . isnnin progressnn, join thennelegram groupnnto learn more and discuss.nni ountynnhere is an ongoingnnbountynnfor collision finding in the i hash function.nnubblennptimistic ollups () allows greater layer  scalability with the use of on-chain data availability and fraud proofs. ubble allows for the creation of optimistic rollup chains with the same interface so that people can enter the rollup space once and then move between chains instantly at negligible costs and remove the need to ever "eit" the low cost rollup world.nney features include mass migrations and a global account registry. urn auctions will be used to decentralise the coordinator and to distribute  to ’s. ransfers to new accounts are possible directly from  without having to deposit on . ith the help of  signatures the team was able to achievenn tps on ropstennn. he hubble  wallet aims to support other ’s such as rbitrum, ptimism and uel.nnubble's code is available onnnithubnn. ontracts are frozen and the team is preparing for an upcoming audit.nnzkoprunnzkopru (zk-optimistic-rollup) is a layer- scaling solution for private transactions using zk- and optimistic rollup. t supports private transfer and private atomic swap within the layer- network between , ,  at a low cost. t also provides instant withdrawal with pay-in-advance features and compliance compatibility using spending key and viewing keys. anseob presented the system at zk-summit, the recording will be available on outube soon.
zkopru is entering the “urrito” stage of itsnnroadmapnn, you can try it out onnntestnetnnnow. lso, the  for its trusted setup and burn auction for the decentralized coordination are in pipe. n audit is scheduled to start in anuary.nnperimental directionsnnlind indnn- a pp network allowing users to search for others without revealing their identity. fter a successful search, the user can prove the search path eists in the network with a -based construction, without revealing the path itself. o learn more and discuss, please join thenntelegram groupnn.nnniepnn- a private and non repudiable reputation system. sers can receive positive and negative reputation from attesters, and voluntarily prove that they have at least a certain amount of reputation without revealing the eact amount. oreover, users cannot refuse to receive reputation from an attester. oin thenntelegram channelnnto learn more and discuss!nneekooknn- a private order matching system on thereum. t allows users to advertise and search for trading orders without leaking the order price. heck out thenndemonn. oin thenntelegram groupnnfor discussion.nncosystem upport rogramnnuthored by  eamnnelivering supportnnhe  team is always eploring new ways to help and encourage the many amazing builders in the thereum ecosystem. e highlighted a few teams that received support other than traditional grants innnthis postnn.nneanwhile, almost $. million in grants were awarded in - learn more about the + recipients in ournnnnandnnnnallocation updates, and keep an eye out for a  post in the new year!nnutreach and communicationnne’ve made an effort to provide more resources for teams looking for support, as well as thereum community members who want to keep up with what we’re supporting.nnvents we’ve been making the (virtual) rounds at meetups and hackathons to connect in real time with builders, spread the word about  and help answer any questions or concerns.nnuide to nn this new page of our website goes into detail about  inquiry and grant proposal processnnore blogging e’ve posted regular updates on newly awarded grants throughout the year, but what these teams do with their grant funding is the real story! n ovember, we published thennfirst postnnin a new blog series meant to recognize grantees’ ongoing accomplishments.nnth esearchnnuthored by anny yannnecember st marked the launch of the eth beacon chain. his bootstrapped thereum’s proof of stake consensus that will ultimately serve as thereum’s new consensus home.nnooking past the launch of the beacon chain, the eth research team is concentrating on the net set of upgrades to eth -- native light client support, the merge of eth into eth, and scalable sharded data.nnor the latest from our team, keep posted to the ‘eth quick updates’ on the  blog.  few recent editions can be seen herenn#nn,nn#nn,nn#nn.nnethereum.orgnnuthored by yan ordellnnhennethereum.orgnnteam has spent the last half of  adding yet more content and features to our ever-growing portal of thereum goodness.nnnboardingnns we're quite often the first place users find when searching "thereum" for the first time, we've spent a lot of time enriching the content that helps you get started.nnet a quick eplainer onnnthereumnn,nnethernn, andnnwalletsnnind out where you can get , based on where you livennind your first wallet based on the features you wantnnperience thereum by eploring the world of dappsnnthnnnd in the build up to the launch of the deposit contract, th has filled the headlines and our backlog. t's clearly been front of mind for our users, as in the last month, visits to our th pages have surpassed even the homepage.nnheck you're sending your stake to the right addressnnet an overview of thnnplore the different th upgradesnnearn about staking and how to stakenniscover ways to get involvednnr simply understandnnhy thnnevelopersnninally our other main initiative in the latter part of  was improving our developer content,.to help users get started with information from a single, trusted source. t's still a work-in-progress, but so far we've built ]nn community-led documentation platformnn way for developer educators to reach a larger audience with theirnnthereum tutorialsnnntros tonnsetting up a local development environmentnnandnndifferent ways to learn thereumnnnd after some user testing we've got plenty of ideas on how to improve these as we head into the new year.nnranslationsnnt was also a massive year for epanding our reach into other languages. n the last half of  our community of translators has updated content innnzech (nnhttps//ethereum.org/cs/nn)nnithuanian (nnhttps//ethereum.org/lt/nn)nnpanish (nnhttps//ethereum.org/es/nn)nnorean (nnhttps//ethereum.org/ko/nn)nnortuguese razilian (nnhttps//ethereum.org/pt-br/nn)nnapanese (nnhttps//ethereum.org/ja/nn)nnietnamese (nnhttps//ethereum.org/vi/nn)nnou can find all  of the languages we now support atnnethereum.org/en/languagesnnand learn how tonnget involved with translation effortsnn.nne can't go into everything, so take a look atnnethereum.orgnnandnnour previous updatesnnto see the other bits we've worked on since you last visited.nns always if you want to contribute in any way, stop bynnour iscordnnor raise an issue/ innnitubnn.nnwasmnnritten by le eregszaszi, aweł ylica, and ina ahmoodinns proposed in thennlast updatenn, we have continued to work on th, th., and th. related topics.nnthnnnnne key motivator for our work on assessing performance bottlenecks of various virtual machine designs (nn and ebssemblynn) and their various implementations is to improve the speed of eecution within thereum. s reported in annprevious updatennwe had success scaling ebssembly for eecuting the elliptic curve pairing operation efficiently.nnn the past si months we have embarked on the  project with the goal to reproduce the same scaling on . hile it started out asnna small proof of conceptnn, we have released anncomprehensive eplanationnnand several updates (nnnn,nnnn, andnnnn) along the way. n these updates we presentnnan overview of the precompile problem,nnthree new  opcodes facilitating efficient -bit calculations,nnmultiple design choices for ,nna comparison of the languages ul and uff,nnand an implementation of the pairing operation over the - curve using the proposed opcodes.nnpdates about  can be followed on thennappropriate thagicians topicnn.nn subroutinesnnhe teamnnperformed analysis and proposed significant changesnntonn- “imple ubroutines for the ”nn. he resulting discussions highlighted potential risks and opportunities, and led us to conduct research onnnnnanalysis techniques. he outcome of this is thennbaseline interpreternnas discussed net.nnevmonennased onnnour benchmarksnn,nnevmonennis a really fast  interpreter. ne of the strengths of evmone is the etensive bytecode analysis it performs, allowing fornnpre-computation of gas cost and stack requirement checksnn. owever, this can also be a downside or vulnerability.nn new variant of evmone called thenn"baseline interpreter"nnhas been prototyped in the project. he goal is to evaluate a much simpler interpreter design in order to avoid analysis vulnerabilities and perhaps question the speed benefits of analysis. hile this implementation is not yet battle tested, it does pass all of evmone's unit tests, the thereum tate ests, and olidity's test suite.nnnepectedly, this naïve design performs surprisingly well. n "average" contracts the speed difference between the baseline vs. the "advanced" evmone is negligible, however on computation-heavy  bytecode the "advanced" evmone would perform up to % faster.nnhe urboeth team has bootstrapped thennilkwormnnproject which uses evmone as the  implementation. hey also proposed a number of interesting changes tonnevmonennandnnnn.nnnnhree new versions ofnnnnwere releasednn..nn,nn..nnandnn..nn. he releases brought various improvements for the ++, o, and ava language support, as well as for tooling.nnhe ava support has received a lot of attention recently as part of its integration intonnpache uweninn. ee the list ofnnrelated changes and discussionsnn.nn support was adopted by a number of projects lately, includingnnurboethnn,nnilkwormnn, andnnecond tate's nn.nnth. / tateless thereumnnnder the tateless thereum umbrella we have been involved with multiple efforts.nnode merkleizationnnfter the initial feasibility eperiments on code merkleization, which was mentioned in the last update, we proposednn-nnand implemented the specification innngethnnand annstandalone toolnnin ython. here have been further eperiments, such as using  for merkleization and performance overhead analysis, which can be seen in the discussionnnthreadnn.nnitness formatnnhe team, with aul's lead, has participated innnspecifyingnnand optimizing the witness format. he format has been implemented innnythonnnas well asnnavascriptnn. he ython implementation has been additionally used for generating tests for the format.nninarificationnne have furthermore closely followed the binarification effort and contributed to the designnndiscussionnn. ur goal is to ensure the design works well with other components of a stateless thereum. ith this in mind we have aimed to keep the code merkleization proposal aligned with the binarification effort.nneenesisnne had previously argued for a state cache to reduce (stateless) witness sizes in th. hase . ence we findnneenesisnnto be a promising direction. o help with the discussion, aul published an early work-in-progress version of annformal specificationnnfor a potential variant of eenesis. he specification follows the notation introduced by the ellow aper.nnight-client syncnnight clients are bottlenecked by the amount of data they "pull" from altruistic servers. e believe techniques first developed for tateless thereum combined with a commitment to chain history can reduce pressure on the servers. s a first step towards this goal we havennsurveyednnapproaches that reduce bandwidth requirements for syncing the header chain. ommitment to the chain history might further prove useful in contets (such as eenesis) outside of light client sync.nnth.nneposit contractnnur team led thennolidity rewritennof the deposit contract, which underwent successfulnnaudit and verificationnn, and wasnnadopted as a part of the th. specificationnn.nnhennverification reportnnmentions a benefit of the rewritennespite the additional runtime checks, the olidity implementation is more gas-efficient (~% less gas cost) than the original yper implementation, thanks to the advanced code optimization of the olidity compiler.nnthnnn thennprevious updatennwe described our work on th hase  and introduced th as a concept.nnhe first variant of th, namednnpostillenn, specifies a minimally-invasive etension to th and . his etension allows contracts on the th chain to communicate with other eecution shards on th.nnhe eperiment describes a situation where all  shards of th are homogenous and running the , and allows these shards to communicate with each other. urthermore the techniques presented can be (re)used in the contet of the th-th merge.nnizzynnizzy aims to be a fast, deterministic, and pedantic ebssembly interpreter written in ++.nnhe four main goals ofnnizzynnarennhigh code quality and simplicitynnstrict specification conformancennefficiencynnfirst class support for deterministic applicationsnnollowing prilnnsignificant progress has been made and three out of the four major goals have been already met.nnompared to other interpreters, we have deliberately restricted the scope to ebssembly ., avoided implementing any pending proposals, and resisted the urge to create an all-encompassing library. izzy only supports the canonical binary representation (nn.wasmnn) of ebssembly and does not support the tet formats (nn.watnn/nn.wastnn). his allowed us to keep the code simple and straightforward.nnhe pedantic adherence to the specification, combined with ehaustive use of static analyzers and fuzz-testing, allowed us to find missing test coverage innnthe specificationnn, and upstream issues innnwabtnnandnnwasmnn.nnhile eecution speed was not the first goal, we have been conscious about design decisions affecting it. his allowed izzy to become the second fastest interpreter on the market, beating our previous favoritennwabtnn.nnizzy in numbersnn major releasesnn~ lines of well commented modern ++ codennadditional ~ lines of unit testsnn.%nncode coveragenn% "spectest" pass rate (the official ebssembly test suite)nnsecond fastest ebssembly interpreternne are preparing the .. release which will introduce a public  and ust , and provide support fornnnn, which allows eecuting a wide range of applications.nnfter that our attention will be focused on blockchain specific behaviour (efficient metering) and continued upstream contributions for specification conformance.nnormal erificationnnuthored by eo lt, artin undfall, avid errynnctnnct . is close to being released. t is converging as a language, and a lot of work went into tooling for ct in the past months, as plannednn backendnn. nductive high level properties such as contract invariants and post conditions written in ct can be proven automatically using the ct  backend. he properties are encoded as inductive theorems using the required  theories, and given to an  solver. his feature allows users to prove properties in a simple, easy and standalone way, separated from the bytecode. he  backend assumes that the contract’s bytecode is correctly represented by the storage updates in the specification. n order to prove that, you can use thennevm backend. evm now hasnnsymbolic eecution featuresnn, which are now fully integrated into ct. iven an ct specification and the compiled bytecode, it will automatically check whether the storage updates described in the specification match what the bytecode actually does.nnoq backend. imilarly to the  backend, this feature is useful to prove inductive high level properties in a standalone way.  solvers are automatic and fast, but can’t solve everything. ome problems require more epressiveness, and those are the target of the oq backend. t generates oq definitions and theorems so the user can use the oq proof assistant to prove the high level properties.nnevmnnevm's symbolic eecution features werenneplained in detail earlier in the yearnn, and here’s a summary of the features added since the last updatennymbolic eecution. s eplained in thennprevious blog postnn,nnhevmnnis now capable of eploring the possible eecution paths of a smart contract, keeping one or more variables abstract. he resulting post states can be checked for assertion violations, or against a given specification. tate can be fetched from an rpc node, or kept fully abstract. he tree of eecution traces can be eplored interactively in a debugger view.nnquivalence checking.nnhevm equivalencennsymbolically eecutes two smart contracts and compares all resulting end states. his is particularly useful for proving safety of compiler optimizations, or comparing different implementations of contracts implementing the same semantics.nnecompilation of smart contracts. he first initial steps towards a symbolic decompiler have been taken. unningnnhevm symbolicnnwith the flagnn--show-treennprints a summary of the reachable end states, their path conditions and the state updates performed. his feature is still in its early stages, but the plan is that this will generate a set ofnnactnnspecifications from  bytecode, which could then be used to further reason about the smart contract’s behaviour.nnest integration.nnhevmnn’s symbolic eecution capabilities have been integrated with thenndappnntesting frameworknn. his means that you can now write properties and formally verify them in olidity in the same way you write tests! here is a lot more to be said here and we are working on a longer blog post which goes into detail.nnheckernnany important features have been added to the hecker since the last update, includingnnuch more language support. he hecker is by now almost able to analyze any synta modulo ) some language features we don’t see being used that much, such as function pointers and complicated memory/storage aliasing and ) things that are too hard to have a reasonably efficient representation in the  universe, like  encoding/decoding and hash functions.nnternal calls to unknown code. his is a big one! he hecker’snnonstrained orn lausesnn() engine abstracts eternal calls to non-trusted contracts as an unbounded number of nondeterministic calls to the analyzed contract. sing this abstraction the  engine can compute precisely what state changes can or cannot happen via this eternal call, allowing it to keep inductive invariants that were inferred previously and/or compute new ones. his enables the tool to automatically prove and learn invariants about more comple properties, that involve eternal calls and potential reentrancy. his also reduces greatly the number of false positives caused by eternal calls.nnulti-transaction countereamples. nother big one! he  engine now reports the full transaction trace from the contract’s constructor to the function that causes the verification condition to be triggered. t also includes concrete values for the function’s arguments and state variables, if applicable, for value types and arrays. ome upcoming features are reporting concrete values for structs and reporting reentrant calls in the transaction trace.nnetter control and usability. he user can now choose separately which engine should run,nn (ounded odel hecker)nn,  or both. esides, a timeout in milliseconds can also be given and is applied to each query. his makes fully deterministic reruns hard, but is useful when trying to prove comple properties that might need more time.nnethnnuthored by éter zilágyinnhe eth team's primary focus in the past months was around laying the groundwork for a number of features we're gradually rolling out in the net few weeks and also towards th-th interoperabilitynnne feature we've run ourselves for the better part of the year but have been holding back on rolling out to everyone is thennsnapshotternn, which allows storing the thereum state in a flat format in the database. lthough the core functionality worked well, we've spent a significant amount of time working on various recovery features so crashes and de-syncs with the state trie can be gracefully handled. ou can already run your node with --snapshot, but as it is consensus critical, we'll only be enabling it by default on our net major release, slated for early anuary.nnhe primary purpose of the snapshotter was to enable snap sync, a successor to fast- and warp sync, having the advantages of both, whilst working around the disadvantages of both. he protocol was fully specced and published in the last few months in thenndevpp reponn, and it has a full production implementation pending merge on thenneth reponn. s a teaser, the stats from ournnlast benchmarknn network packets reduced by (!) orders of magnitude, serving disk  and upload by  orders of magnitude.  faster sync,  less download.nnne of the chilles' heels of eth since its inception was that once some data hit the database, we never deleted it. ong term, our disk usage kept growing and bloating with stale states belonging to ancient blocks. he fast iteration capability of the snapshotter provides us with a unique new opportunity to implement a very simplennstate prunernn. e will not be enabling it as a background process within eth any time soon, but you'll be able to prune your database offline vianngeth snapshot prune-statenn, which should finish in a few hours.nnn a more research-y front, we've been investigating the practicality of replacing the current heary state trie with annbinary onenn, the purpose of which would be to significantly reduce witness sizes (stateless direction) and light client proofs. n addition, binary tries could also help reduce some of the code compleity for new clients that would be willing to join the thereum network only from a future block and not care about chain history based on the heary tries. anding this work is still far out as this is as much of an open-heart-surgery of thereum as we can do.nnince the th beacon chain now live, we've beennnworkingnnon a possiblennintegrationnnof the current thereum chain into a shard of the beacon chain which would implicitly also enable running arbitrary  shards on th. here are still a number of pieces missing to make it production ready (mostly around needing a new sync model, though no new protocol), but a prototype eth  shard on top of th was alreadynndemonstratednn.nne've come to the realization that - at this point in time - most clients do not focus on network protocol improvements, even though eth defined ( approved) and shipped quite a few lately. his is a problem as it prevents us from dropping old protocol versions, which makes our code brittle. mplementing these changes is not hard, but validating them is, which is our best guess as to why other clients aren't keen on doing it. o try to offset some of the burden, we began working on a protocol tester to allow validating an arbitrary client's implementations of the discovery protocol, devpp and higher level overlays (nnethnn,nnsnapnn, etc).nnn a similar vein to the above protocol tester, a lot of effort went into bringingnnhivennup to speed with new clients and new test suites. ur hopes are that other clients will also start contributing some tests to cross validate each others' code and that soon th clients would also join a combined effort to keep the network stable.nneth implemented and ran  testnets for the upcoming erlin hard fork ( v and v), with the rd one currently being prepped once all the proposed s are more or less finalized. his also implicitly means that we've spent a lot of time implementing and shipping the various s that will make up the erlin hard fork. rogress on this front is a big jaggedy as the  process is not the leanest and the proposals evolve quite a bit, but we're hopeful that all the details will get nailed down soon enough to launch v and then erlin.nnor a list of security improvements in eth - in order not to duplicate the same things multiple times - please check thennecuritynnsection a bit further down authored by artin olst wende.nnavacript eamnnuthored by olger rewesnnhe avacript team just recently had its big thereum  v release which consists of si major version releasesnnethereumjs/commonnnv..nnethereumjs/tnnv..nnethereumjs/blocknnv..nnethereumjs/ethashnnv..nnethereumjs/blockchainnnv..nnethereumjs/vmnnv..nn v is the first full-featured avacript  available with backports for all hardforks down to genesis. t also comes with dedicated support for s, moving away from a hardfork-centric . hese new library versions complete our ypecript transition and all now provide a modern  romise-based . urthermore, necessary refactors have been done on the block and t libraries to get rid of technical debt. ou can read more on the release in thennblog postnnon the  blog, covering things in a lot more detail.nnhese new releases provide the ground for us to turn more strongly towards protocol research and development. urnnethereumjs/clientnn, which we have justnnintegratednninto our monorepo, will play a central role. uilding upon the new , ommon and lockchain release versions we are now able to finish a conceptually simple full-sync implementation on the client and start to join development efforts around developer testnets like thennolonnornn-nntest networks. he client is far from being ready for mainnet but will serve us well in all sorts of development and research scenarios.nnhere is continued development onnnthersnnas well, andnnricmoonnhas done  (!) small feature and bug fi releases since the bignnv releasennin une  (see preceding beta release notes for the full picture). oteworthy features are the added support for - signed typed data innnv..nnand new  resolver functions for contentash innnv..nn, together with many smaller fies and improvements introduced.  lot of work has also been done on thers to ensure it remains a reliable infrastructure component in the large ecosystem it is used within. n eample here is the work to ensure more robust lchemy and nfura provider support seennv..nnand subsequent releases. ee thisnnblog postnnfor a more in-depth update on the latest highlights.nneminnuthored by ann evreau & ob tupaynnn the past  months, emi roject has undergone more than a modicum of developmental loveliness. e’ve updated the functionality, the quality of the codebase, and the ability of the  to work with other projects. e have also been preparing for future iterations of the . nd yet, the totality of our programmatic handiwork would mean nothing if we didn’t reach out to teach new users, partner with other organizations and grow our community. o we did!nnemi  is used by both newcomers to thereum and by eperienced devs. e have fortified the tool for both types of users. e have also been striving to improve the ev for those coding plugins for  as well as ensuring that their plugins look good and continue to function well.nnhere are some large changes coming to emi. urrently the  uses the yoyo framework, which is no longer being maintained. o we are moving on and have begun the transition to eact and also to heia - a framework specifically for building s. n addition, we have finished the first iteration of a emi plugin for ode.nnee the specifics of the updates onnnour blog post about the last si monthsnn.nnnake harmers ython cosystem y/rinity/eb.py/yper]nnuthored by iper erriamnne-ang, a new smart contract language is under active development.nnhe language was originally born as a rewrite of the yper compiler (in ust) but has since moved on to follow its own path. ore on the backstory and goals can be read in thennofficial announcement postnn.nne are on track to have an - implementation in e functional before the end of the year. o be clear, the compiler will in no way be a suitable choice for a production  by that time, but we look forward to demonstrating the capabilities of e with such a well understood working eample.nnore information can be found atnnhttps//fe.ethereum.org/nnas well as our most recentnndevelopment updatenn.nnhe rinity team is winding down development on the rinity thereum client in order to re-focus on more impactful problems with the core protocols.nne are starting work to build out a  based network for more effectively serving the chain history, as well as continued research on how to solve on-demand state availability. he project is moving forward under the name “leandria”. ead more in our recentnndevelopmentnnupdatesnn.nnhe eb.py team continues to focus on stability of the library which has matured nicely over the past years. ooking forward, we are still working towards implementing nativennasyncnnsupport. e are also working on eposing the th beacon chain s.nntateless thereumnnuthored by iper erriamnnhe “tateless thereum” effort continues. n our latest call earlier in ovember we reviewed the roadmap and goals. eams are actively working on conversion of the main thereum state trie from its current heary format to a new binary format, as well as a modification to introduce a merklization layer to the way that contract code is stored. hese two changes have the largest impact on reducing witness sizes. e-genesis is also under active research as it provides major benefits to client developers, allowing them to drop old fork rules from their codebases while also giving us an incremental path towards full statelessness.nnecurity ecurity / onsensus ests]nnuthored by artin olst wendenne've started doing bi-weekly cross-client fuzzing calls among client developers, where we've been iterating on the practicalities of evm-based fuzzing, getting the clients to agree on formats and chain definitions. e've performed ~ fuzzed testcases focusing on v, specifically -, between eth,  and esu.nnurther improvements and additions to ive (nnhttps//hivetests.ethdevops.ionn), to epand the protocol testing capabilities and cover a larger portion of the / protocol. lso improve documentation and , to make it easier for other eth teams to integrate/use for testing, and make it possible to use for eth clients later on.nno-ethereum is now enrolled in -uzz, which resulted in an upstream o-lang bug being detected. ince the integration, we've further improved and epanded the fuzzing targets.nnork in progress that we hope will land soon, is to implement a(n optional) vulnerability-check into eth, which fetches information from a vulnerability-feed that can be used to check if the client suffers from any known vulnerability.nnhe forkmon (nnhttps//forkmon.ethdevops.ionn) has been created, and  public and/or nodes are connected to it. t is a dashboard to help visualizennif the various clients are in agreement the head blocknnif not, where the disagreement (fork) startednnwhether any particular client has become stucknne have also epanded on the number of in-house clients that are used for monitoring the ainnet, which now includes eth, esu, ethermind and penthereum.nnoliditynnuthored by ranziska eintel and hristian eitwiessnernnnd of uly, olidity v.. wasnnreleasednn. ou can find a detailed list of all breaking changesnnherenn.nnith the olidity .. release being just around the corner, we wanted to try out a new format to share the implementation details and changes of breaking releases with you beforehand. ence, we published a preview release. hennpreview release postnnincludes .. test binaries as well as a detailed description of the upcoming “hecked rithmetic” feature (bye bye afeath!) with its three sub-features. e hope you find these kind of preview releases helpful and look forward to hearing your thoughts on the implementation of the breaking changes. nd, as per usual, if you are interested in discussing language design with us, make sure to join the solidity-usersnnmailing listnn!nnt the moment, the olidity team is working on the last items to get into olidity .. ost notably, adding overflow checks for arithmetic operations and the activation of  coder  by default. ee above for the preview release!nnhe second big chunk of work, which is also nearing completion, is the use of ul as an intermediate language in the compiler. or this, we re-implemented most of the code generator. ou can try it out usingnnsolc --eperimental-via-irnnornnsolc --irnnandnnsolc --ir-optimized --optimizenn. he goal of using ul is that the compiler gets more transparent because you can actually read and understand the code it generates. urthermore, it allows more opportunities for optimization and you might soon say goodbye to “stack too deep” errors!
ith regard to features, we want to change the olidity language to support more items at the file-level, which allows you to better structure your code and introduce nicely isolated helper functions.
inally, with the introduction of error codes, you will soon be able to flag problems that are readable to the user and at the same time only consume little gas.
h and then the language server...nnolidity ummitnnhe first olidity ummit took place online on pril -  and featured discussions & talks on olidity, ul, language design and tooling. he event encouraged discussions around language design and language improvement and aimed to foster communication between teams working on similar topics. urthermore, the goal was to identify needs for the thereum smart contract ecosystem. ith enough content and talks for a packed agenda over two days, it was a great success. he conference featured  talks and  open discussion rounds. o learn more, read thennrecapnnof the event or watch the videos of all talks online in thisnnplaylistnn. e are planning to host more olidity ummits in future and will keep you updated on when and how.nnolidity anguage ortal & omainsnnn ctober, we were ecited tonnannouncennthe launch of thennolidity language portalnn, a one-stop-shop for all important links and high-level information around olidity. longside with the launch of this portal, we tidied up domains and moved most of thennolidity pagesnnunder the newnnsoliditylang.orgnndomain umbrella.
e have also recently changed the hosting of thennstatic buildsnn, which are now available atnnbinaries.soliditylang.orgnn. hile the transition should have been seamless for most users, please make sure to switch if you are still usingnnhttps//ethereum.github.io/solc-bin/nn.nnolidity nderhanded ontestnnhroughout ctober, we hosted a new edition of thennolidity nderhanded ontestnn. he contest’s goal is to raise awareness of smart contract security and uncover language design faults by writing innocent-looking olidity code, which contains malicious behavior or backdoors. ubmissions closed on ctober st and we are thrilled to share the winners with you in the coming days!nnourcifynnesides the core update, the olidity team has been working on an initiative called ourcify (formerly known as source-verify) for a while now. ourcify is a contract verification service and metadata repo, which aims to make interacting with smart contracts on the blockchain safer andnnmore transparentnnfor users. o achieve this goal, ourcify supports several efforts to foster adoption of open-source source verification, metadata files and atpec comments.nnt its core, ourcify currently maintainsnnannninterfacennthat helps developers to verify metadata and contract source code.nnanncontract repositorynnof all verified contracts.nnannmonitoring & verifier servicennthat checks for new contracts on thereum blockchains (mainnet and testnets) and tries to verify them automatically.
ou can follow ourcify’s progress onnnithubnnandnnwitternn.nnast, but not least, wenncelebratednnthe th birthday of olidity version .. with a walk down memory lane, reflections on + years of language design and a brief look into the future.nn esearchnnuthored by mitry hovratovich, ary aller and ankrad eistnnmproving -based snnhe idea is to prove a long incompressible iteration using a zk (en-asson et al). e suggested a new iterative construction with increased performance and security over the tarkware proposal eedo. he new one minimizes the arithmetic operations per step and reduces the hardware requirements. e also analyzednnow time-memory tradeoffs can affect the construction and suggested secure parameters.nnuantum attacks on the function and quantum enhancements to tradeoff algorithms.nnesigning a more secure hash function for  applicationsnnurrent -friendly hash functions rely too much on algebraic attacks, but the proof system ltra (adding the lookup construction to ) adds a lookup table (like an  -bo) as a fast operation.
e show how to combine lookups with field operations to be fast both in proofs and in regular hashing.
he security relies much more on regular cryptanalysis than on (not much understood) roebner basis attacks.nnew protocol for ingle ecret eader lection () that can be implemented in thnnhe consensus protocol in th is leader based. his means that for each shard, a leader is selected who is responsible for proposing blocks and driving progress. hus a malicious party could theoretically stall the entire network simply by ing the selected leader. e have designed a preventative measure against such attacks based on a single secret leader election () put forward by oneh and others.nnhe  ensures that the only person who knows who the leader is, is the leader themselves. he leader only reveals their identity upon proposing a block. hus our malicious party does not know who to attack. he  is achieved by shuffling encryptions in zero-knowledge. e have implemented a shuffle argument inspired by that of ayer and roth, but using more modern inner product arguments to improve efficiency. he argument is fast enough to be included in the th design and does not require a trusted setup. t is still awaiting a formal audit.nnoratesnnuthored by acob berhardtnne’ve been hard at work since our last update, and are happy to announce several new features and improvements today.
hroughout the last couple of months, we etended the orates language and compiler, added a new backend, and improved our documentation to make zks even more accessible to thereum developers today.nne etended support for unsigned integers with additional operators and efficiency tweaks. his allowed us to rewrite important standard library functions, such as , fully in our  instead of relying on imports of hand-optimised circuits for performance.nno further improve usability and developer eperience, we added synta highlighting to the orates emi plugin, etended input validation, and enabled convenient input forms for comple data types.nns groundwork for the integration of new proving schemes and recursive proof composition, we added support for thennrkworksnnzk libraries as an additional backend (nnthis library was called  until very recentlynn). e thank the  lockchain & team for their valuable contributions in this contet!
uilding on that, we are currently working towards enabling recursive zk composition within the orates toolbo.nnesides the usual documentation updates to describe new features and changes, we added a new tutorial to help onboarding new users.nne’ll close with a little teaser e’re getting close to finalizing support for generic orates programs that depend on compile-time constants. his will significantly improve code reusability and make our standard library easier to use. tay tuned.