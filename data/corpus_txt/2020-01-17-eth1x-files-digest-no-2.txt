Titre: The 1.x Files: January call digest\nAuteur: Griffin Ichiba Hotchkiss\nDate: January 17, 2020\nURL: https://blog.ethereum.org/2020/01/17/eth1x-files-digest-no-2\nCatégorie: Non catégorisé\n\n==================================================\n\nanuary th tldc (too long, didn't call)nnisclaimernnnnhis is a digest of the topics discussed in the recurring th. research call, and doesn't represent finalized plans or commitments to network upgrades.nnhe main topics of this call werennough data quantifying advantages of switching to a binary trie structurennransition strategies and potential challenges for a switch to binary triesnn"erklizing" contract code for witnesses, and implications for gas scheduling/meteringnnhain pruning and historical chain/state data -- network implications and approaches to distribution.nnogisticsnnhe weekend following th (arch -), there will be a small . research summit, with the intent of having a few days of solid discussion and work on the topics at hand. he session will be capped (by venue constraints) at  attendees, which should be more than enough for the participants epected.nnhere will also likely be some informal, ad-hoc gathering around tanford lockchain week and enver, but nothing eplicitly planned.nnhe net call is tentatively scheduled for the first or second week in ebruary -- half-way between now and the summit in aris.nnechnical discussionnn #nnlthough not directly related to stateless ethereum, this  improves the network protocol for transaction propagation, and is thus a pretty straightforward improvement that moves things in the right direction for what research is working on. upport!nninary rie size savingsnnransitioning to a binary trie structure (instead of the current heary trie structure) should in theory reduce the size of witnesses by something like .,nnbut in practice that reduction might only be about half, depending on how you look at it.nn.nnitnesses are about % code and % hashes. ashes within the trie are reduced by , but code is not improved with a binary trie, since it always needs to be included in the witness. o switching to a binary trie format will bring witness sizes to ~-k, down from ~-,k in the heary trie.nnaking the switchnnnacting the actual transition to a binary trie is another matter, with a few questions that need to be fleshed out. here are essentially two different possible strategies that could be followednnprogressive transitionnn-- his is a 'ship of heseus' model of transition whereby the entire state trie is migrated to a binary format account-by-account and storagelot-by-storagelot, as each part of state is touched by  eecution. his implies that, forevermore, thereum's state would be a heary/binary hybrid, and accounts would need to be "poked" in order to be updated to the new trie format (maybe with a  opcode ). he advantages are that this does not interrupt the normal functioning of the chain, and does not require large-scale coordination for upgrading. he disadvantage is compleity both heary and binary trie formats need to be accounted for in clients, and the process would never actually "finish", because some parts of the state cannot be accessed eternally, and would need to be eplicitly poked by their owners which probably wont happen for the entire state. he progressive strategy would also require clients to modify their database to be a kind of 'virtualized' binary trie inside of a heary database layout, to avoid a sudden dramatic increase in storage requirements for all clients (note this database improvement can happen independent of the full 'progressive' transition, and would still be beneficial alone).nncompute and clean-cutnn-- his would be an 'at once' transition accomplished over one or more hard-forks, whereby a date in the future would be chosen for the switch, and then all participants in the network would need to recompute the state as a binary trie, and then switch to the new format together. his strategy would be in some sense 'simpler' to implement because it's straightforward on the engineering side. ut it's more comple from a coordination perspective he new binary trie state needs to be pre-computed before the fork which could take an hour (or thereabouts) -- during that window, its not clear how transactions and new blocks would be handled (because they would need to be included in the yet-un-computed binary state trie, and/or the legacy trie). his process would be made harder by the fact that many miners and echanges prefer to upgrade clients at the last moment. lternatively we could imagine halting the entire chain for a short time to re-compute the new state -- a process which might be even trickier, and potentially controversial, to coordinate.nnoth options are still 'on the table', and require further consideration and discussion before any decisions are made with regards to net steps. n particular weighing the trade-offs between implementation compleity on one hand and coordination challenges on the other.nnode "chunking"nnddressing the code portion of witnesses, there has been some prototyping work done on code 'merklization', which essentially allows contract code to be split up into chunks before being put into a witness. he basic idea being that, if a method in a smart contract is called, the witness should only need to include the parts of the contract code that were actually called, rather than the entire contract. his is still very early research, but it suggests an additional ~% reduction in the code portion of a witness. ore ambitiously, the practice of code chunking could be etended to create a single global 'code trie', but this is not a well developed idea and likely has challenges of its own that warrant further investigation.nnhere are different methods by which code can be broken up into chunks, and then be used to generate witnesses. he first is 'dynamic', in that it relies on finding  instructions, and cleaving near those points, which results in variable chunk sizes depending on the code being broken up. he second is 'static', which would break up code into fied sizes, and add some necessary metadata specifying where correct jump destinations are within the chunk. t seems like either of these two approaches would be valid, and both might be compatible and could be left up to users to decide which to employ. ither way, chunking enables a further shrinking of witness sizes.nn(un)gasnnne open question is what changes would be necessary or desirable in gas scheduling with the introduction of block witnesses. itness generation needs to be paid for in gas. f the code is chunked, within a block there would be some overlap where multiple transactions cover the same code, and thus parts of a block witness would be paid for more than once by all the included transactions in the block. t seems like a safe idea (and one that would be good for miners) would be to leave it to the poster of a transaction to pay the full cost of their own transaction's witness, and then let the miner keep the overpayment. his minimizes the need for changes in gas costs and incentivizes miners to produce witnesses, but unfortunately breaks the current security model of only trusting sub-calls (in a transaction) with a portion of the total committed gas. ow that change to the security model is handled is something that needs to be considered fully and thoroughly. t the end of the day, the goal is to charge each transaction the cost of producing its own witness, proportional to the code it touches.nnei ang's  proposalnnmight make any changes to the  easier to accomplish. t's not strictly necessary for stateless thereum, but it is an idea for how to make future breaking changes to gas schedules easier. he question to ask is "hat do the changes look like both without and with  -- and those things considered, does  actually make this stuff significantly easier to implement". o answer this, we need eperiments that run things with merklized code and new gas rules appled, and then see what should change with regard to cost and eecution in the .nnruning and data deliverynnn a stateless model, nodes that do not have some or all of the state need a way to signal to the rest of the network what data they have and what data they lack. his has implications for network topology -- stateless clients that lack data need to be able to reliably and quickly find the data they need somewhere on the network, as well as broadcast up-front what data they don't have (and might need). dding such a feature to one of the chain-pruning s is a networking (but not consensus) protocol change, and its something that also can be done now.nnhe second side of this problem is where to store the historical data, and the best solution so far proposed is an th-specific distributed storage network, that can serve requested data. his could come in many flavors the complete state might be amenable to 'chunking', similar to contract code partial-state nodes could watch over (randomly assigned) chunks of state, and serve them by request on the edges of the network clients might employ additional data routing mechanism so that a stateless node can still get missing data through an intermediary (which doesn't have the data it needs, but is connected to another node that does). owever it's implemented, the general goal is that clients should be able to join the network and be able to get all the data they need, reliably, and without jockying for position connecting to a full-state node, which is effectively what happens with  nodes now. ork surrounding these ideas is still in early stages, but the geth team has some promising results eperimenting with 'state tiling' (chunking), and turbo-geth is working on data routing for gossiping parts of state.nns always, if you have questions about th efforts, requests for topics, or want to contribute, attend an event, come introduce yourself on ethresear.ch or reach out to gichiba and/or ancock on twitter.