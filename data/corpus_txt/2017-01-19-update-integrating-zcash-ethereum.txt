Titre: An Update on Integrating Zcash on Ethereum (ZoE)\nAuteur: Christian Reitwiessner\nDate: January 19, 2017\nURL: https://blog.ethereum.org/2017/01/19/update-integrating-zcash-ethereum\nCatégorie: Non catégorisé\n\n==================================================\n\nembers of the thereum & team and the cash ompany are collaborating on a research project addressing the combination of programmability and privacy in blockchains. his joint post is being concurrently posted on thenncash blognn, and is coauthored by riel abizon (cash) and hristian eitwiessner (thereum).nnthereum’s fleible smart contract interface enables a large variety of applications, many of which have probably not yet been conceived. he possibilities grow considerably when adding the capacity for privacy. magine, for eample, an election or auction conducted on the blockchain via a smart contract such that the results can be verified by any observer of the blockchain, but the individual votes or bids are not revealed. nother possible scenario may involve selective disclosure where users would have the ability to prove they are in a certain city without disclosing their eact location. he key to adding such capabilities to thereum is zero-knowledge succinct non-interactive arguments of knowledge (zk-s) - precisely the cryptographic engine underlying cash.nnne of the goals of the cash company, codenamednnroject lchemynn, is to enable a direct decentralized echange between thereum and cash. onnecting these two blockchains and technologies, one focusing on programmability and the other on privacy, is a natural way to facilitate the development of applications requiring both.nns part of the cash/thereum technical collaboration, riel abizon from cash visited hristian eitwiessner from the thereum hub at erlin a few weeks ago. he highlight of the visit is a proof of concept implementation of a zk- verifier written in olidity, based on pre-compiled thereum contracts implemented for the thereum ++ client. his work complementsnnaby onn, where a zk- precompiled contract was written for arity (the thereum ust client). he updates we've made involved adding tiny cryptographic primitives (elliptic curve multiplication, addition and pairing) and implementing the rest in olidity, all of which allows for a greater fleibility and enables using a variety of zk- constructions without requiring a hard fork. etails will be shared as they are available later. e tested the new code by successfully verifying a real privacy-preserving cash transaction on a testnet of the thereum blockchain.nnhe verification took only  milliseconds, which shows that such precompiled contracts can be added, and the gas costs for using them can be made to be quite affordable.nnhat can be done with such a systemnnhe cash system can be reused on thereum to create shielded custom tokens. uch tokens already allow many applications like voting, (see below) or simple blind auctions where participants make bids without the knowledge of the amounts bid by others.nnf you want to try compiling the proof of concept, you can use the following commands. f you need help, seennhttps//gitter.im/ethereum/privacy-technngitnnclone https//github.com/scipr-lab/libsnark.gitnncdnnlibsnarknnsudonnnnnn/usr/localnnmakenn_nnnnnn_nnnnnn_nnnnnnnnnnnn_nnnnnnnn"-_ -_ nn-__"nnnnlibnninstallnncdnn..nngitnnclone --recursive -b snark https//github.com/ethereum/cpp-ethereum.gitnncdnncpp-ethereumnn./scripts/install_deps.shnn&&nncmakenn.nn-nnnnnn-nnnnnn&&nnmakennethnncdnn..nngitnnclone --recursive -b snarks https//github.com/ethereum/solidity.gitnncdnnsoliditynn./scripts/install_deps.shnn&&nncmakenn.nn&&nnmakennsoltestnncdnn..nn./cpp-ethereum/eth/eth --test -d /tmp/testnn# nd on a second terminalnn./solidity/test/soltest -tnn"*/snark"nn-- --ipcpath   /tmp/test/geth.ipc  --show-messagesnne also discussed various aspects of integrating zk-s into the thereum blockchain, upon which we now epand.nneciding what precompiled contracts to definennecall that a  is a short proof of some property, and what is needed for adding the privacy features to the thereum blockchain are clients that have the ability to verify such a proof.nnn all recent constructions, the verification procedure consisted solely of operations on elliptic curves. pecifically, the verifier requires scalar multiplication and addition on an elliptic curve group, and would also require a heavier operation called a bilinear pairing.nns mentionednnherenn, implementing these operations directly in the  is too costly. hus, we would want to implement pre-compiled contracts that perform these operations. ow, the question debated is what level of generality should these pre-compiled contracts aim for.nnhe security level of the  corresponds to the parameters of the curve. oughly, the larger the curve order is, and the larger something called the embedding degree is, and the more secure the  based on this curve is. n the other hand, the larger these quantities are, naturally the more costly the operations on the corresponding curve are. hus, a contract designer using s may wish to choose these parameters according to their own desired efficiency/security tradeoff. his tradeoff is one reason for implementing a pre-compiled contract with a high level of generality, where the contract designer can choose from a large family of curves. e indeed began by aiming for a high level of generality, where the description of the curve is given as part of the input to the contract. n such a case, a smart contract would be able to perform addition in any elliptic curve group.nn complication with this approach is assigning gas cost to the operation. ou must assess, merely from the description of the curve, and with no access to a specific implementation, how epensive a group operation on that curve would be in the worst case.  somewhat less general approach is to allow all curves from a given family. e noticed that when working with the arreto-aehrig () family of curves, one can assess roughly how epensive the pairing operation will be, given the curve parameters, as all such curves support a specific kind of optimal te pairing. ere's annsketchnnof how such a precompile would work and how the gas cost would be computed.nne learned a lot from this debate, but ultimately, decided to "keep it simple" for this proof of concept we chose to implement contracts for the specific curve currently used by cash. e did this by using wrappers of the corresponding functions in thennlibsnarknnlibrary, which is also used by cash.nnote that we could have simply used a wrapper for the entire  verification function currently used by cash, as was done in the above mentioned aby o project. owever, the advantage of eplicitly defining elliptic curve operations is enabling using a wide variety of  constructions which, again, all have a verifier working by some combination of the three previously mentioned elliptic curve operations.nneusing the cash setup for new anonymous tokens and other applicationsnns you may have heard, using s requires anncomple setup phasennin which the so-called public parameters of the system are constructed. he fact that these public parameters need to be generated in a secure way every time we want to use a  for a particular circuit significantly, hinders the usability of s. implifying this setup phase is an important goal that we have given thought to, but haven't had any success in so far.nnhe good news is that someone desiring to issue a token supporting privacy-preserving transactions can simply reuse the public parameters that have already been securely generated by cash. t can be reused because the circuit used to verify privacy-preserving transactions is not inherently tied to one currency or blockchain. ather, one of its eplicit inputs is the root of a erkle tree that contains all the valid notes of the currency. hus, this input can be changed according to the currency one wishes to work with. oreover, if it is easy to start a new anonymous token. ou can already accomplish many tasks that do not look like tokens at first glance. or eample, suppose we wish to conduct an anonymous election to choose a preferred option amongst two. e can issue an anonymous custom token for the vote, and send one coin to each voting party. ince there is no “mining”, it will not be possible to generate tokens any other way. ow each party sends their coin to one of two addresses according to their vote. he address with a larger final balance corresponds to the election result.nnther applicationsnn non-token-based system that is fairly simple to build and allows for “selective disclosure” follows. ou can, for eample, post an encrypted message in regular intervals, containing your physical location to the blockchain (perhaps with other people’s signatures to prevent spoofing). f you use a different key for each message, you can reveal your location only at a certain time by publishing the key. owever, with zk-s you can additionally prove that you were in a certain area without revealing eactly where you were. nside the zk-, you decrypt your location and check that it is inside the area. ecause of the zero-knowledge property, everyone can verify that check, but nobody will be able to retrieve your actual location.nnhe work aheadnnchieving the mentioned functionalities - creating anonymous tokens and verifying cash transactions on the thereum blockchain, will require implementing other elements used by cash in olidity.nnor the first functionality, we must have an implementation of tasks performed by nodes on the cash network such as updating the note commitment tree.nnor the second functionality, we need an implementation of the equihash proof of work algorithm used by cash in olidity. therwise, transactions can be verified as valid in themselves, but we do not know whether the transaction was actually integrated into the cash blockchain.nnortunately, such an implementation wasnnwrittennn however, its efficiency needs to be improved in order to be used in practical applications.nncknowledgementnn e thank ean owe for technical assistance. e also thank ean and italik uterin for helpful comments, and ing han for editing.