Titre: Go Ethereum’s JIT-EVM\nAuteur: Jeffrey Wilcke\nDate: June 2, 2016\nURL: https://blog.ethereum.org/2016/06/02/go-ethereums-jit-evm\nCatégorie: Non catégorisé\n\n==================================================\n\nhe thereum irtual machine is kind of different than most other irtual achines out there. n mynnprevious postnn already eplained how it’s used and described some of its characteristics.nnhe thereum irtual achine () is a simple but powerful, uring complete bit irtual achine that allows anyone to eecute arbitrarynn yte odenn.nnhe go-ethereum project contains two implementations of the .  simple and straightforwardnnbyte-code nnand a more sophisticatednn-nn. n this post ’m going to eplain some of the differences between the two implementations and describe some of the characteristics of the   and why it can be so much faster than the byte-code .nno-ethereum’s yte ode irtual achinennhe ’s internals are pretty simple it has a single run loop which will attempt to eecute the instruction at the currentnnrogram ounter (nnin short). ithin this loop thennasnnis calculated for each instruction, memory is epanded if necessary and eecutes the instruction if the preamble succeeds. his will continue on until the  either finishes gracefully or returns with an error by throwing an eception (e.g.nnout-of-gasnn).nnfornnopnnnncontractnnnnpcnn]nn{nnifnn!nnsufficientasnn(nnopnn)nn{nnreturnnnerrornn(nn"insufficient gas for op"nn, ornn)nn}nnswitchnnopnn{nncasenn..nn.nn/* eecute */nncasennnnreturnnnmemorynnnnstacknnnn-nn]nn, stacknnnn-nn]nn]nn}nnpc++nn}nnt the end of the eecution loop the program-counter gets increment to run the net instruction and continues to do so until it has finished.nnhe  has another way tonnchangennthe program-counter through something callednnjumpnn-instructions (nnnn&nn).nnnstead of letting the program-counter increment (pc++) the  can also jump to arbitrary positions in the contract code. he  knows two jump instructions, a normal jump that reads as “nnjump to position nn” and a conditional jump that read as “nnjump to position  if condition  is truenn”. hen either such a jump occurs it must always land on annjump-destinationnn. f the program lands on an instruction other than a jump destination the program fails — in other words, for a jump to be valid it must always be followed by a jump-destination instruction if the condition yielded true.nnrior to running any thereum program the  iterates over the code and finds all possible jump-destinations, it then puts them in a map that can be referenced by the program-counter to find them. ach and every time the  encounters a jump-instructions the jump validity is checked.nns you can see the eecuting code is relatively easy and simply interpreted by the byte-code , we may conclude even that through its sheer simplicity it’s actually pretty dumb.nnelcome  nnhe - takes a different approach to running  byte-code and is by definitionnninitiallynnslower than the byte-code . efore the  can run any code it must firstnncompilennthe byte-code in to components that can be understood by the  .nnhe initialisation- and eecution procedure is done in -stepsnne check whether there’s a  program ready to be run using the hash of the code —nn()nnis used as an identifier to identify the programnnif a program was found we run the program and return the resultnnif no program was found we run the byte-codennandnnwe compile a  program in the background.nnnitially  tried to check whether the  program had finished compiling and move the eecution over to the  — this all happened during runtime in the same loop using o’snnatomicnnpackage — unfortunately it turned out to be slower than letting the byte-code  run and use the  program for every sequential call after the compilation of the program had finished.nny compiling the byte-code in to logical pieces the  has the ability to analyse the code more precisely and optimise where and whenever necessary.nnor eample an incredible simple optimisation that  did was compiling severalnnpushnnoperation in to a single instruction. et’s take thennnninstruction call requires  push instructions — i.e. gas, address, value, input-offset, input-size, return-offset and return-size — prior to eecuting it, and what  did instead of looping through these  instructions, eecuting them one by one, ’ve optimised this away by taking the  instructions and append the  values in to a single slice. ow, whenever thennstartnnof the  push instructions is eecuted, it instead eecutes the one optimised instruction by immediately appending the static slice to the  stack. ow of course this only works for static values (i.e.nnpush ),nnbut these are present in the code quite a lot.nn’ve also optimised thennstatic jumpnninstructions. tatic jumps are jumps who always jump to the same position (i.e.nnpush , jumpnn) and never change under any circumstance. y determining which jumps are static we can pre-check whether a jump is valid and lies within the bounds of the contract and if so we create a new instructions that replaces both thennpushnnandnnjumpnninstruction and is flagged asnnvalidnn. his prevents the  from having to do two instructions and it prevents it from having to check whether the jump is valid and doing an epensive hash-map lookup for valid jump position.nnet stepsnnull stack and memory analysis would also fit nicely in this model where large chunks of code could fit in to single instructions. urther ’d like to addnnsymbolic-eecutionnnand turn the  in to a proper -.  think this would be a logical net step once programs get large enough to take advantage of these optimisations.nnonclusionnnnnur - is a whole lot smarter than the byte-code , but is far from being completely done (if ever). here are many more clever tricks we could add with this structure, but simply aren’t realistic for the moment. he runtime is within the bounds of being “reasonable” speedy. ay the need arise to further optimise the  we have the tools to do so.nnurther code-readingnnyte code  eecutionnn  ompilationnn  rogram eecutionnn  ptimisernnross posted from - https//medium.com/jeff.ethereum/go-ethereums-jit-evm-ef#.edljdz